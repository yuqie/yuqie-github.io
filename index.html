<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="Home is behind, the world ahead">
<meta property="og:type" content="website">
<meta property="og:title" content="Ringinmay&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Ringinmay&#39;s Blog">
<meta property="og:description" content="Home is behind, the world ahead">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="QQAI">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>Ringinmay's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ringinmay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Home is behind, the world ahead</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="post-title-link" itemprop="url">操作系统</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-15 11:20:39" itemprop="dateCreated datePublished" datetime="2020-09-15T11:20:39+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 10:54:24" itemprop="dateModified" datetime="2020-09-16T10:54:24+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p><img src="操作系统.assets\1600217528868.png" alt="1600217528868"></p>
<h3 id="x86-系统的结构"><a href="#x86-系统的结构" class="headerlink" title="x86 系统的结构"></a>x86 系统的结构</h3><p><img src="操作系统.assets\1600160298027.png" alt="1600160298027"></p>
<h4 id="PCI-E"><a href="#PCI-E" class="headerlink" title="PCI-E"></a>PCI-E</h4><p>PCIe (Peripheral Component Interconnect Express，PCI-Express)一种高速串行计算机扩展总线标准，PCIe属于高速串行点对点双通道高带宽传输，所连接的设备分配独享通道带宽，不共享总线带宽，主要支持主动电源管理，错误报告，端对端的可靠性传输，热插拔以及服务质量(<a href="https://baike.baidu.com/item/QOS" target="_blank" rel="noopener">QOS</a>)等功能。</p>
<p>PCIe Sizes：x16 vs x8 vs x4 vs x1</p>
<p>x后面的数字表示PCIe卡或插槽的物理大小，x16是最大的，x1是最小的。以下是各种尺寸的形状：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-</th>
<th>Number of Pins（引脚的数量）</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCI Express x1</td>
<td>18</td>
<td>25毫米</td>
</tr>
<tr>
<td>PCI Express x4</td>
<td>32</td>
<td>39毫米</td>
</tr>
<tr>
<td>PCI Express x8</td>
<td>49</td>
<td>56毫米</td>
</tr>
<tr>
<td>PCI Express x16</td>
<td>82</td>
<td>89毫米</td>
</tr>
</tbody>
</table>
</div>
<p>不管PCIe插槽或卡片的大小是多少，关键的凹槽，卡或槽中的小空间，总是在大头针11上。</p>
<p>PCIe卡片适合于主板上的任何PCIe插槽，它的大小至少和它一样大。例如，PCIe x1卡将适用于任何PCIe x4、PCIe x8或PCIe x16插槽。</p>
<p><img src="https://img-blog.csdn.net/20180718153127412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JqYXJuZUNwcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="MDI"><a href="#MDI" class="headerlink" title="MDI"></a>MDI</h4><p>Medium Dependent Interface ，介质相关接口。在 hub 或 switch 中有两种接口，分别叫 MDI port和 MDI-X port， MDI port 也叫做级联端口（ uplink port ），是 hub 或 switch 之间相互连接的端口。 </p>
<p>MDI port和 MDI-X port 之间最大的区别在于， MDI port内部发送数据线和接收数据线没交叉， 而MDI-X port 内部发送数据线和接收数据线是交叉的，这个X代表交叉的意思。</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/9345d688d43f8794964ce0bdd31b0ef41ad53af5?x-bce-process=image/resize,m_lfit,w_250,h_250,limit_1" alt="img"></p>
<p>计算机和交换机的连接要用直通线，交换机和交换机之间的连接要用交叉线，</p>
<h4 id="DMI"><a href="#DMI" class="headerlink" title="DMI"></a>DMI</h4><p>DMI是指Direct Media Interface(直接媒体接口)，用于连接主板南北桥的总线，取代了以前的Hub-Link总线。它基于<a href="https://baike.baidu.com/item/PCI-Express" target="_blank" rel="noopener">PCI-Express</a>总线，跟随PCI-E总线的换代而换代。DMI采用点对点的连接方式，时钟频率为100MHz。</p>
<h4 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h4><p>USB(Univversal Serial Bus) 连接慢速 I/O 设备和计算机。USB 1.0 ：12 Mb/s，USB 2.0 总线速度 480Mb/s，USB 3.0不小于 5Gb/s。USB连接不需要重启计算机。</p>
<h4 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h4><p>SCSI(Small Computer System Interface) 总线是一种高速总线，用在高速硬盘，扫描仪和其他需要较大带宽的设备上。现在，它们主要用在服务器和工作站中，速度可以达到640MB/s。</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><blockquote>
<ol>
<li><p>rom最初不能编程，出厂什么内容就永远什么内容，不灵活。</p>
</li>
<li><p>后来出现了prom，可以自己写入一次，要是写错了，只能换一片。</p>
</li>
<li><p>人类文明不断进步，终于出现了可多次擦除写入的EPROM，每次擦除要把芯片拿到紫外线上照一下.</p>
</li>
<li><p>历史的车轮不断前进，伟大的EEPROM出现了，拯救了一大批程序员，终于可以随意的修改rom中的内容了。</p>
<p>ROM—PROM—EPROM—EEPROM的进化！</p>
</li>
</ol>
</blockquote>
<h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p>全称是“电可擦除可编程只读存储器，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。</p>
<h4 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h4><p>狭义的EEPROM：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。</p>
<p>Flash属于广义的EEPROM，也是电擦除的rom。但擦除时不再以字节为单位，而是以块为单位，一次简化了电路，数据密度更高，降低了成本。上M的rom一般都是flash。</p>
<p>flash分为nor flash和nand flash。</p>
<blockquote>
<ol>
<li>nor flash数据线和地址线分开，可以实现ram一样的随机寻址功能，可以读取任何一个字节。但是擦除仍要按块来擦。</li>
<li>nand flash同样是按块擦除，但是数据线和地址线复用，不能利用地址线随机寻址。读取只能按页来读取。（nandflash按块来擦除，按页来读，norflash没有页）</li>
<li>由于nandflash引脚上复用，因此读取速度比nor flash慢一点，但是擦除和写入速度比nor flash快很多。nand flash内部电路更简单，因此数据密度大，体积小，成本也低。因此大容量的flash都是nand型的。小容量的2～12M的flash多是nor型的。</li>
<li>使用寿命上，nand flash的擦除次数是nor的数倍。而且nand flash可以标记坏块，从而使软件跳过坏块。nor flash 一旦损坏便无法再用。</li>
<li>因为nor flash可以进行字节寻址，所以程序可以在nor flash中运行。嵌入式系统多用一个小容量的nor flash存储引导代码，用一个大容量的nand flash存放文件系统和内核。</li>
</ol>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/Pual623548198/p/7085319.html" target="_blank" rel="noopener">https://www.cnblogs.com/Pual623548198/p/7085319.html</a></p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><h4 id="基本输入输出系统-Basic-Input-Output-System-BIOS"><a href="#基本输入输出系统-Basic-Input-Output-System-BIOS" class="headerlink" title="基本输入输出系统(Basic Input Output System, BIOS)"></a>基本输入输出系统(Basic Input Output System, BIOS)</h4><p>保存在闪存中，非易失性。</p>
<p>有底层I/0软件：读键盘，写屏幕，磁盘I/O。</p>
<p>计算机启动时，检查设备，通过尝试存储在CMOS存储器中的设备清单尝试启动设备。</p>
<p>决定从外部（CD-ROM，USB）还是硬盘启动。</p>
<h4 id="互补金属氧化物半导体-Complementary-Metal-Oxide-Semiconductor-CMOS"><a href="#互补金属氧化物半导体-Complementary-Metal-Oxide-Semiconductor-CMOS" class="headerlink" title="互补金属氧化物半导体(Complementary Metal Oxide Semiconductor , CMOS)"></a>互补金属氧化物半导体(Complementary Metal Oxide Semiconductor , CMOS)</h4><p>电脑主板上的一块可读写的RAM芯片。用来保存BIOS设置完电脑硬件参数后的数据。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>大型机操作系统</p>
<p>服务器操作系统：典型的服务器操作系统有Solaris， FreeBSD，Linux，Windows Server 201x</p>
<p>多处理器操作系统：将多个CPU连接到一个系统中，并行计算机（多核处理器）</p>
<p>个人计算机系统：Linux，FreeBSD，Windows 7，Windows 8 ， OS X</p>
<p>掌上计算机：Abdroid和IOS</p>
<p>嵌入式操作系统：</p>
<p>传感器节点操作系统：</p>
<p>实时操作系统：硬实时系统和软实时系统</p>
<p>智能卡操作系统：信用卡</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>本质是操作系统执行的一个程序。</p>
<h5 id="地址空间："><a href="#地址空间：" class="headerlink" title="地址空间："></a>地址空间：</h5><p>32位有2^32字节的地址空间，64位有2^64字节的地址空间。</p>
<p>通常，每个进程有一些可以使用的地址集合，典型值从0开始到某个最大值，一个进程可拥有的最大地址空间小于主存，这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p>
<blockquote>
<p>如果进程的地址空间比主存还大，可以把部分地址空间装入主存，部分留在磁盘，并在需要时来回交换（虚拟内存）</p>
</blockquote>
<p>磁芯映像 core image</p>
<p>资源集：寄存器（程序计数器和堆栈指针），打开文件的清单等 （这些都在进程表中）</p>
<p>进程表：与一个进程相关的所有信息，除了该进程自身空间的内容以外，均存放在操作系统的一张表中。是数组或者链表结构，当前存在每一个进程都占据其中的一项。</p>
<p>进程间通信：合作完成某些作业的相关进程需要彼此通信</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>读写之前，检查访问权限，若权限许可，系统返回一个小整数（文件描述符），若禁止访问，系统返回一个错误码。</p>
<p>UNIX的特殊文件：为了使系统向调用读写文件一样调用I/O设备</p>
<p>块特殊文件：可随机存取的块组成的设备，比如磁盘</p>
<p>字符特殊文件：用于打印机，调制解调器和其他接受或输出字符流的设备。</p>
<p>管道：一种虚文件，可以用来连接两个进程。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>提供应用程序抽象：创建，写入，读取和删除文件。</p>
<p>管理计算资源：</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>以系统调用read(fd, buffer, nbytes)为例</p>
<p><img src="操作系统.assets\1600168907591.png" alt="1600168907591"></p>
<p>首先把参数压入栈堆：1. C和C++编译器使用逆序 2. 第二个参数通过引用传递，即传递的是缓冲区的地址 &amp;</p>
<p>TRAP指令：将用户态切换到内核态。</p>
<p>完成调用之后，操作系统需要清除用户堆栈，增加堆栈指针（increment stackpointer）</p>
<h5 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h5><p>fork创建原有进程的副本，包括所有的文件描述，寄存器等。fork调用返回一个值，在子进程中为0，在父进程中等于子进程的进程标识符（Process IDentified，PID）。</p>
<h5 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h5><p>O_RDONLY O_WRONLY O_RDWR</p>
<p>iseek(fd,offset,whence)</p>
<h5 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h5><p>mkdir   rmdir</p>
<p>link(name1,name2) 允许同一个文件以两个或者多个名称出现。</p>
<p>每个文件都独一无二，i-number 是inodes表的索引。目录是一系列（i-编号，ASCII名称）的集合。</p>
<p>link利用某个已有文件的i-编号，穿件一个新的目录项。</p>
<p>mount(specila, name, flag)将两个文件系统合并为一个。<img src="操作系统.assets\1600174254344.png" alt="1600174254344"></p>
<h5 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h5><p>chdir    chmod   kill</p>
<h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>UNIX程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。</p>
<p>Windows应用程序通常是由事件驱动的，主程序等待一些时间发生，然后调用程序去处理。</p>
<p>win中函数库的调用和实际的系统调用几乎是不对应的。</p>
<p><img src="操作系统.assets\1600174669528.png" alt="1600174669528"></p>
<p>windows中没有类似UNIX中的进程层次，不存在父进程和子进程的概念。</p>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><p>内核态以单一程序的方式运行</p>
<p><img src="操作系统.assets\1600216350126.png" alt="1600216350126"></p>
<p>除了核心操作系统外，操作系统还支持扩展：I/O设备驱动和文件系统。UNIX中叫做<strong>共享库（shared library）</strong>，windows中叫做**动态链接库（Dynamic Link Library，DLL）</p>
<h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>使用层来分隔不同的功能单元，每一层只与该层的上层和下层通信。上层软件都是在下层软件的基础之上构建的。</p>
<p><img src="操作系统.assets\1600216585570.png" alt="1600216585570"></p>
<p><img src="操作系统.assets\1600216594038.png" alt="1600216594038"></p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>在分层方式中，确定哪里划分内核-用户的分界。</p>
<p>MINIX3</p>
<p><img src="操作系统.assets\1600217029845.png" alt="1600217029845"></p>
<p>微内核中机制与策略分离，内核均值寻找最高的优先级进程并运行，策略（赋予进程优先级）可以在用户态中的进程完成。</p>
<h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><p>当策略将进程分为两大类：服务器（提供服务）和客户端（使用服务）——客户-服务模式。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><img src="操作系统.assets\1600217767997.png" alt="1600217767997"></p>
<h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程是对正在运行中的程序的一个抽象。即使CPU只有一个，也支持（伪）并发操作（将单独的CPU抽象为多个虚拟机的CPU）</p>
<p>伪并行（pseudoparallelism）：单核或多核处理器同时执行多个进程，从而使程序更快，通过以非常有限的时间间隔在程序之间快速切换CPU产生并行感。</p>
<h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>进程包括：程序计数器，寄存器，变量当前值。</p>
<p>顺序进程（sequential process）</p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><ul>
<li><p>系统初始化（init）: 启动阶段穿件进程</p>
<blockquote>
<p>前台进程（numerous process）：同用户进行交互并完成工作</p>
<p>守护进程（daemons）：运行在后台，不与特定用户进行交互</p>
</blockquote>
</li>
<li><p>正在运行的程序执行了创建进程的系统调用（fork）</p>
<blockquote>
<p>​</p>
</blockquote>
</li>
<li><p>用户请求创建新进程</p>
<blockquote>
<p>交互式系统中，输入命令或者双击启动程序</p>
</blockquote>
</li>
<li><p>初始化一个批处理工作</p>
<blockquote>
<p>大型机的批处理系统</p>
<p>在UNIX中，系统调用(fork)后，创建一个与调用进程相关的副本，子进程有何父进程相同的内存映像，环境字符创和打开文件，子进程执行<code>execve</code>或者简单的系统调用来改变内存映像并运行一个新程序。</p>
<p>例如 shell中输入sort命令，shell会fork一个子进程，然后执行sort命令</p>
<p>Win32中，<code>CreateProcess</code>处理流程创建并将正确的程序加载到新的进程中。</p>
</blockquote>
</li>
</ul>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ul>
<li><p>正常退出(自愿)</p>
<blockquote>
<p>编译器完成给定程序的编译后，编译器执行一个系统调用告诉操作系统完成了工作</p>
<p>UNIX：<code>exit</code>  Windows: <code>ExitProcess</code></p>
<p>界面化的软件有可以点击关闭的按钮，用来通知进程删除其打开的临时文件，然后终止。</p>
</blockquote>
</li>
<li><p>错误退出(自愿)</p>
<blockquote>
<p>发出声明，给出错误参数，并退出</p>
<p>面向屏幕的交互式进程通常并不会直接退出</p>
</blockquote>
</li>
<li><p>严重错误（非自愿）</p>
<blockquote>
<p>进程引起的错误，通常由于程序中的错误导致，UNIX中，进程会受到信号（中断）</p>
<p>例如，执行一条非法指令，引用不存在的内存，或者除数为0</p>
</blockquote>
</li>
<li><p>被其他进程杀死（非自愿）</p>
<blockquote>
<p>UNIX kill；Win32中TerminateProcess</p>
</blockquote>
</li>
</ul>
<h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><ul>
<li><p>UNIX</p>
<p>进程和其所有子进程以及子进程的子进程共同组成一个进程组。</p>
</li>
<li><p>Windows</p>
<p>没有进程层次的概念。父进程可以得到一个特别的令牌（句柄），用来控制子进程，但该令牌可以移交给别的操作系统。UNIX中不能剥夺其子进程的进程权。</p>
</li>
</ul>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>
<p>当grep就绪，但输入进程还没能完成时，必须阻塞grep进程，直到输入完毕。</p>
<p><img src="操作系统.assets\1600220979244.png" alt="1600220979244"></p>
<ul>
<li>运行态：进程实际占用CPU时间片</li>
<li>就绪态：可运行，但因其他进程正在运行而处于就绪状态</li>
<li>阻塞态：除非某种外部时间发生，否则进程不能运行</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/09/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/09/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/" class="post-title-link" itemprop="url">网络相关知识</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-09 10:33:28" itemprop="dateCreated datePublished" datetime="2020-09-09T10:33:28+08:00">2020-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 10:47:08" itemprop="dateModified" datetime="2020-09-16T10:47:08+08:00">2020-09-16</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="HTTP知识"><a href="#HTTP知识" class="headerlink" title="HTTP知识"></a>HTTP知识</h2><h3 id="安全和幂等的概念"><a href="#安全和幂等的概念" class="headerlink" title="安全和幂等的概念"></a>安全和幂等的概念</h3><p>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。<br>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</p>
<p><strong>GET 方法是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。<br><strong>POST </strong>因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。</p>
<h3 id="HTTP的优缺点"><a href="#HTTP的优缺点" class="headerlink" title="HTTP的优缺点"></a>HTTP的优缺点</h3><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</p>
<p>HTTP 协议缺点是「无状态、明文传输」，同时还有一大缺点「不安全」。</p>
<blockquote>
<ol>
<li><p>无状态的好处，因为服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存用来对外提供服务。</p>
<p>无状态的坏处，既然服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。</p>
<p><strong>可以通过cookie解决</strong></p>
</li>
<li><p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。<br>但HTTP 的所有信息都暴露在了光天化日下，相当于信息裸奔。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那你号没了。</p>
</li>
<li><p>HTTP 比较严重的缺点就是不安全：</p>
<ul>
<li><p>通信使用明文（不加密），内容可能会被窃听。比如，账号信息容易泄漏，那你号没了。</p>
</li>
<li><p>不验证通信方的身份，因此有可能遭遇伪装。比如，访问假的淘宝、拼多多，那你钱没了。</p>
</li>
<li><p>无法证明报文的完整性，所以有可能已遭篡改。比如，网页上植入垃圾广告，视觉污染，眼没了。</p>
<p><strong>通过HTTPS解决：在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP/3 甚至把 TCP 层换成了基于 UDP 的 QUIC。</strong></p>
</li>
</ul>
</li>
</ol>
</blockquote>
<p><img src="网络常见知识.assets\1599625816283.png" alt="1599625816283"></p>
<h2 id="IP知识"><a href="#IP知识" class="headerlink" title="IP知识"></a>IP知识</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>IP 在 TCP/IP 参考模型中处于第三层，也就是网络层。<br>网络层的主要作用是：实现主机与主机之间的通信，也叫点对点（end to end）通信。</p>
<p>IP 地址（IPv4 地址）由 32 位正整数来表示，IP 地址在计算机是以二进制的方式处理的。</p>
<p><img src="网络常见知识.assets\1599626314741.png" alt="1599626314741"></p>
<p>IP地址最大$2^{32}$ ，大约43亿，IP 地址并不是根据主机台数来配置的，而是以网卡。</p>
<p><img src="网络常见知识.assets\1599626438580.png" alt="1599626438580"></p>
<h3 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h3><p>IP 地址分类成了 5 种类型，分别是 A 类、B 类、C 类、D 类、E 类。</p>
<p><img src="网络常见知识.assets\1599626499535.png" alt="1599626499535"></p>
<p>D 类和 E 类地址是没有主机号的，所以不可用于主机 IP，D 类常被用于多播，E 类是预留的分类，暂时未使用。</p>
<p><img src="网络常见知识.assets\1599626848504.png" alt="1599626848504"></p>
<p>多播用于将包发送给特定组内的所有主机。由于广播无法穿透路由，若想给其他网段发送同样的包，就可以使用可以穿透路由的多播。</p>
<ul>
<li>224.0.0.0 ~ 224.0.0.255 为预留的组播地址，只能在局域网中，路由器是不会进行转发的。</li>
<li>224.0.1.0 ~ 238.255.255.255 为用户可用的组播地址，可以用于 Internet 上。</li>
<li>239.0.0.0 ~ 239.255.255.255 为本地管理组播地址，可供内部网在内部使用，仅在特定的本地范围内有效。</li>
</ul>
<p>对于 A、B、C 类主要分为两个部分，分别是网络号和主机号。</p>
<p><img src="网络常见知识.assets\1599626543682.png" alt="1599626543682"></p>
<p>在 IP 地址中，有两个 IP 是特殊的，分别是主机号全为 1 和 全为 0 地址。</p>
<ul>
<li>主机号全为 1 指定某个网络下的所有主机，用于广播（广播地址用于在同一个链路中相互连接的主机之间发送数据包）</li>
<li>主机号全为 0 指定某个网络</li>
</ul>
<p>广播地址可以分为本地广播和直接广播：</p>
<ul>
<li>在本网络内广播的叫做本地广播。例如网络地址为 192.168.0.0/24 的情况下，广播地址是192.168.0.255 。因为这个广播地址的 IP 包会被路由器屏蔽，所以不会到达 192.168.0.0/24 以外的其他链路上。</li>
<li>在不同网络之间的广播叫做直接广播。例如网络地址为 192.168.0.0/24 的主机向192.168.1.255/24 的目标地址发送 IP 包。收到这个包的路由器，将数据转发给 192.168.1.0/24，从而使得所有 192.168.1.1~192.168.1.254 的主机都能收到这个包（由于直接广播有一定的安全问题，多数情况下会在路由器上设置为不转发。） 。</li>
</ul>
<h3 id="IP分类的优缺点"><a href="#IP分类的优缺点" class="headerlink" title="IP分类的优缺点"></a>IP分类的优缺点</h3><ol>
<li>同一网络下没有地址层次，比如一个公司里用了 B 类地址，但是可能需要根据生产环境、测试环境、开发环境来划分地址层次，而这种 IP 分类是没有地址层次划分的功能，所以这就缺少地址的灵活性。</li>
<li>A、B、C类有个尴尬处境，就是不能很好的与现实网络匹配。C 类地址能包含的最大主机数量实在太少了，只有 254 个。而 B 类地址能包含的最大主机数量又太多了，6 万多台机器放在一个网络下面，一般的企业基本达不到这个规模，闲着的地址就是浪费。</li>
</ol>
<h3 id="无分类地址-CIDR"><a href="#无分类地址-CIDR" class="headerlink" title="无分类地址 CIDR"></a>无分类地址 CIDR</h3><p>32 比特的 IP 地址被划分为两部分，前面是网络号，后面是主机号。表示形式 a.b.c.d/x ，其中 /x 表示前 x 位属于网络号， x 的范围是 0 ~ 32 ，这就使得 IP 地址更加具有灵活性。</p>
<p>另一种划分网络号与主机号形式，那就是子网掩码，掩码的意思就是掩盖掉主机号，剩余的就是网络号。将子网掩码和 IP 地址按位计算 AND，就可得到网络号。</p>
<blockquote>
<p>两台计算机要通讯，首先要判断是否处于同一个广播域内，即网络地址是否相同。如果网络地址相同，表明接受方在本网络上，那么可以把数据包直接发送到目标主机。</p>
</blockquote>
<h3 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h3><p>子网掩码的另一个作用，子网划分实际上是将主机地址分为两个部分：子网网络地址和子网主机地址。</p>
<h3 id="公有-IP-地址与私有-IP-地址"><a href="#公有-IP-地址与私有-IP-地址" class="headerlink" title="公有 IP 地址与私有 IP 地址"></a>公有 IP 地址与私有 IP 地址</h3><p><img src="网络常见知识.assets\1599629584305.png" alt="1599629584305"></p>
<p>私有 IP 地址允许组织内部的 IT人员自己管理、自己分配，而且可以重复。</p>
<p>公有 IP 地址是由 ICANN 组织管理，中文叫「互联网名称与数字地址分配机构」。IANA 是 ICANN 的其中一个机构，它负责分配互联网 IP 地址，是按州的方式层层分配。在中国是由 CNNIC 的机构进行管理，它是中国国内唯一指定的全局 IP 地址管理的组织。<br><img src="网络常见知识.assets\1599629683644.png" alt="1599629683644"></p>
<h3 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h3><p>IP地址的网络地址这一部分是用于进行路由控制。</p>
<p><img src="网络常见知识.assets\1599629833778.png" alt="1599629833778"></p>
<h3 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h3><p>环回地址是在同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。</p>
<p>计算机使用一个特殊的 IP 地址 127.0.0.1 作为环回地址。与该地址具有相同意义的是一个叫做localhost 的主机名。使用这个 IP 或主机名时，数据包不会流向网络。</p>
<h3 id="IP-分片与重组"><a href="#IP-分片与重组" class="headerlink" title="IP 分片与重组"></a>IP 分片与重组</h3><p>每种数据链路的最大传输单元 MTU 都是不相同的，如 FDDI 数据链路 MTU 4352、以太网的 MTU 是1500 字节等。</p>
<p>那么当 IP 数据包大小大于 MTU 时， IP 数据包就会被分片。经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行，路由器是不会进行重组的。</p>
<h3 id="IPv6-基本认识"><a href="#IPv6-基本认识" class="headerlink" title="IPv6 基本认识"></a>IPv6 基本认识</h3><p>IPv6 地址长度是 128 位，是以每 16 位作为一组，每组用冒号 「:」 隔开。</p>
<p><img src="网络常见知识.assets\1599631076301.png" alt="1599631076301"></p>
<h3 id="IPv6-的优点"><a href="#IPv6-的优点" class="headerlink" title="IPv6 的优点"></a>IPv6 的优点</h3><blockquote>
<p>IPv6 可自动配置，即使没有 DHCP 服务器也可以实现自动分配IP地址，即插即用。</p>
<p>IPv6 包头包首部长度采用固定的值 40 字节，去掉了包头校验和，简化了首部结构，减轻了路由器负荷，大大提高了传输的性能。</p>
<p>IPv6 有应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能，大大提升了安全性。</p>
</blockquote>
<h3 id="IPv6-地址的类型"><a href="#IPv6-地址的类型" class="headerlink" title="IPv6 地址的类型"></a>IPv6 地址的类型</h3><ol>
<li><p>单播地址，用于一对一的通信</p>
<blockquote>
<ul>
<li>在同一链路单播通信，不经过路由器，可以使用链路本地单播地址，IPv4 没有此类型</li>
<li>在内网里单播通信，可以使用唯一本地地址，相当于 IPv4 的私有 IP</li>
<li>在互联网通信，可以使用全局单播地址，相当于 IPv4 的公有 IP</li>
</ul>
</blockquote>
</li>
<li><p>组播地址，用于一对多的通信</p>
</li>
<li><p>任播地址，用于通信最近的节点，最近的节点是由路由协议决定</p>
</li>
<li><p>没有广播地址</p>
</li>
</ol>
<p><img src="网络常见知识.assets\1599631155764.png" alt="1599631155764"></p>
<h3 id="IPv4-首部与-IPv6-首部"><a href="#IPv4-首部与-IPv6-首部" class="headerlink" title="IPv4 首部与 IPv6 首部"></a>IPv4 首部与 IPv6 首部</h3><p><img src="网络常见知识.assets\1599631291826.png" alt="1599631291826"></p>
<h3 id="IP（网络层）-和-MAC-（数据链路层）之间的区别和关系"><a href="#IP（网络层）-和-MAC-（数据链路层）之间的区别和关系" class="headerlink" title="IP（网络层） 和 MAC （数据链路层）之间的区别和关系"></a>IP（网络层） 和 MAC （数据链路层）之间的区别和关系</h3><p>IP 的作用是主机之间通信用的，而 MAC 的作用则是实现「直连」的两个设备之间通信，而 IP 则负责在「没有直连」的两个网络之间进行通信传输。</p>
<p><img src="网络常见知识.assets\1599626206478.png" alt="1599626206478"></p>
<p>在网络中数据包传输中，源IP地址和目标IP地址在传输过程中是不会变化的，只有 MAC 地址和目标 MAC 一直在变化。</p>
<h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>在DNS解析域名后，确定了源 IP 地址和目标 IP 地址后，就会通过主机「路由表」确定 IP 数据包下一跳。</p>
<p>由于主机的路由表中可以找到下一跳的 IP 地址，所以可以通过 ARP 协议，求得下一跳的 MAC 地址。</p>
<blockquote>
<ul>
<li>主机会通过广播发送 ARP 请求，这个包中包含了想要知道的 MAC 地址的主机 IP 地址。</li>
<li>当同个链路中的所有设备收到 ARP 请求时，会去拆开 ARP 请求包里的内容，如果 ARP 请求包中的目标 IP 地址与自己的 IP 地址一致，那么这个设备就将自己的 MAC 地址塞入 ARP 响应包返回给主机。</li>
</ul>
</blockquote>
<h3 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h3><p>已知 MAC 地址求 IP 地址。例如将打印机服务器等小型嵌入式设备接入到网络时就经常会用得到。</p>
<h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><p>通过 DHCP 动态获取 IP 地址，大大省去了配IP 信息繁琐的过程。</p>
<p>DHCP 客户端进程监听的是 68 端口号，DHCP 服务端进程监听的是 67 端口号。DHCP 交互中，全程使用 UDP 广播通信。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>网络地址转换 NAT 的方法，缓解了 IPv4 地址耗尽的问题。</p>
<p>简单的来说 NAT 就是同个公司、家庭、教室内的主机对外部通信时，把私有 IP 地址转换成公有 IP 地址。</p>
<p>可以把 IP 地址 + 端口号一起进行转换，这种转换技术就叫网络地址与端口转换 NAPT。</p>
<h3 id="ICMP（互联网控制报文协议）"><a href="#ICMP（互联网控制报文协议）" class="headerlink" title="ICMP（互联网控制报文协议）"></a>ICMP（互联网控制报文协议）</h3><p>ICMP 全称是 Internet Control Message Protocol，也就是互联网控制报文协议。主要的功能包括：确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置等。</p>
<p><img src="网络常见知识.assets\1599632892092.png" alt="1599632892092"></p>
<p>3：IP 路由器无法将 IP 数据包发送给目标地址时，会给发送端主机返回一个目标不可达的 ICMP 消息，并在这个消息中显示不可达的具体原因，<strong>原因记录在 ICMP 包头的代码字段。</strong></p>
<p><img src="网络常见知识.assets\1599642681552.png" alt="1599642681552"></p>
<p>4：原点抑制消息（ICMP Source Quench Message），当路由器向低速线路发送数据时，其发送队列的缓存变为零而无法发送出去时，可以向 IP 包的源地址发送一个 ICMP 原点抑制消息。</p>
<p>5：路由器发现发送端主机使用了「不是最优」的路径发送数据，那么它会返回一个 ICMP 重定向消息给这个主机。</p>
<p>11：IP 包中有一个字段叫做 TTL （ Time To Live ，生存周期），它的值随着每经过一次路由器就会减1，直到减到 0 时该 IP 包会被丢弃。设置 IP 包生存周期的主要目的，是为了在路由控制遇到问题发生循环状况时，避免 IP 包无休止地在网络上被转发。</p>
<h3 id="IGMP（因特网组管理协议）"><a href="#IGMP（因特网组管理协议）" class="headerlink" title="IGMP（因特网组管理协议）"></a>IGMP（因特网组管理协议）</h3><p>IGMP 是因特网组管理协议，工作在主机（组播成员）和最后一跳路由之间，</p>
<p>D 类地址，也就是组播地址，只有一组的主机能收到数据包，不在一组的主机不能收到数组包。</p>
<h2 id="Ping命令"><a href="#Ping命令" class="headerlink" title="Ping命令"></a>Ping命令</h2><p>ping 是基于 ICMP 协议工作的。</p>
<p>ICMP 报文是封装在 IP 包里面，它工作在网络层，是 IP 协议的助手。</p>
<p><img src="网络常见知识.assets\1599633694899.png" alt="1599633694899"></p>
<p><img src="网络常见知识.assets\1599633743475.png" alt="1599633743475"></p>
<p>可以向对端主机发送回送请求的消息（ ICMP Echo Request Message ，类型 8 ），也可以接收对端主机发回来的回送应答消息（ ICMP Echo Reply Message ，类型 0 ）。</p>
<h3 id="ping-的发送和接收过程"><a href="#ping-的发送和接收过程" class="headerlink" title="ping 的发送和接收过程"></a>ping 的发送和接收过程</h3><p>同个子网下的主机 A 和 主机 B，主机 A 执行 ping 主机 B 后，我们来看看其间发送了什么</p>
<ol>
<li><p>构建一个 ICMP 回送请求消息数据包。</p>
<p><img src="网络常见知识.assets\1599643761263.png" alt="1599643761263"></p>
</li>
<li><p>构建一个 IP 数据包</p>
<p><img src="网络常见知识.assets\1599643783667.png" alt="1599643783667"></p>
</li>
<li><p>加入 MAC头</p>
</li>
</ol>
<p><img src="网络常见知识.assets\1599643796582.png" alt="1599643796582"></p>
<ol>
<li><p>主机 B 收到这个数据帧后，先检查它的目的 MAC 地址，并和本机的 MAC 地址对比，如符合，则接收，否则就丢弃。接收后检查该数据帧，将 IP 数据包从帧中提取出来，交给本机的 IP 层。同样，IP 层检查后，将有用的信息提取后交给 ICMP 协议。主机 B 会构建一个 ICMP 回送响应消息数据包</p>
<p><img src="网络常见知识.assets\1599646372406.png" alt="1599646372406"></p>
</li>
</ol>
<h2 id="访问网址"><a href="#访问网址" class="headerlink" title="访问网址"></a>访问网址</h2><h3 id="URL解析"><a href="#URL解析" class="headerlink" title="URL解析"></a>URL解析</h3><p><img src="网络常见知识.assets\1599646805689.png" alt="1599646805689"></p>
<p>当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html</p>
<h3 id="生产-HTTP-请求信息"><a href="#生产-HTTP-请求信息" class="headerlink" title="生产 HTTP 请求信息"></a>生产 HTTP 请求信息</h3><p><img src="网络常见知识.assets\1599646862552.png" alt="1599646862552"></p>
<h3 id="查询真实IP地址"><a href="#查询真实IP地址" class="headerlink" title="查询真实IP地址"></a>查询真实IP地址</h3><p>查询服务器域名对应的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p>
<p>DNS 服务器专门保存了 Web 服务器域名与 IP 的对应关系。</p>
<h3 id="协议栈"><a href="#协议栈" class="headerlink" title="协议栈"></a>协议栈</h3><p>把 HTTP 的传输工作交给操作系统中的协议栈，协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p>
<p><img src="网络常见知识.assets\1599647032468.png" alt="1599647032468"></p>
<h3 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h3><h4 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h4><p>TCP 是面向连接（一对一，UDP可以一对多）的、可靠的、基于字节流的传输层通信协议。</p>
<p>TCP连接，包括Socket、序列号和窗口大小，用于保证可靠性和流量控制维护的某些状态信息。</p>
<ul>
<li>Socket：由 IP 地址和端口号组成</li>
<li>序列号：用来解决乱序问题等</li>
<li>窗口大小：用来做流量控制</li>
</ul>
<p><img src="网络常见知识.assets\1599650022884.png" alt="1599650022884"></p>
<p>TCP 四元组可以唯一的确定一个连接，端口在TCP头部中，地址在IP头部中。</p>
<h4 id="UDP和TCP"><a href="#UDP和TCP" class="headerlink" title="UDP和TCP"></a>UDP和TCP</h4><p>UDP 不提供复杂的控制机制，利用 IP 提供面向「无连接」的通信服务。<br>UDP 协议非常简单，头部只有 8 个字节（ 64 位），UDP 的头部格式如下：</p>
<p><img src="网络常见知识.assets\1599650138256.png" alt="1599650138256"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>连接</td>
<td>向连接的传输层协议，传输数据前先要建立连接。</td>
<td>不需要连接，即刻传输数据</td>
</tr>
<tr>
<td>服务对象</td>
<td>一对一的两点服务，即一条连接只有两个端点</td>
<td>支持一对一、一对多、多对多的交互通信</td>
</tr>
<tr>
<td>可靠性</td>
<td>是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达。</td>
<td>尽最大努力交付，不保证可靠交付数据。</td>
</tr>
<tr>
<td>拥塞控制、流量控制</td>
<td>有拥塞控制和流量控制机制，保证数据传输的安全性。</td>
<td>即使网络非常拥堵了，也不会影响 UDP 的发送速率。</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部长度较长，会有一定的开销，首部在没有使用「选项」字段时是 20 个字节，如果使</td>
<td>首部只有 8 个字节，并且是固定不变的，开销较小。</td>
</tr>
<tr>
<td>传输方式</td>
<td>流式传输，没有边界，但保证顺序和可靠。</td>
<td>是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</td>
</tr>
<tr>
<td>分片不同</td>
<td>数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输</td>
<td>数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层，但是如果中途丢了一个分片，则就需要重传所有的数据包，这样传输</td>
</tr>
<tr>
<td>应用场景</td>
<td>FTP 文件传输 HTTP / HTTPS</td>
<td>包总量较少的通信，如 DNS 、SNMP 等，视频、音频等多媒体通信</td>
</tr>
</tbody>
</table>
</div>
<p>IP 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。TCP 是一个工作在传输层的可靠数据传输的服务，它能确保接收端接收的网络包是无损坏、无间隔、非冗余和按序的。</p>
<h4 id="TCP-报文头部的格式"><a href="#TCP-报文头部的格式" class="headerlink" title="TCP 报文头部的格式:"></a>TCP 报文头部的格式:</h4><p><img src="网络常见知识.assets\1599647186623.png" alt="1599647186623"></p>
<ol>
<li><p>源端口号和目标端口号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p>
</li>
<li><p>序号，在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一<br>次数据，就「累加」一次该「数据字节数」的大小。解决包乱序的问题。</p>
</li>
<li><p>确认号，指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序<br>号以前的数据都已经被正常接收，为了解决不丢包的问题。</p>
</li>
<li><p>控制位。</p>
<blockquote>
<ol>
<li><p>SYN 该位为 1 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</p>
<blockquote>
<p>RFC1948 中提出了一个较好的初始化序列号 ISN 随机生成算法。<br>ISN = M + F (localhost, localport, remotehost, remoteport)<br>M 是一个计时器，这个计时器每隔 4 毫秒加 1。<br>F 是一个 Hash 算法，根据源 IP、目的 IP、源端口、目的端口生成一个随机数值。要保证Hash 算法不能被外部轻易推算得出，用 MD5 算法是一个比较好的选择。</p>
</blockquote>
</li>
<li><p>ACK 该位为 1 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 SYN包之外该位必须设置为 1 。</p>
</li>
<li><p>RST 该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接。</p>
</li>
<li><p>FIN 该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段。</p>
<p>TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p>
</li>
</ol>
</blockquote>
</li>
<li><p>窗口大小。TCP 要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，也别发的太慢。</p>
</li>
</ol>
<h4 id="三次握手连接"><a href="#三次握手连接" class="headerlink" title="三次握手连接"></a>三次握手连接</h4><p><img src="网络常见知识.assets\1599647353466.png" alt="1599647353466"></p>
<ol>
<li>客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN状态。</li>
<li>客户端主动发起连接 SYN ，之后处于 SYN-SENT 状态。</li>
<li>服务端收到发起的连接，返回 SYN ，并且 ACK 客户端的 SYN ，之后处于 SYN-RCVD 状态。</li>
<li>客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK ，之后处于ESTABLISHED 状态，因为它一发一收成功了。</li>
<li>服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。</li>
</ol>
<p>第三次握手是可以携带数据的，前两次握手是不可以携带数据的，</p>
<h4 id="三次握手的原因"><a href="#三次握手的原因" class="headerlink" title="三次握手的原因"></a>三次握手的原因</h4><ol>
<li><p>防止旧的重复连接初始化造成混乱。</p>
<blockquote>
<p>在网络拥堵情况下：<br>一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；<br>那么此时服务端就会回一个 SYN + ACK 报文给客户端；<br>客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户<br>端就会发送 RST 报文给服务端，表示中止这一次连接。</p>
</blockquote>
</li>
<li><p>同步双方初始序列号</p>
<blockquote>
<p>序列号是可靠传输的一个关键因素，它的作用：<br>接收方可以去除重复的数据；<br>接收方可以根据数据包的序列号按序接收；<br>可以标识发送出去的数据包中， 哪些是已经被对方收到的；</p>
</blockquote>
</li>
<li><p>避免资源浪费</p>
<blockquote>
<p>「两次握手」：如果客户端的 SYN 阻塞了，重复发送多次 SYN 报文，那么服务器在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。</p>
<p>无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
</blockquote>
</li>
</ol>
<h4 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h4><p><img src="网络常见知识.assets\1599657284840.png" alt="1599657284840"></p>
<p>等待服务端处理完数据后，也向客户端发送 FIN 报文，之后服务端进入 LAST_ACK 状态</p>
<p><strong>为什么会有四次</strong></p>
<p>服务端通常需要等待完成数据的发送和处理，所以服务端的 ACK 和 FIN 一般都会分开发送，从而比三次握手导致多了一次。</p>
<p><strong>TIME_WAIT 等待的时间是 2MSL</strong></p>
<p>MSL 是 Maximum Segment Lifetime，报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。因为 TCP 报文基于是 IP 协议的，而 IP 头中有一个 TTL 字段，是 IP 数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减 1，当此值为 0 则数据报将被丢弃，同时发送 ICMP 报文通知源主机。</p>
<p>MSL 与 TTL 的区别： MSL 的单位是时间，而 TTL 是经过路由跳数。所以 MSL 应该要大于等于 TTL消耗为 0 的时间，以确保报文已被自然消亡。</p>
<p>TIME_WAIT 等待 2 倍的 MSL，比较合理的解释是： 网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间。</p>
<p><strong>TIME-WAIT的原因</strong></p>
<ol>
<li><p>防止旧连接的数据包</p>
<blockquote>
<p>经过 2MSL 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。</p>
</blockquote>
</li>
<li><p>保证连接正确关闭</p>
<blockquote>
<p>TIME-WAIT 作用是等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</p>
</blockquote>
</li>
</ol>
<h4 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h4><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p>
<p>TCP 针对数据包丢失的情况，会用重传机制解决。</p>
<h5 id="超时重传"><a href="#超时重传" class="headerlink" title="超时重传"></a>超时重传</h5><p>在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 ACK 确认应答报文，就会重发该数据</p>
<p>TCP 会在以下两种情况发生超时重传：</p>
<ul>
<li>数据包丢失</li>
<li>确认应答丢失</li>
</ul>
<p><img src="网络常见知识.assets\1599658362894.png" alt="1599658362894"></p>
<p>RTT （Round-Trip Time 往返时延）：是数据从网络一端传送到另一端所需的时间，也就是包的往返时间。</p>
<p>超时重传时间是以 RTO （Retransmission Timeout 超时重传时间）表示，超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。</p>
<h5 id="快速重传"><a href="#快速重传" class="headerlink" title="快速重传"></a>快速重传</h5><p>快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。不以时间为驱动，而是以数据驱动重传。只解决了超时时间的问题，面临着另外一个问题。就是重传的时候，是重传之前的一个，还是重传所有的问题。</p>
<p><img src="网络常见知识.assets\1599701097569.png" alt="1599701097569"></p>
<h5 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h5><p>Selective Acknowledgment 选择性确认</p>
<p>在 TCP 头部「选项」字段里加一个 SACK 的东西，它可以将缓存的地图发送给发送方，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以只重传丢失的数据。</p>
<h5 id="Duplicate-SACK"><a href="#Duplicate-SACK" class="headerlink" title="Duplicate SACK"></a>Duplicate SACK</h5><p>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</p>
<h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><p>TCP 是每发送一个数据，都要进行一次确认应答。当上一个数据包收到了应答了， 再发送下一个。缺点：数据包的往返时间越长，通信的效率就越低。</p>
<p>窗口大小就是指无需等待确认应答，而可以继续发送数据的最大值。这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。</p>
<p><strong>发送方的滑动窗口</strong></p>
<p><img src="网络常见知识.assets\1599701589673.png" alt="1599701589673"></p>
<p>TCP 滑动窗口方案使用三个指针来跟踪在四个传输类别中的每一个类别中的字节。其中两个指针是绝对指针（指特定的序列号），一个是相对指针（需要做偏移）。</p>
<p><strong>接收方的滑动窗口</strong></p>
<p><img src="网络常见知识.assets\1599701705091.png" alt="1599701705091"></p>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。为了解决这种现象发生，TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</p>
<p><strong>窗口关闭，潜在死锁</strong></p>
<p><img src="网络常见知识.assets\1599702117779.png" alt="1599702117779"></p>
<p>TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。如果持续计时器超时，就会发送窗口探测 ( Window probe ) 报文，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。</p>
<p>窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 RST 报文来中断连接。</p>
<p><strong>糊涂窗口综合症</strong></p>
<p>如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症。TCP + IP 头有 40 个字节，为了传输那几个字节的数据，要达上这么大的开销，这太不经济了。</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<h4 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h4><p>避免「发送方」的数据填满整个网络。</p>
<p>拥塞控制主要是四个算法：</p>
<ul>
<li><p>慢启动：当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。（是指数性的增长）</p>
</li>
<li><p>拥塞避免：拥塞避免算法：每当收到一个 ACK 时，cwnd 增加 1/cwnd（线性增长）</p>
</li>
<li><p>拥塞发生：（会发生数据包重传）</p>
<blockquote>
<p>超时重传：ssthresh 设为 cwnd/2；cwnd 重置为 1，重新进入慢启动</p>
<p>快速重传：cwnd = cwnd/2 ，也就是设置为原来的一半;ssthresh = cwnd ;进入快速恢复算法</p>
</blockquote>
</li>
<li><p>快速恢复</p>
<blockquote>
<p>拥塞窗口 cwnd = ssthresh + 3 （ 3 的意思是确认有 3 个数据包被收到了）；<br>重传丢失的数据包；<br>如果再收到重复的 ACK，那么 cwnd 增加 1；<br>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新<br>的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的<br>状态了，也即再次进入拥塞避免状态；</p>
</blockquote>
</li>
</ul>
<h4 id="TCP半连接队和全连接队"><a href="#TCP半连接队和全连接队" class="headerlink" title="TCP半连接队和全连接队"></a>TCP半连接队和全连接队</h4><ul>
<li>半连接队列，也称 SYN 队列；</li>
<li>全连接队列，也称 accepet 队列；</li>
</ul>
<h4 id="TCP分割数据"><a href="#TCP分割数据" class="headerlink" title="TCP分割数据"></a>TCP分割数据</h4><p>MTU ：一个网络包的最大长度，以太网中一般为 1500 字节；<br>MSS ：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；</p>
<p><img src="网络常见知识.assets\1599647484820.png" alt="1599647484820"></p>
<p>如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。</p>
<p><strong>如果使用IP分片</strong></p>
<p>IP 层本身没有超时重传机制，它由传输层的 TCP 来负责超时和重传。如果一个 IP 分片丢失，整个 IP 报文的所有分片都得重传。</p>
<p>当接收方发现 TCP 报文（头部 + 数据）的某一片丢失后，则不会响应 ACK 给对方，那么发送方的TCP 在超时后，就会重发「整个 TCP 报文（头部 + 数据）」。</p>
<h4 id="TCP报文生成"><a href="#TCP报文生成" class="headerlink" title="TCP报文生成"></a>TCP报文生成</h4><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80 ， HTTPS 默认端口号是 443 ）。</p>
<p>网络包：</p>
<p><img src="网络常见知识.assets\1599647574610.png" alt="1599647574610"></p>
<h4 id="SYN-攻击"><a href="#SYN-攻击" class="headerlink" title="SYN 攻击"></a>SYN 攻击</h4><p>假设攻击者短时间伪造不同 IP 地址的 SYN 报文，服务端每接收到一个 SYN 报文，就进入SYN_RCVD 状态，但服务端发送出去的 ACK + SYN 报文，无法得到未知 IP 主机的 ACK 应答，久而久之就会占满服务端的 SYN 接收队列（未连接队列），使得服务器不能为正常用户服务。</p>
<p><strong>解决办法</strong></p>
<ol>
<li><p>通过修改 Linux 内核参数，控制队列大小和当队列满时应做什么处理。</p>
<blockquote>
<p>当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。</p>
<p>SYN_RCVD 状态连接的最大个数：</p>
<p>超出处理能时，对新的 SYN 直接回报 RST，丢弃连接：</p>
</blockquote>
</li>
</ol>
<h3 id="IP-报文头部"><a href="#IP-报文头部" class="headerlink" title="IP 报文头部"></a>IP 报文头部</h3><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。</p>
<p><img src="网络常见知识.assets\1599647663399.png" alt="1599647663399"></p>
<p>HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06 （十六进制），表示协议为TCP。</p>
<p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。</p>
<p>目标地址和子网掩码都是 0.0.0.0 ，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器， Gateway 即是路由器的 IP 地址。</p>
<h3 id="MAC头部"><a href="#MAC头部" class="headerlink" title="MAC头部"></a>MAC头部</h3><p>在 MAC 包头里需要发送方 MAC 地址和接收方目标 MAC 地址，用于两点之间的传输。<br>一般在 TCP/IP 通信里，MAC 包头的协议类型只使用：</p>
<ul>
<li>0800 ： IP 协议</li>
<li>0806 ： ARP 协议</li>
</ul>
<p>MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p>
<h3 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h3><p>IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，需要<strong>将数字信息转换为电信号</strong>，才能在网线上传输，负责执行这一操作的是<strong>网卡，要控制网卡还需要靠网卡驱动程序。</strong></p>
<p>网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上<strong>报头和起始帧分界符</strong>，在末尾加上<strong>用于检测错误的帧校验序列</strong>。</p>
<p><img src="网络常见知识.assets\1599648804365.png" alt="1599648804365"></p>
<p>网卡会将包转为电信号，通过网线发送出去</p>
<h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>交换机的设计是将网络包原样转发到目的地。交换机工作在MAC 层，也称为二层网络设备。</p>
<p>交换机的端口不具有 MAC 地址，直接接收所有的包并存放到缓冲区中，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录。根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。</p>
<p><img src="网络常见知识.assets\1599648944157.png" alt="1599648944157"></p>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。</p>
<ul>
<li>因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li>
<li>而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。</li>
</ul>
<p>完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。<br>MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。</p>
<p><strong>查询路由表判断转发目标</strong></p>
<p><img src="网络常见知识.assets\1599649188561.png" alt="1599649188561"></p>
<h3 id="服务器和客户端"><a href="#服务器和客户端" class="headerlink" title="服务器和客户端"></a>服务器和客户端</h3><p><img src="网络常见知识.assets\1599649299268.png" alt="1599649299268"></p>
<h3 id="路由器和交换机"><a href="#路由器和交换机" class="headerlink" title="路由器和交换机"></a>路由器和交换机</h3><p>现在家里的路由器其实有了交换机的功能了。交换机可以简单理解成一个设备，三台电脑网线接到这个设备，这三台电脑就可以互相通信了，交换机嘛，交换数据这么理解就可以。</p>
<h2 id="TCP三次握手，四次挥手"><a href="#TCP三次握手，四次挥手" class="headerlink" title="TCP三次握手，四次挥手"></a>TCP三次握手，四次挥手</h2>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%80%BB%E7%BB%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%A7%E6%80%BB%E7%BB%93/" class="post-title-link" itemprop="url">数据库知识点大总结</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-07 21:25:42" itemprop="dateCreated datePublished" datetime="2020-09-07T21:25:42+08:00">2020-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-08 12:16:31" itemprop="dateModified" datetime="2020-09-08T12:16:31+08:00">2020-09-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>title: 数据库知识点大总结<br>date: 2020-09-07 21:25:42<br>tags: [SQL, MySQL, 数据库]<br>categories: MySQL</p>
<p>转载来源：<a href="https://blog.csdn.net/wugenqiang/article/details/106501338" target="_blank" rel="noopener">数据库面试题</a></p>
<h2 id="数据库基本知识"><a href="#数据库基本知识" class="headerlink" title="数据库基本知识"></a>数据库基本知识</h2><h3 id="范式的定义"><a href="#范式的定义" class="headerlink" title="范式的定义"></a>范式的定义</h3><p>改造关系模式，通过分解关系模型来消除其中不合适的数据依赖，以决绝插入异常，删除异常，数据用余。</p>
<h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><p>第一范式（1NF）：关系模式 R 中每个列都不可以再拆分。</p>
<p>第二范式（2NF）：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。</p>
<h3 id="mysql有关权限的表"><a href="#mysql有关权限的表" class="headerlink" title="mysql有关权限的表"></a>mysql有关权限的表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h3 id="MySQL的binlog的3种录入格式"><a href="#MySQL的binlog的3种录入格式" class="headerlink" title="MySQL的binlog的3种录入格式"></a>MySQL的binlog的3种录入格式</h3><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h3 id="⭐什么是数据字典"><a href="#⭐什么是数据字典" class="headerlink" title="⭐什么是数据字典"></a>⭐什么是数据字典</h3><p>数据字典是关系数据库管理系统内部的一组系统表，它<strong>记录了数据库中所有的定义信息</strong>，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。<strong>关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典中的相应信息</strong></p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系型数据库和非关系型数据库比较"><a href="#关系型数据库和非关系型数据库比较" class="headerlink" title="关系型数据库和非关系型数据库比较"></a>关系型数据库和非关系型数据库比较</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库:"></a>关系型数据库:</h4><ul>
<li>采用了关系模型来组织数据的数据库，以行和列形式存储数据，以便于用户理解。</li>
<li>通用的 SQL 语言使得操作关系型数据库非常方便。</li>
<li>关系型数据库遵循 ACID 原则。</li>
<li>常见的关系型数据库比如 MySQL，Oracle</li>
</ul>
<p><strong>关系型数据库存在的问题</strong>：</p>
<ul>
<li>网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘 I/O 是一个很大的瓶颈</li>
<li>网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。因此，关系型数据不适合持久存储海量数据</li>
<li>很难进行横向扩展（增加服务器），也就是说想要提高数据处理能力，要使用性能更好的计算机（纵向扩展）</li>
<li>性能欠佳：导致关系型数据库性能欠佳的最主要原因就是多表的关联查询，为了保证数据库的ACID特性，必须尽量按照范式要求设计数据库，关系数据库中的表存储的往往是一个固定的、格式化的数据结构</li>
</ul>
<p>而非关系型数据库就可以很好的解决关系型数据库很难解决的大数据问题</p>
<h4 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h4><ul>
<li>非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</li>
<li>支持分布式存储，容易进行横向扩展</li>
<li>不遵循 ACID 特性（不提供对事务的处理）</li>
<li>常见的非关系型数据库比如 Redis、MongoDB、Elasticsearch</li>
</ul>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h4><p>数据库连接池是负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接</strong>，而不是每次访问数据库的时候都需要重新建立一次连接。</p>
<h4 id="②-为什么要使用连接池"><a href="#②-为什么要使用连接池" class="headerlink" title="② 为什么要使用连接池"></a>② 为什么要使用连接池</h4><p><strong> 数据库连接是一种关键的有限的昂贵的资源</strong> ，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p>
<p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p>
<p>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
<h4 id="③-传统的连接机制与连接池运行机制区别"><a href="#③-传统的连接机制与连接池运行机制区别" class="headerlink" title="③ 传统的连接机制与连接池运行机制区别"></a>③ 传统的连接机制与连接池运行机制区别</h4><p>执行一个 SQL 命令</p>
<p><strong>不使用数据库连接池的步骤</strong>：</p>
<ul>
<li>TCP建立连接三次握手</li>
<li>MySQL认证三次握手</li>
<li>真正的SQL执行</li>
<li>MySQL关闭</li>
<li>TCP四次挥手关闭</li>
</ul>
<p>可以看到，为了执行一条SQL，却多了非常多网络交互，应用需要频繁的创建连接和关闭连接。</p>
<p><strong>使用数据库连接池的步骤</strong>：</p>
<p>第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。</p>
<h3 id="超键、候选键、主键、外键分别是什么"><a href="#超键、候选键、主键、外键分别是什么" class="headerlink" title="超键、候选键、主键、外键分别是什么"></a>超键、候选键、主键、外键分别是什么</h3><ul>
<li><strong>⭐超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li><strong>⭐候选键</strong>：即最小超键，即没有冗余元素的超键。候选键中的元素称为<strong>主属性</strong></li>
<li><strong>主键</strong>：候选键中选出一个作为主键，一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h4 id="主键和外键的区别"><a href="#主键和外键的区别" class="headerlink" title="主键和外键的区别"></a>主键和外键的区别</h4><p>主键在本表中是唯一的、不可为空的，外键可以重复可以为空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。</p>
<h3 id="主码和外码"><a href="#主码和外码" class="headerlink" title="主码和外码"></a>主码和外码</h3><p>若关系中某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>，若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。</p>
<p>如果F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的<strong>外码</strong>。</p>
<blockquote>
<p>类似外键：F不是R的主键，但是是另一个关系S的主键，则F是R的外键</p>
</blockquote>
<h3 id="⭐完整性约束"><a href="#⭐完整性约束" class="headerlink" title="⭐完整性约束"></a>⭐完整性约束</h3><p>数据库的完整性是指<strong>数据的正确性和相容性</strong>。</p>
<ul>
<li>数据的正确性是指数据是符合现实世界语义、反映当前实际状况的。</li>
<li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。</li>
</ul>
<p>l <strong>实体完整性</strong>：若属性A是基本关系B的主属性，则A不能取空值（所谓空值是指不知道，不存在，无意义的值）</p>
<p>l <strong>参照完整性</strong>：若属性F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须：</p>
<p>² 或者取空值（F的每个属性值均为空值）</p>
<p>² 或者等于S中某个元组的主码值</p>
<p>（某个同学班长属性可以是尚为选出班长，也可以是本关系中某个元组的学号值）</p>
<p>l <strong>用户定义完整性</strong>：针对某一具体关系数据库的约束条件，反映某一具体应用涉及的数据必须满足的语义要求（如某个属性必须取唯一值，某个非主属性不能取空值）</p>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL-的四个组成部分-⭐"><a href="#SQL-的四个组成部分-⭐" class="headerlink" title="SQL 的四个组成部分 ⭐"></a>SQL 的四个组成部分 ⭐</h3><ol>
<li>数据库模式定义语言DDL：create用来创建数据库中的各种对象——表、视图、索引、同义词、聚簇等</li>
<li>数据查询语言dql：基本结构是由SELECT子句，FROM子句和WHERE子句组成的查询块</li>
<li>数据操纵语言dml：插入INSERT、更新UPDATE和删除DELETE</li>
<li>数据控制语言dcl：用来授予或回收访问数据库的某种特权，并控制数据库操纵事物发生的时间和效果，对数据库实行监视等</li>
</ol>
<h3 id="SQL-约束"><a href="#SQL-约束" class="headerlink" title="SQL 约束"></a>SQL 约束</h3><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul>
<li><p>交叉连接（CROSS JOIN）</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>内连接（INNER JOIN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A,B WHERE A.id&#x3D;B.id </span><br><span class="line">SELECT * FROM A INNER JOIN B ON A.id&#x3D;B.id #多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>等值连接：ON A.id=B.id</p>
<p>不等值连接：ON A.id &gt; B.id</p>
<p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</p>
</blockquote>
</li>
<li><p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<blockquote>
<p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN<br>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p>
</blockquote>
</li>
<li><p>联合查询（UNION与UNION ALL）</p>
<blockquote>
<p>把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并<br>如果使用UNION ALL，不会合并重复的记录行<br>效率 UNION 高于 UNION ALL</p>
</blockquote>
</li>
<li><p>全连接（FULL JOIN）</p>
<blockquote>
<p>MySQL不支持全连接<br>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</p>
</blockquote>
</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote>
<ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
</blockquote>
<h3 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a>子查询的三种情况</h3><ul>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资最高的员工是谁？ </span><br><span class="line">select  * from employee where salary&#x3D;(select max(salary) from employee);</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from Stduent where id in (select id from SC);</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1) 查询出2011年以后入职的员工信息</span><br><span class="line">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span><br><span class="line">select * from dept d,  (select * from employee where join_date &gt; &#39;2011-1-1&#39;) e where e.dept_id &#x3D;  d.id;    </span><br><span class="line"></span><br><span class="line">-- 使用表连接：</span><br><span class="line">select d.*, e.* from  dept d inner join employee e on d.id &#x3D; e.dept_id where e.join_date &gt;  &#39;2011-1-1&#39;</span><br></pre></td></tr></table></figure>
<h3 id="in-和-exists-的区别"><a href="#in-和-exists-的区别" class="headerlink" title="in 和 exists 的区别"></a>in 和 exists 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from Student where id exists (select id from SC);</span><br><span class="line">select id from Stduent where id in (select id from SC);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>in 先进行子查询 select id from SC，再进行外查询 select id from Student</p>
<p>exists 先执行外查询，再执行子查询</p>
</li>
<li><p>in 语句是把外表和内表作连接</p>
<p>而 exists 语句是对外表作循环，每次循环再对内表进行查询</p>
</li>
<li><p>exists 适合子查询的表比外查询大的查询语句</p>
<p>如果内表和外表差不多大，那么 in 和 exists 的效率差别不大</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAwMzcucG5n?x-oss-process=image/format,png" alt="image-20200429100036635"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAxMDAucG5n?x-oss-process=image/format,png" alt="image-20200429100059106"></p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p>
<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p>
<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。仍占4字节存储，存储范围不变，不影响内部存储。</p>
<h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>FLOAT（存储至多8位十进制数，4字节）、DOUBLE（存储至多18位十进制数，8字节）、DECIMAL。</p>
<p>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>year, date, time, datetime, timestep</p>
<p>尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>VARCHAR、CHAR、TEXT、BLOB</p>
<p>CHAR是定长的，根据定义的字符串长度分配足够的空间，会根据需要使用空格进行填充方便比较，适合存储很短的字符串，或者所有值都接近同一个长度。存储的内容超出设置的长度时，内容会被截断。</p>
<p>VARCHAR用于存储可变长字符串，列长度小于255字节时，使用1字节表示，否则使用2字节表示，存储的内容超出设置的长度时，内容会被截断，比定长类型更节省空间。使用额外1或2个字节存储字符串长度。</p>
<p>varchar(50)中50的表示最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
<h4 id="枚举类型（ENUM）"><a href="#枚举类型（ENUM）" class="headerlink" title="枚举类型（ENUM）"></a>枚举类型（ENUM）</h4><p>把不重复的数据存储为一个预定义的集合。</p>
<p>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>
<h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>1、delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。</p>
<p>2、delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
<p>3、delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。</p>
<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>1、truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
<p>3、对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</p>
<p>4、truncatetable不能用于参与了索引视图的表。</p>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>1、drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
<p>3、drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、在速度上，一般来说，drop&gt; truncate &gt; delete。</p>
<p>2、在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。</p>
<p>3、如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；</p>
<p>   如果想删除表，当然用drop； </p>
<p>   如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
<p>   如果和事务有关，或者想触发trigger，还是用delete；</p>
<p>   如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。</p>
<h3 id="SQL-的生命周期"><a href="#SQL-的生命周期" class="headerlink" title="SQL 的生命周期"></a>SQL 的生命周期</h3><ol>
<li>应用服务器与数据库服务器建立一个连接</li>
<li>数据库进程拿到请求sql</li>
<li>解析并生成执行计划，执行</li>
<li>读取数据到内存并进行逻辑处理</li>
<li>通过步骤一的连接，发送结果到客户端</li>
<li>关掉连接，释放资源</li>
</ol>
<h3 id="在数据库中查询语句速度很慢，应如何优化"><a href="#在数据库中查询语句速度很慢，应如何优化" class="headerlink" title="在数据库中查询语句速度很慢，应如何优化"></a>在数据库中查询语句速度很慢，应如何优化</h3><ol>
<li>建索引</li>
<li>减少表之间的关联</li>
<li>优化 SQL，尽量让 SQL 很快定位数据，不要让 SQL 做全表查询，应该走索引，把数据量大的表排在前面</li>
<li>简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>
<li>尽量用 Prepared Statement 来查询，不要用 Statement</li>
</ol>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li><p>数据库层面：核心减少load的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面第一条语句需要load1000000数据，只取10条，基本上全部丢弃,所以很慢</span><br><span class="line">select * from table where age &gt; 20 limit 1000000,10</span><br><span class="line">select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</span><br><span class="line"></span><br><span class="line">select * from table where id &gt; 1000000 limit 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>从需求的角度减少这种请求：不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</p>
</li>
</ul>
<h3 id="Union-和-Union-All-有什么不同"><a href="#Union-和-Union-All-有什么不同" class="headerlink" title="Union 和 Union All 有什么不同"></a>Union 和 Union All 有什么不同</h3><p>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表 UNION。 </p>
<p>UNION ALL 只是简单的将两个结果合并后就返回。 </p>
<p>从效率上说，UNION ALL 要比 UNION 快很多，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用 UNION ALL。</p>
<h3 id="order-by-和-group-by-的区别"><a href="#order-by-和-group-by-的区别" class="headerlink" title="order by 和 group by 的区别"></a>order by 和 group by 的区别</h3><p>order by 排序查询、asc 升序、desc 降序 </p>
<p>group by 分组查询、having 只能用于 group by 子句，作用于组内，having 条件子句可以直接跟函数表达式。使用 group by 子句的查询语句需要使用聚合函数。</p>
<h3 id="什么是-PL-SQL"><a href="#什么是-PL-SQL" class="headerlink" title="什么是 PL / SQL"></a>什么是 PL / SQL</h3><p>PL / SQL 是一种程序语言，叫做过程化 SQL 语言（Procedural Language/SQL）。PL / SQL 是 Oracle 数据库对 SQL 语句的扩展。在普通 SQL 语句的使用上增加了编程语言的特点，所以 PL / SQL 把数据操作和查询语句组织在 PL / SQL 代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。</p>
<p>PL / SQL 只有 Oracle 数据库有。 MySQL 目前不支持 PL / SQL 的。</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>存储引擎Storage engine：数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ol>
<li>Innodb引擎：提供了对数据库ACID事务的支持，还提供了行级锁和外键的约束。它的设计目标就是处理大数据容量的数据库系统。</li>
<li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ol>
<h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2MjkucG5n?x-oss-process=image/format,png" alt="image-20200429100628653"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2NTgucG5n?x-oss-process=image/format,png" alt="image-20200429100657751"></p>
<blockquote>
<p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。<br>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。<br>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。<br>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p>
</blockquote>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><blockquote>
<ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
</blockquote>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><blockquote>
<p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul>
<li>索引是一种特殊的文件（InnoDB 数据表上的索引是表空间的一个组成部分），包含对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B + 树。</li>
<li>索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，需要占据物理空间。</li>
</ul>
<h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><p>索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。如果没有索引，一般来说执行查询时遍历整张表。</p>
<h3 id="添加索引目的"><a href="#添加索引目的" class="headerlink" title="添加索引目的"></a>添加索引目的</h3><p>提高数据查询的效率</p>
<h3 id="聚集索引和非聚集索引-⭐"><a href="#聚集索引和非聚集索引-⭐" class="headerlink" title="聚集索引和非聚集索引 ⭐"></a>聚集索引和非聚集索引 ⭐</h3><p>物理存储顺序与逻辑顺序相同，即聚集索引（InnoDB）</p>
<p>物理存储顺序与索引顺序不一致，即非聚集索引（MyISAM）</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点</p>
<ul>
<li>加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="什么样的字段适合建索引"><a href="#什么样的字段适合建索引" class="headerlink" title="什么样的字段适合建索引"></a>什么样的字段适合建索引</h3><p>唯一、不为空、经常被查询的字段</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>
<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</li>
</ul>
<p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
</ul>
<p>全文索引： 是目前搜索引擎使用的一种关键技术。（InnoDB不支持，MyISAM支持）</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><p>索引的原理就是把无序的数据变成有序的查询，把创建了索引的列的内容进行排序，对排序结果生成倒排表，在倒排表内容上拼上数据地址链。在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据。</p>
<h3 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h3><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>Mysql数据库中最常用的索引算法，基本所有存储引擎都支持BTree索引。（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）。不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &#39;jack%&#39;; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &#39;%jack&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>B+ tree性质：</strong></p>
<ol>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+ 树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ol>
<h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>B tree</th>
<th>B+ tree</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>内部节点和叶子节点存放键和值</strong>    把频繁访问的数据放在靠近根节点的地方可以提高热点数据的查询效率。</td>
<td><strong>内部节点都是键，没有值，叶子节点同时存放键和值 </strong>    因此一次读取可以在内存页中获取更多的键，有利于更快地缩小查找范围,空间利用率更高，可减少I/O次数，磁盘读写代价更低（因为索引本身很大，不可能全部存储在内存中，往往以索引文件的形式存储的磁盘上）</td>
</tr>
<tr>
<td></td>
<td><strong>叶子节点各自独立</strong>  遍历时需要对树的每一层进行遍历，需要更多的内存置换次数，花费更多的时间</td>
<td><strong>叶子节点有一条链相连</strong>    当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</td>
</tr>
<tr>
<td></td>
<td>只适合随机检索</td>
<td>同时支持随机检索和顺序检索</td>
</tr>
<tr>
<td></td>
<td>B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>查询效率更加稳定</strong>    顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>类似于数据结构中简单实现的HASH表（散列表）一样，在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于B Tree索引。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>item</th>
<th>Hash</th>
<th>B+ tree</th>
</tr>
</thead>
<tbody>
<tr>
<td>底层实现原理</td>
<td>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</td>
<td>B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</td>
</tr>
<tr>
<td></td>
<td>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。不支持使用索引进行排序， 不支持模糊查询以及多列索引的最左前缀匹配（因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。</td>
<td>B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低</td>
</tr>
</tbody>
</table>
</div>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>可以利用<code>select count(*)/count(distinct left(password,prefixLen))</code>;，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p>
<h3 id="最左前缀原则-amp-最左匹配原则"><a href="#最左前缀原则-amp-最左匹配原则" class="headerlink" title="最左前缀原则&amp;最左匹配原则"></a>最左前缀原则&amp;最左匹配原则</h3><p>最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p>
<p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ol>
<li>最左前缀匹配原则：组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)停止匹配</li>
<li>较频繁作为查询条件的字段才去创建索引, 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>更新频繁字段不适合创建索引</li>
<li>不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ol>
<h3 id="创建，删除索引"><a href="#创建，删除索引" class="headerlink" title="创建，删除索引"></a>创建，删除索引</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><ul>
<li>非空字段：应该指定列为NOT NULL，除非想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h5 id="在执行CREATE-TABLE时创建索引"><a href="#在执行CREATE-TABLE时创建索引" class="headerlink" title="在执行CREATE TABLE时创建索引"></a>在执行CREATE TABLE时创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">	id INT auto_increment PRIMARY KEY,</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="使用ALTER-TABLE命令去增加索引"><a href="#使用ALTER-TABLE命令去增加索引" class="headerlink" title="使用ALTER TABLE命令去增加索引"></a>使用ALTER TABLE命令去增加索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<h5 id="使用CREATE-INDEX命令创建"><a href="#使用CREATE-INDEX命令创建" class="headerlink" title="使用CREATE INDEX命令创建"></a>使用CREATE INDEX命令创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure>
<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure>
<p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引），需要取消自增长再行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id int,</span><br><span class="line">drop PRIMARY KEY</span><br></pre></td></tr></table></figure>
<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h4><p>通常，通过索引查询数据比全表扫描要快。但是它也有代价。</p>
<p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，不必要的索引反而会使查询反应时间变慢。</p>
<p>使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h4 id="如何删除百万级别或以上的数据"><a href="#如何删除百万级别或以上的数据" class="headerlink" title="如何删除百万级别或以上的数据"></a>如何删除百万级别或以上的数据</h4><p>对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。</p>
<p>要删除百万数据时</p>
<ol>
<li>先删除索引（此时大概耗时三分多钟）</li>
<li>删除其中无用数据（此过程需要不到两分钟）</li>
<li>重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
</ol>
<h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</p>
<p>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</p>
<h4 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h4><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<h4 id="为什么需要注意联合索引中的顺序？"><a href="#为什么需要注意联合索引中的顺序？" class="headerlink" title="为什么需要注意联合索引中的顺序？"></a>为什么需要注意联合索引中的顺序？</h4><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>
<p>事务是指一个单元的工作，要么全做，要么全不做，事务是逻辑上的一组操作，保证一组数据的修改要么全部执行，要么全部不执行。</p>
<blockquote>
<p>举例：事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
</blockquote>
<h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<ul>
<li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="脏读，幻读，不可重复读"><a href="#脏读，幻读，不可重复读" class="headerlink" title="脏读，幻读，不可重复读"></a>脏读，幻读，不可重复读</h3><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p>
<ol>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>在所有的 DBMS 中，<strong>锁是实现事务的关键，锁可以保证事务的完整性和并发性</strong>。与现实生活中锁一样，它可以是某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。</p>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ol>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ol>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="按照锁的粒度划分"><a href="#按照锁的粒度划分" class="headerlink" title="按照锁的粒度划分"></a>按照锁的粒度划分</h4><p>在关系型数据库中，按照锁的粒度把数据库锁分为<strong>行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</strong></p>
<p>MyISAM采用表级锁(table-level locking)<br>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行级锁</th>
<th>表级锁</th>
<th>页级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁</td>
<td>MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。</td>
<td>MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</td>
</tr>
<tr>
<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</td>
<td>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</td>
<td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</td>
</tr>
</tbody>
</table>
</div>
<h4 id="按照锁的类别划分"><a href="#按照锁的类别划分" class="headerlink" title="按照锁的类别划分"></a>按照锁的类别划分</h4><p><strong>共享锁</strong>: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p><strong>排他锁</strong>: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
<li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li>
</ol>
<h3 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<strong>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</strong></p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<blockquote>
<p>多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
</blockquote>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。</p>
<blockquote>
<p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
</blockquote>
<h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><h4 id="MySQL中InnoDB引擎的行锁"><a href="#MySQL中InnoDB引擎的行锁" class="headerlink" title="MySQL中InnoDB引擎的行锁"></a>MySQL中InnoDB引擎的行锁</h4><p>InnoDB是基于索引来完成行锁</p>
<p>例: <code>select * from tab_with_index where id = 1 for update;</code></p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h4 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h4><ul>
<li><p>Record lock：单个行记录上的锁</p>
<blockquote>
<p>当查询的索引含有唯一属性时，将next-key lock降级为record key</p>
</blockquote>
</li>
<li><p>Gap lock：间隙锁，锁定一个范围，不包括记录本身</p>
<blockquote>
<p>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，这会导致幻读问题<br>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）</p>
<p> A. 将事务隔离级别设置为RC </p>
<p>B. 将参数innodb_locks_unsafe_for_binlog设置为1</p>
</blockquote>
</li>
<li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p>
<blockquote>
<p>Next-locking keying为了解决Phantom Problem幻读问题</p>
<p>innodb对于行的查询使用next-key lock</p>
</blockquote>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p>视图本质上是一种虚拟表，在物理上是不存在的，具有和物理表相同的功能，其内容与真实的表相似，包含一系列带有名称的列和行数据，可以对视图进行增，改，查，操作，但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<h3 id="为什么要使用视图"><a href="#为什么要使用视图" class="headerlink" title="为什么要使用视图"></a>为什么要使用视图</h3><p>为了提高复杂 SQL 语句的复用性和表操作的安全性，数据库管理系统提供了视图特性。视图使得开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h3 id="视图有哪些特点"><a href="#视图有哪些特点" class="headerlink" title="视图有哪些特点"></a>视图有哪些特点</h3><ol>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
<li>视图的操作包括创建视图，查看视图，删除视图和修改视图。</li>
</ol>
<h3 id="视图的优缺点"><a href="#视图的优缺点" class="headerlink" title="视图的优缺点"></a>视图的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>查询简单化：视图能简化用户的操作</li>
<li>数据安全性：视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性：视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>性能：数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制：当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</li>
</ol>
<h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><h4 id="视图的使用场景有哪些"><a href="#视图的使用场景有哪些" class="headerlink" title="视图的使用场景有哪些"></a>视图的使用场景有哪些</h4><p>视图根本用途：简化 SQL 查询，提高开发效率。兼容老的表结构。</p>
<p>常见使用场景：</p>
<ol>
<li>重用 SQL 语句；</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<h4 id="表和视图的关系"><a href="#表和视图的关系" class="headerlink" title="表和视图的关系"></a>表和视图的关系</h4><p>视图其实就是一条查询 SQL 语句，用于显示一个或多个表或其他视图中的相关数据。 </p>
<p>表是关系数据库中实际存储数据用的。</p>
<h4 id="什么是游标"><a href="#什么是游标" class="headerlink" title="什么是游标"></a>什么是游标</h4><p>游标是系统为用户开设的一个数据缓冲区，存放 SQL 语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。</p>
<h3 id="存储过程用什么来调用"><a href="#存储过程用什么来调用" class="headerlink" title="存储过程用什么来调用"></a>存储过程用什么来调用</h3><ul>
<li>可以用一个命令对象来调用存储过程。</li>
<li>可以供外部程序调用，比如：Java 程序。</li>
</ul>
<h3 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便。</li>
<li>移植性差，数据库端代码当然是与数据库相关的。但如果是工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，如果用户很难维护该系统</li>
</ol>
<h3 id="存储过程与函数的区别"><a href="#存储过程与函数的区别" class="headerlink" title="存储过程与函数的区别"></a>存储过程与函数的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>存储过程</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于在数据库中完成特定的操作或者任务（如插入、删除等）</td>
<td>用于特定的数据（如选择）</td>
</tr>
<tr>
<td>程序头部声明用 procedure</td>
<td>程序头部声明用 function</td>
</tr>
<tr>
<td>程序头部声明时不需描述返回类型</td>
<td>程序头部声明时要描述返回类型，而且 PL / SQL 块中至少要包括一个有效的 return 语句</td>
</tr>
<tr>
<td>可以使用 in / out / in out 三种模式的参数</td>
<td>可以使用 in / out /in out 三种模式的参数</td>
</tr>
<tr>
<td>可作为一个独立的 PL / SQL 语句来执行</td>
<td>不能独立执行，必须作为表达式的一部分调用</td>
</tr>
<tr>
<td>可以通过 out / in out 返回零个或多个值</td>
<td>通过 return 语句返回一个值，且改值要与声明部分一致，也可以是通过 out 类型的参数带出的变量</td>
</tr>
<tr>
<td>SQL 语句( DML 或 SELECT )中不可调用存储过程</td>
<td>SQL 语句( DML 或 SELECT )中可以调用函数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h3><p>触发器是<strong>用户定义在关系表上的一类由事件驱动的特殊的存储过程</strong>，触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>主要是通过事件来触发而被执行的。可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<h3 id="触发器的使用场景"><a href="#触发器的使用场景" class="headerlink" title="触发器的使用场景"></a>触发器的使用场景</h3><p>可以通过数据库中的相关表实现级联更改。<br>实时监控某张表中的某个字段的更改而需要做出相应的处理。例如可以生成某些业务的编号。</p>
<h3 id="MySQL中的触发器"><a href="#MySQL中的触发器" class="headerlink" title="MySQL中的触发器"></a>MySQL中的触发器</h3><p>在 MySQL 数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h3 id="事前触发和事后触发的区别"><a href="#事前触发和事后触发的区别" class="headerlink" title="事前触发和事后触发的区别"></a>事前触发和事后触发的区别</h3><p>事前触发器运行于触发事件发生之前，事后触发器运行于触发事件发生之后。</p>
<p>通常事前触发器可以获取事件之前和新的字段值。</p>
<h3 id="语句级触发和行级触发有何区别"><a href="#语句级触发和行级触发有何区别" class="headerlink" title="语句级触发和行级触发有何区别"></a>语句级触发和行级触发有何区别</h3><p>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/SQL%E5%92%8CMySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/07/SQL%E5%92%8CMySQL/" class="post-title-link" itemprop="url">SQL和MySQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-07 19:02:12 / Modified: 21:25:54" itemprop="dateCreated datePublished" datetime="2020-09-07T19:02:12+08:00">2020-09-07</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="结构化查询语言（SQL）"><a href="#结构化查询语言（SQL）" class="headerlink" title="结构化查询语言（SQL）"></a>结构化查询语言（SQL）</h1><p>结构化查询语言（Structured Query Language）简称 SQL，是一种数据库查询语言。用于存取数据、查询、更新和管理关系数据库系统。</p>
<h2 id="SQL-是一种声明性语言"><a href="#SQL-是一种声明性语言" class="headerlink" title="SQL 是一种声明性语言"></a>SQL 是一种声明性语言</h2><p>简单地说，SQL 语言声明的是结果集的属性，计算机会根据 SQL 所声明的内容来从数据库中挑选出符合声明的数据，而不是像传统编程思维去指示计算机如何操作。</p>
<h2 id="SQL-的语法并不按照语法顺序执行"><a href="#SQL-的语法并不按照语法顺序执行" class="headerlink" title="SQL 的语法并不按照语法顺序执行"></a>SQL 的语法并不按照语法顺序执行</h2><p>SQL 语句的语法顺序是：</p>
<ul>
<li>SELECT[DISTINCT]</li>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<p>执行顺序为：</p>
<ul>
<li>FROM</li>
<li>WHERE</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>SELECT</li>
<li>DISTINCT</li>
<li>UNION</li>
<li>ORDER BY</li>
</ul>
<ol>
<li>FROM 是 SQL 语句执行的第一步，而非 SELECT 。数据库在执行 SQL 语句的第一步是将数据从硬盘加载到数据缓冲区中，以便对这些数据进行操作。</li>
<li>SELECT 是在大部分语句执行了之后才执行的，严格说是在 FROM 和 GROUP BY 之后执行的。所以不能在 WHERE 中使用在 SELECT 中设定别名字段作为判断条件。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.x + A.y AS z FROM A</span><br><span class="line">WHERE z &#x3D; 10 -- z 在此处不可用，因为SELECT是最后执行的语句！</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT A.x + A.y AS z FROM A </span><br><span class="line">WHERE (A.x + A.y) &#x3D; 10 -- 正确用法</span><br></pre></td></tr></table></figure>
<ol>
<li>无论在语法上还是在执行顺序上， UNION 总是排在在 ORDER BY 之前。尽管某些数据库允许 SQL 语句对子查询（subqueries）或者派生表（derived tables）进行排序，但是这并不说明这个排序在 UNION 操作过后仍保持排序后的顺序。</li>
</ol>
<blockquote>
<p>并非所有的数据库对 SQL 语句使用相同的解析方式。如 MySQL、PostgreSQL和 SQLite 中就不会按照上面第二点中所说的方式执行。</p>
</blockquote>
<h2 id="SQL-语言的核心是对表的引用（table-references）"><a href="#SQL-语言的核心是对表的引用（table-references）" class="headerlink" title="SQL 语言的核心是对表的引用（table references）"></a>SQL 语言的核心是对表的引用（table references）</h2><p>根据 SQL 标准，FROM 语句被定义为：</p>
<p><code>&lt;from clause&gt; ::= FROM &lt;table reference&gt; [ { &lt;comma&gt; &lt;table reference&gt; }... ]</code></p>
<p>FROM 语句的“输出”是一张联合表，来自于所有引用的表在某一维度上的联合。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM a, b</span><br></pre></td></tr></table></figure>
<p>上面这句 FROM 语句的输出了一张联合表，联合了表 a 和表 b 。如果 a 表有三个字段， b 表有 5 个字段，那么这个“输出表”就有 8 （ =5+3）个字段。联合表里的数据是 a*b，<strong>即 a 和 b 的笛卡尔积</strong>。 a 表中的每一条数据都要跟 b 表中的每一条数据配对。如果 a 表有3 条数据， b 表有 5 条数据，那么联合表就会有 15 （ =5*3）条数据。</p>
<blockquote>
<p>从集合论（关系代数）的角度来看，一张数据库的表就是一组数据元的关系，而每个 SQL 语句会改变一种或数种关系，从而产生出新的数据元的关系（即产生新的表）</p>
</blockquote>
<h2 id="SQL-语句中的表连接"><a href="#SQL-语句中的表连接" class="headerlink" title="SQL 语句中的表连接"></a>SQL 语句中的表连接</h2><p><strong>SQL 是对表的引用， JOIN 则是一种引用表的复杂方式</strong> 。严格的说 JOIN 语句并非是 SELECT 中的一部分，而是<strong>一种特殊的表引用语句</strong>。SQL 语言标准中表的连接定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;table reference&gt; ::&#x3D;</span><br><span class="line">    &lt;table name&gt;</span><br><span class="line">  | &lt;derived table&gt;</span><br><span class="line">  | &lt;joined table&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM a1 JOIN a2 ON a1.id = a2.id, b</span><br></pre></td></tr></table></figure>
<p> JOIN 是构建连接表的关键词，并不是 SELECT 语句的一部分。有一些数据库允许在 INSERT 、 UPDATE 、 DELETE 中使用 JOIN 。</p>
<p>使用 JOIN 语句的好处在于：</p>
<ul>
<li>安全。JOIN 和要连接的表离得非常近，这样就能避免错误。</li>
<li>更多连接的方式，JOIN 语句能去区分出来外连接和内连接等。</li>
</ul>
<h2 id="SQL-语句中不同的连接操作"><a href="#SQL-语句中不同的连接操作" class="headerlink" title="SQL 语句中不同的连接操作"></a><strong>SQL 语句中不同的连接操作</strong></h2><p>SQL 语句中，表连接的方式从根本上分为五种：</p>
<ul>
<li>EQUI JOIN</li>
<li>SEMI JOIN</li>
<li>ANTI JOIN</li>
<li>CROSS JOIN</li>
<li>DIVISION</li>
</ul>
<h3 id="EQUI-JOIN"><a href="#EQUI-JOIN" class="headerlink" title="EQUI JOIN"></a><strong>EQUI JOIN</strong></h3><p>包含两种连接方式：</p>
<ul>
<li>INNER JOIN（或者是 JOIN ）</li>
<li>OUTER JOIN（包括：LEFT 、 RIGHT、 FULL OUTER JOIN）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- This table reference contains authors and their books.</span></span><br><span class="line"><span class="comment">-- There is one record for each book and its author.</span></span><br><span class="line"><span class="comment">-- authors without books are NOT included</span></span><br><span class="line">author JOIN book ON author.id = book.author_id</span><br><span class="line"></span><br><span class="line"><span class="comment">-- This table reference contains authors and their books</span></span><br><span class="line"><span class="comment">-- There is one record for each book and its author.</span></span><br><span class="line"><span class="comment">-- ... OR there is an "empty" record for authors without books</span></span><br><span class="line"><span class="comment">-- ("empty" meaning that all book columns are NULL)</span></span><br><span class="line">author LEFT OUTER JOIN book ON author.id = book.author_id</span><br></pre></td></tr></table></figure>
<h3 id="SEMI-JOIN"><a href="#SEMI-JOIN" class="headerlink" title="SEMI JOIN"></a>SEMI JOIN</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Using IN</span></span><br><span class="line">FROM author WHERE author.id IN (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"><span class="comment">-- Using EXISTS</span></span><br><span class="line"><span class="keyword">FROM</span> author <span class="keyword">WHERE</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<ul>
<li>IN比 EXISTS 的可读性更好</li>
<li>EXISTS 比IN 的表达性更好（更适合复杂的语句）</li>
<li>二者之间性能没有差异（但对于某些数据库来说性能差异会非常大）</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Find only those authors who also have books</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> first_name, last_name</span><br><span class="line"><span class="keyword">FROM</span> author <span class="keyword">JOIN</span> book <span class="keyword">ON</span> author.id = book.author_id</span><br></pre></td></tr></table></figure>
<p>这是一种很糟糕的写法，原因如下：</p>
<ul>
<li>SQL 语句性能低下：因为去重操作（ DISTINCT ）需要数据库重复从硬盘中读取数据到内存中。</li>
<li>这么写并非完全正确：尽管也许现在这么写不会出现问题，但是随着 SQL 语句变得越来越复杂，想要去重得到正确的结果就变得十分困难。</li>
</ul>
<h3 id="ANTI-JOIN"><a href="#ANTI-JOIN" class="headerlink" title="ANTI JOIN"></a><strong>ANTI JOIN</strong></h3><p>这种连接的关系跟 SEMI JOIN 刚好相反。在 IN 或者 EXISTS 前加一个 NOT 关键字就能使用这种连接。举个例子来说，我们列出书名表里没有书的作者：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Using IN</span></span><br><span class="line">FROM author WHERE author.id NOT IN (<span class="keyword">SELECT</span> book.author_id <span class="keyword">FROM</span> book)</span><br><span class="line"><span class="comment">-- Using EXISTS</span></span><br><span class="line"><span class="keyword">FROM</span> author <span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (<span class="keyword">SELECT</span> <span class="number">1</span> <span class="keyword">FROM</span> book <span class="keyword">WHERE</span> book.author_id = author.id)</span><br></pre></td></tr></table></figure>
<h3 id="CROSS-JOIN"><a href="#CROSS-JOIN" class="headerlink" title="CROSS JOIN"></a><strong>CROSS JOIN</strong></h3><p>这个连接过程就是<strong>两个连接的表的乘积</strong>：即将第一张表的每一条数据分别对应第二张表的每条数据。这就是逗号在 FROM 语句中的用法。在实际的应用中，很少有地方能用到 CROSS JOIN，一旦用上，可以用这样的 SQL语句表达：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Combine every author with every book</span></span><br><span class="line">author CROSS JOIN book</span><br><span class="line"><span class="comment">-- 等同于</span></span><br><span class="line">FROM author, book</span><br></pre></td></tr></table></figure>
<h3 id="DIVISION"><a href="#DIVISION" class="headerlink" title="DIVISION"></a><strong>DIVISION</strong></h3><p>DIVISION 比较奇怪。简而言之，如果 JOIN 是一个乘法运算，那么 DIVISION 就是 JOIN 的逆过程。DIVISION 的关系很难用 SQL 表达出来。</p>
<h2 id="SQL-中的派生表"><a href="#SQL-中的派生表" class="headerlink" title="SQL 中的派生表"></a><strong>SQL 中的派生表</strong></h2><p>派生表就是在括号之中的子查询：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- A derived table</span></span><br><span class="line">FROM (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author)</span><br><span class="line"><span class="comment">-- 我们可以给派生表定义一个相关名（即别名）</span></span><br><span class="line"><span class="comment">-- A derived table with an alias</span></span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> * <span class="keyword">FROM</span> author) a</span><br></pre></td></tr></table></figure>
<p>派生表可以有效的避免由于 SQL 逻辑而产生的问题。</p>
<p>想重用一个用 SELECT 和 WHERE 语句查询出的结果：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Get authors' first and last names, and their age in days</span></span><br><span class="line"><span class="keyword">SELECT</span> first_name, last_name, age</span><br><span class="line"><span class="keyword">FROM</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, <span class="keyword">current_date</span> - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="comment">-- If the age is greater than 10000 days</span></span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<p>在有些数据库，以及 SQL ：1990 标准中，派生表被归为下一级——通用表语句（ common table experssion）。允许在一个 SELECT 语句中对派生表多次重用。上面的例子就（几乎）等价于下面的语句：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> a <span class="keyword">AS</span> (</span><br><span class="line">  <span class="keyword">SELECT</span> first_name, last_name, <span class="keyword">current_date</span> - date_of_birth age</span><br><span class="line">  <span class="keyword">FROM</span> author</span><br><span class="line">)</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> a</span><br><span class="line"><span class="keyword">WHERE</span> age &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<h3 id="SQL-语句中-GROUP-BY"><a href="#SQL-语句中-GROUP-BY" class="headerlink" title="SQL 语句中 GROUP BY"></a><strong>SQL 语句中 GROUP BY</strong></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.x, A.y, <span class="keyword">SUM</span>(A.z)</span><br><span class="line"><span class="keyword">FROM</span> A</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> A.x, A.y</span><br></pre></td></tr></table></figure>
<h3 id="SQL-语句中的-SELECT-实质上是对关系的映射"><a href="#SQL-语句中的-SELECT-实质上是对关系的映射" class="headerlink" title="SQL 语句中的 SELECT 实质上是对关系的映射"></a><strong>SQL 语句中的 SELECT 实质上是对关系的映射</strong></h3><p>SELECT 语句就像一个“投影仪”，可以将其理解成一个将源表中的数据按照一定的逻辑转换成目标表数据的函数。</p>
<p>通过 SELECT语句，可以对每一个字段进行操作，通过复杂的表达式生成所需要的数据。</p>
<p>SELECT 语句有很多特殊的规则：</p>
<ul>
<li><p>仅能够使用能通过表引用而得来的字段；</p>
</li>
<li><p>如果有 GROUP BY 语句，只能够使用 GROUP BY 语句后面的字段或者聚合函数；</p>
</li>
<li><p>当语句中没有 GROUP BY 的时候，可以使用开窗函数代替聚合函数；</p>
</li>
<li><p>当语句中没有 GROUP BY 的时候，不能同时使用聚合函数和其它函数；</p>
<blockquote>
<p>在既有聚合函数又有普通函数的 SQL 语句中，如果没有 GROUP BY 进行分组，SQL 语句默认视整张表为一个分组，当聚合函数对某一字段进行聚合统计的时候，引用的表中的每一条 record 就失去了意义，全部的数据都聚合为一个统计值，你此时对每一条 record 使用其它函数是没有意义的</p>
</blockquote>
</li>
<li><p>有一些方法可以将普通函数封装在聚合函数中</p>
</li>
</ul>
<h3 id="DISTINCT-，-UNION-，-ORDER-BY-和-OFFSET"><a href="#DISTINCT-，-UNION-，-ORDER-BY-和-OFFSET" class="headerlink" title="DISTINCT ， UNION ， ORDER BY 和 OFFSET"></a><strong>DISTINCT ， UNION ， ORDER BY 和 OFFSET</strong></h3><h4 id="集合运算（-DISTINCT-和-UNION-）"><a href="#集合运算（-DISTINCT-和-UNION-）" class="headerlink" title="集合运算（ DISTINCT 和 UNION ）"></a>集合运算（ DISTINCT 和 UNION ）</h4><p>集合运算主要操作在于集合上，事实上指的就是对表的一种操作。</p>
<ul>
<li>DISTINCT 在映射之后对数据进行去重</li>
<li>UNION 将两个子查询拼接起来并去重</li>
<li>UNION ALL 将两个子查询拼接起来但不去重</li>
<li>EXCEPT 将第二个字查询中的结果从第一个子查询中去掉</li>
<li>INTERSECT 保留两个子查询中都有的结果并去重</li>
</ul>
<h4 id="排序运算（-ORDER-BY，OFFSET…FETCH）"><a href="#排序运算（-ORDER-BY，OFFSET…FETCH）" class="headerlink" title="排序运算（ ORDER BY，OFFSET…FETCH）"></a>排序运算（ ORDER BY，OFFSET…FETCH）</h4><p>排序运算跟逻辑关系无关。这是一个 SQL 特有的功能。排序运算不仅在 SQL 语句的最后，而且在 SQL 语句运行的过程中也是最后执行的。使用 ORDER BY 和 OFFSET…FETCH 是保证数据能够按照顺序排列的最有效的方式。</p>
<p>OFFSET…SET是一个没有统一确定语法的语句，不同的数据库有不同的表达方式，如 MySQL 和 PostgreSQL 的 LIMIT…OFFSET、SQL Server 和 Sybase 的 TOP…START AT 等。</p>
<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL是一种开放源代码的关系型数据库管理系统（Relational Database Management System，RDBMS），由瑞典 MySQL AB 公司开发，属于 Oracle 旗下产品，使用最常用的数据库管理语言–结构化查询语言（SQL）进行数据库管理。</p>
<h2 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h2><p><code>mysql  -u user -p</code></p>
<p>退出连接：<code>QUIT 或者 Ctrl+D</code></p>
<h2 id="查看，创建，使用数据库"><a href="#查看，创建，使用数据库" class="headerlink" title="查看，创建，使用数据库:"></a>查看，创建，使用数据库:</h2><p><code>show databases;</code></p>
<p>默认数据库：</p>
<figure class="highlight plain"><figcaption><span>- 用户权限相关数据</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql - 用户权限相关数据保存在mysql数据库的user表中</span><br><span class="line">test - 用于用户测试数据</span><br><span class="line">information_schema - MySQL本身架构相关数据</span><br></pre></td></tr></table></figure>
<p>创建数据库：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database db1 DEFAULT CHARSET utf8 COLLATE utf8_general_ci; # utf8编码</span><br><span class="line">create database db1 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; # gbk编码</span><br></pre></td></tr></table></figure>
<p>使用数据库：<code>use db1;</code></p>
<p>显示当前使用的数据库中所有表：<code>SHOW TABLES;</code></p>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><p>创建用户：<code>create user &#39;用户名&#39;@&#39;IP地址&#39; identified by &#39;密码&#39;;</code></p>
<p>修改用户：<code>rename user &#39;用户名&#39;@&#39;IP地址&#39;; to &#39;新用户名&#39;@&#39;IP地址&#39;;</code></p>
<p>删除用户：<code>drop user &#39;用户名&#39;@&#39;IP地址&#39;;</code></p>
<p>修改密码：<code>set password for &#39;用户名&#39;@&#39;IP地址&#39; = Password(&#39;新密码&#39;);</code></p>
<h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>mysql对于权限这块有以下限制：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">all privileges：除grant外的所有权限</span><br><span class="line">select：仅查权限</span><br><span class="line">select,insert：查和插入权限</span><br><span class="line">...</span><br><span class="line">usage：无访问权限</span><br><span class="line">alter：使用alter table</span><br><span class="line">alter routine：使用alter procedure和drop procedure</span><br><span class="line">create：使用create table</span><br><span class="line">create routine：使用create procedure</span><br><span class="line">create temporary tables：使用create temporary tables</span><br><span class="line">create user：使用create user、drop user、rename user和revoke  all privileges</span><br><span class="line">create view：使用create view</span><br><span class="line">delete：使用delete</span><br><span class="line">drop：使用drop table</span><br><span class="line">execute：使用call和存储过程</span><br><span class="line">file：使用select into outfile 和 load data infile</span><br><span class="line">grant option：使用grant 和 revoke</span><br><span class="line">index：使用index</span><br><span class="line">insert：使用insert</span><br><span class="line">lock tables：使用lock table</span><br><span class="line">process：使用show full processlist</span><br><span class="line">select：使用select</span><br><span class="line">show databases：使用show databases</span><br><span class="line">show view：使用show view</span><br><span class="line">update：使用update</span><br><span class="line">reload：使用flush</span><br><span class="line">shutdown：使用mysqladmin shutdown(关闭MySQL)</span><br><span class="line">super：使用change master、kill、logs、purge、master和set global。还允许mysqladmin调试登陆</span><br><span class="line">replication client：服务器位置的访问</span><br><span class="line">replication slave：由复制从属使用</span><br></pre></td></tr></table></figure>
<p>对于数据库及内部其他权限如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据库名.*            数据库中的所有</span><br><span class="line">数据库名.表           指定数据库中的某张表</span><br><span class="line">数据库名.存储过程      指定数据库中的存储过程</span><br><span class="line">*.*                   所有数据库</span><br></pre></td></tr></table></figure>
<p>对于用户和IP的权限如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用户名@IP地址        用户只能在改IP下才能访问</span><br><span class="line">用户名@192.168.1.%   用户只能在改IP段下才能访问(通配符%表示任意)</span><br><span class="line">用户名@%             用户可以再任意IP下访问(默认IP地址为%)</span><br></pre></td></tr></table></figure>
<p>1、查看权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show grants for &#39;用户&#39;@&#39;IP地址&#39;</span><br></pre></td></tr></table></figure>
<p>2、授权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant  权限 on 数据库.表 to   &#39;用户&#39;@&#39;IP地址&#39;</span><br></pre></td></tr></table></figure>
<p>3、取消授权</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">revoke 权限 on 数据库.表 from &#39;用户名&#39;@&#39;IP地址&#39;</span><br></pre></td></tr></table></figure>
<p>授权实例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on db1.tb1 TO &#39;用户名&#39;@&#39;IP&#39;</span><br><span class="line"></span><br><span class="line">grant select on db1.* TO &#39;用户名&#39;@&#39;IP&#39;</span><br><span class="line"></span><br><span class="line">grant select,insert on *.* TO &#39;用户名&#39;@&#39;IP&#39;</span><br><span class="line"></span><br><span class="line">revoke select on db1.tb1 from &#39;用户名&#39;@&#39;IP&#39;</span><br></pre></td></tr></table></figure>
<h2 id="MySQL表操作"><a href="#MySQL表操作" class="headerlink" title="MySQL表操作"></a>MySQL表操作</h2><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">show tables; # 查看数据库全部表</span><br><span class="line">select * from 表名; # 查看表所有内容</span><br></pre></td></tr></table></figure>
<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">    列名  类型  是否可以为空，</span><br><span class="line">    列名  类型  是否可以为空</span><br><span class="line">)ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure>
<p>例如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;tab1&#96; (</span><br><span class="line">  &#96;nid&#96; int(11) NOT NULL auto_increment,</span><br><span class="line">  &#96;name&#96; varchar(255) DEFAULT zhangyanlin,</span><br><span class="line">  &#96;email&#96; varchar(255),</span><br><span class="line">  PRIMARY KEY (&#96;nid&#96;) </span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>默认值，创建列时可以指定默认值，当插入数据时如果未主动设置，则自动添加默认值。</p>
</li>
<li><p>自增，如果为某列设置自增列，插入数据时无需设置此列，默认将自增（表中只能有一个自增列）</p>
<blockquote>
<p>注意：</p>
<p>1、自增列，必须是索引（含主键）</p>
<p>2、自增可以设置步长和起始值。</p>
</blockquote>
</li>
<li><p>主键，一种特殊的唯一索引，不允许有空值，如果主键使用单个列，则它的值必须唯一，如果是多列，则其组合必须唯一。</p>
</li>
</ul>
<h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名</span><br></pre></td></tr></table></figure>
<h3 id="清空表内容"><a href="#清空表内容" class="headerlink" title="清空表内容"></a>清空表内容</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 表名</span><br><span class="line">truncate table 表名</span><br></pre></td></tr></table></figure>
<h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">添加列：   </span><br><span class="line">alter table 表名 add 列名 类型</span><br><span class="line">删除列：   </span><br><span class="line">alter table 表名 drop column 列名</span><br><span class="line">修改列：      </span><br><span class="line">alter table 表名 modify column 列名 类型;  -- 类型</span><br><span class="line">alter table 表名 change 原列名 新列名 类型; -- 列名，类型</span><br><span class="line">添加主键：       </span><br><span class="line">alter table 表名 add primary key(列名);</span><br><span class="line">删除主键：         </span><br><span class="line">alter table 表名 drop primary key;</span><br><span class="line">alter table 表名  modify  列名 int, drop primary key;</span><br><span class="line">添加外键： </span><br><span class="line">alter table 从表 add constraint 外键名称（形如：FK_从表_主表） foreign key 从表(外键字段) references 主表(主键字段);</span><br><span class="line">删除外键： </span><br><span class="line">alter table 表名 drop foreign key 外键名称</span><br><span class="line">修改默认值：</span><br><span class="line">ALTER TABLE testalter_tbl ALTER i SET DEFAULT 1000;</span><br><span class="line">删除默认值：</span><br><span class="line">ALTER TABLE testalter_tbl ALTER i DROP DEFAULT;</span><br></pre></td></tr></table></figure>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>MySQL的数据类型大致分为：<strong>数值、时间和字符串</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">bit[(M)]</span><br><span class="line">            二进制位（101001），m表示二进制位的长度（1-64），默认m＝1</span><br><span class="line">tinyint[(m)] [unsigned] [zerofill]</span><br><span class="line">            小整数，数据类型用于保存一些范围的整数数值范围：</span><br><span class="line">            有符号：</span><br><span class="line">                -128 ～ 127.</span><br><span class="line">            无符号：</span><br><span class="line">                0 ～ 255</span><br><span class="line">            特别的： MySQL中无布尔值，使用tinyint(1)构造。</span><br><span class="line">int[(m)][unsigned][zerofill]</span><br><span class="line">            整数，数据类型用于保存一些范围的整数数值范围：</span><br><span class="line">                有符号：</span><br><span class="line">                    -2147483648 ～ 2147483647</span><br><span class="line">                无符号：</span><br><span class="line">                    0 ～ 4294967295</span><br><span class="line">            特别的：整数类型中的m仅用于显示，对存储范围无限制。例如： int(5),当插入数据2时，select 时数据显示为：00002</span><br><span class="line">bigint[(m)][unsigned][zerofill]</span><br><span class="line">            大整数，数据类型用于保存一些范围的整数数值范围：</span><br><span class="line">                有符号：</span><br><span class="line">                    -9223372036854775808 ～ 9223372036854775807</span><br><span class="line">                无符号：</span><br><span class="line">                    0  ～  18446744073709551615</span><br><span class="line">decimal[(m[,d])] [unsigned] [zerofill]</span><br><span class="line">            准确的小数值，m是数字总个数（负号不算），d是小数点后个数。 m最大值为65，d最大值为30。</span><br><span class="line">            特别的：对于精确数值计算时需要用此类型</span><br><span class="line">                   decaimal能够存储精确值的原因在于其内部按照字符串存储。</span><br><span class="line">FLOAT[(M,D)] [UNSIGNED] [ZEROFILL]          </span><br><span class="line">            单精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。</span><br><span class="line">                无符号：</span><br><span class="line">                    -3.402823466E+38 to -1.175494351E-38,</span><br><span class="line">                    0</span><br><span class="line">                    1.175494351E-38 to 3.402823466E+38</span><br><span class="line">                有符号：</span><br><span class="line">                    0</span><br><span class="line">                    1.175494351E-38 to 3.402823466E+38</span><br><span class="line">            **** 数值越大，越不准确 ****</span><br><span class="line">DOUBLE[(M,D)] [UNSIGNED] [ZEROFILL]</span><br><span class="line">            双精度浮点数（非准确小数值），m是数字总个数，d是小数点后个数。</span><br><span class="line">                无符号：</span><br><span class="line">                    -1.7976931348623157E+308 to -2.2250738585072014E-308</span><br><span class="line">                    0</span><br><span class="line">                    2.2250738585072014E-308 to 1.7976931348623157E+308</span><br><span class="line">                有符号：</span><br><span class="line">                    0</span><br><span class="line">                    2.2250738585072014E-308 to 1.7976931348623157E+308</span><br><span class="line">            **** 数值越大，越不准确 ****</span><br><span class="line">char (m)</span><br><span class="line">            char数据类型用于表示固定长度的字符串，可以包含最多达255个字符。其中m代表字符串的长度。</span><br><span class="line">            PS: 即使数据小于m长度，也会占用m长度          </span><br><span class="line">varchar(m)</span><br><span class="line">            varchars数据类型用于变长的字符串，可以包含最多达255个字符。其中m代表该数据类型所允许保存的字符串的最大长度，只要长度小于该最大值的字符串都可以被保存在该数据类型中。</span><br><span class="line"></span><br><span class="line">            注：虽然varchar使用起来较为灵活，但是从整个系统的性能角度来说，char数据类型的处理速度更快，有时甚至可以超出varchar处理速度的50%。因此，用户在设计数据库时应当综合考虑各方面的因素，以求达到最佳的平衡</span><br><span class="line">text</span><br><span class="line">            text数据类型用于保存变长的大字符串，可以组多到65535 (2**16 − 1)个字符。</span><br><span class="line">mediumtext</span><br><span class="line">            A TEXT column with a maximum length of 16,777,215 (2**24 − 1) characters.</span><br><span class="line">longtext</span><br><span class="line">            A TEXT column with a maximum length of 4,294,967,295 or 4GB (2**32 − 1) characters.</span><br><span class="line">enum</span><br><span class="line">            枚举类型，</span><br><span class="line">            An ENUM column can have a maximum of 65,535 distinct elements. (The practical limit is less than 3000.)</span><br><span class="line">            示例：</span><br><span class="line">                CREATE TABLE shirts (</span><br><span class="line">                    name VARCHAR(40),</span><br><span class="line">                    size ENUM(&#39;x-small&#39;, &#39;small&#39;, &#39;medium&#39;, &#39;large&#39;, &#39;x-large&#39;)</span><br><span class="line">                );</span><br><span class="line">                INSERT INTO shirts (name, size) VALUES (&#39;dress shirt&#39;,&#39;large&#39;), (&#39;t-shirt&#39;,&#39;medium&#39;),(&#39;polo shirt&#39;,&#39;small&#39;);</span><br><span class="line">set</span><br><span class="line">            集合类型</span><br><span class="line">            A SET column can have a maximum of 64 distinct members.</span><br><span class="line">            示例：</span><br><span class="line">                CREATE TABLE myset (col SET(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;));</span><br><span class="line">                INSERT INTO myset (col) VALUES (&#39;a,d&#39;), (&#39;d,a&#39;), (&#39;a,d,a&#39;), (&#39;a,d,d&#39;), (&#39;d,a,d&#39;);</span><br><span class="line"></span><br><span class="line">DATE          </span><br><span class="line">            YYYY-MM-DD（1000-01-01&#x2F;9999-12-31）</span><br><span class="line">TIME</span><br><span class="line">            HH:MM:SS（&#39;-838:59:59&#39;&#x2F;&#39;838:59:59&#39;）</span><br><span class="line">YEAR</span><br><span class="line">            YYYY（1901&#x2F;2155）</span><br><span class="line">DATETIME</span><br><span class="line">            YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00&#x2F;9999-12-31 23:59:59    Y）</span><br><span class="line">TIMESTAMP</span><br><span class="line">            YYYYMMDD HHMMSS（1970-01-01 00:00:00&#x2F;2037 年某时）</span><br></pre></td></tr></table></figure>
<h2 id="MySQL表内容操作"><a href="#MySQL表内容操作" class="headerlink" title="MySQL表内容操作"></a>MySQL表内容操作</h2><p>表内容操包括<strong>增删改查</strong>，最多的是查</p>
<h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert into 表 (列名,列名...) values (值,值,...)</span><br><span class="line">insert into 表 (列名,列名...) values (值,值,...),(值,值,值...)</span><br><span class="line">insert into 表 (列名,列名...) select (列名,列名...) from 表</span><br><span class="line">例：</span><br><span class="line">    insert into tab1(name,email) values(&#39;zhangyanlin&#39;,&#39;zhangyanlin8851@163.com&#39;)</span><br></pre></td></tr></table></figure>
<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete from 表   # 删除表里全部数据</span><br><span class="line">delete from 表 where id＝1 and name＝&#39;zhangyanlin&#39; # 删除ID &#x3D;1 和name&#x3D;&#39;zhangyanlin&#39; 那一行数据</span><br></pre></td></tr></table></figure>
<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update 表 set name ＝ &#39;zhangyanlin&#39; where id&gt;1</span><br></pre></td></tr></table></figure>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from 表</span><br><span class="line">select * from 表 where id &gt; 1</span><br><span class="line">select nid,name,gender as gg from 表 where id &gt; 1</span><br></pre></td></tr></table></figure>
<h4 id="条件判断where"><a href="#条件判断where" class="headerlink" title="条件判断where"></a>条件判断where</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where id &gt; 1 and name !&#x3D; &#39;aylin&#39; and num &#x3D; 12;</span><br><span class="line">select * from 表 where id between 5 and 16;</span><br><span class="line">select * from 表 where id in (11,22,33)</span><br><span class="line">select * from 表 where id not in (11,22,33)</span><br><span class="line">select * from 表 where id in (select nid from 表)</span><br></pre></td></tr></table></figure>
<h4 id="通配符like"><a href="#通配符like" class="headerlink" title="通配符like"></a>通配符like</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 where name like &#39;zhang%&#39;  # zhang开头的所有（多个字符串）</span><br><span class="line">select * from 表 where name like &#39;zhang_&#39;  # zhang开头的所有（一个字符）</span><br></pre></td></tr></table></figure>
<h4 id="限制limit"><a href="#限制limit" class="headerlink" title="限制limit"></a>限制limit</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 limit 5;            - 前5行</span><br><span class="line">select * from 表 limit 4,5;          - 从第4行开始的5行</span><br><span class="line">select * from 表 limit 5 offset 4    - 从第4行开始的5行</span><br></pre></td></tr></table></figure>
<h4 id="排序asc，desc"><a href="#排序asc，desc" class="headerlink" title="排序asc，desc"></a>排序asc，desc</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from 表 order by 列 asc              - 根据 “列” 从小到大排列</span><br><span class="line">select * from 表 order by 列 desc             - 根据 “列” 从大到小排列</span><br><span class="line">select * from 表 order by 列1 desc,列2 asc    - 根据 “列1” 从大到小排列，如果相同则按列2从小到大排序</span><br></pre></td></tr></table></figure>
<h4 id="分组group-by"><a href="#分组group-by" class="headerlink" title="分组group by"></a>分组group by</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select num from 表 group by num</span><br><span class="line">select num,nid from 表 group by num,nid</span><br><span class="line">select num,nid from 表  where nid &gt; 10 group by num,nid order nid desc</span><br><span class="line">select num,nid,count(*),sum(score),max(score),min(score) from 表 group by num,nid</span><br><span class="line">select num from 表 group by num having max(id) &gt; 10</span><br><span class="line"></span><br><span class="line">特别的：group by 必须在where之后，order by之前</span><br></pre></td></tr></table></figure>
<p><a href="https://mp.weixin.qq.com/s/ha_tlD0H_HrrdbmoB7NlzA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/ha_tlD0H_HrrdbmoB7NlzA</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/hexo-next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/hexo-next%E4%B8%BB%E9%A2%98%E8%AE%BE%E7%BD%AE/" class="post-title-link" itemprop="url">hexo-next主题设置</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-04 16:39:43 / Modified: 16:51:42" itemprop="dateCreated datePublished" datetime="2020-09-04T16:39:43+08:00">2020-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="NexT主题开启文章目录"><a href="#NexT主题开启文章目录" class="headerlink" title="NexT主题开启文章目录"></a>NexT主题开启文章目录</h2><p>参考这篇<a href="https://blog.csdn.net/wugenqiang/article/details/88609066" target="_blank" rel="noopener">博客</a></p>
<h3 id="修改样式文件"><a href="#修改样式文件" class="headerlink" title="修改样式文件"></a>修改样式文件</h3><p>在<code>custom.styl</code>文件（位于<code>themes/next/source/css/_custom下</code>）后添加</p>
<p>文章目录展开</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//文章目录默认展开</span><br><span class="line">.post-toc .nav .nav-child &#123; display: block; &#125;</span><br></pre></td></tr></table></figure>
<p>以及目录字体大小调整</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.post-toc ol &#123;  </span><br><span class="line">  font-size : <span class="number">13</span>px;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开主题的配置文件<code>_config.yml</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">toc:</span><br><span class="line">  enable: true</span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line">  number: false</span><br><span class="line">  <span class="comment"># If true, all words will placed on next lines if header width longer then sidebar width.</span></span><br><span class="line">  wrap: false</span><br><span class="line">  <span class="comment"># If true, all level of TOC in a post will be displayed, rather than the activated part of it.</span></span><br><span class="line">  expand_all: false</span><br><span class="line">  <span class="comment"># Maximum heading depth of generated toc.</span></span><br><span class="line">  max_depth: <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>PS: 我的主题目录下没有·custom.styl·这个文件（<code>themes/next/source/css/_custom</code>），但最终也能生成目录ORZ。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/Typora%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/Typora%E4%BD%BF%E7%94%A8/" class="post-title-link" itemprop="url">Typora使用</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-04 16:34:01 / Modified: 16:39:02" itemprop="dateCreated datePublished" datetime="2020-09-04T16:34:01+08:00">2020-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index">
                    <span itemprop="name">markdown</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="插入大纲目录"><a href="#插入大纲目录" class="headerlink" title="插入大纲目录"></a>插入大纲目录</h2><p>使用 <code>[TOC]</code>可以在顶部显示目录，但是hexo不能渲染</p>
<h2 id="左侧大纲视图折叠"><a href="#左侧大纲视图折叠" class="headerlink" title="左侧大纲视图折叠"></a>左侧大纲视图折叠</h2><p>Typora 中 shift+ctrl+O 可以在左侧显示大纲视图，但是当目录很长，默认展开时，</p>
<p>文件 ⇒ 偏好设置 ⇒ 侧边栏 ⇒  选中侧边栏的大纲视图允许折叠和展开。</p>
<p>参考：<a href="https://www.cnblogs.com/tian-ci/p/10543088.html" target="_blank" rel="noopener">https://www.cnblogs.com/tian-ci/p/10543088.html</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/04/hexo-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/04/hexo-%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/" class="post-title-link" itemprop="url">hexo-如何支持数学公式</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-09-04 16:18:46 / Modified: 16:33:09" itemprop="dateCreated datePublished" datetime="2020-09-04T16:18:46+08:00">2020-09-04</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/hexo/" itemprop="url" rel="index">
                    <span itemprop="name">hexo</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近在学习hands on sklearn这本书，用Typora做笔记时有大量公式，今天发现hexo默认不支持数学公式。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Hexo默认使用<code>hexo-renderer-marked</code>引擎渲染网页，该引擎会把一些特殊的markdown符号转换为相应的html标签，比如下划线’_’会被渲染引擎处理为<code>&lt;em&gt;</code>标签,这样MathJax引擎就认为该公式有语法错误，因此不会渲染。</p>
<p>类似的语义冲突的符号还包括’*’, ‘{‘, ‘}’, ‘\’等。</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用hexo-renderer-kramed引擎渲染"><a href="#使用hexo-renderer-kramed引擎渲染" class="headerlink" title="使用hexo-renderer-kramed引擎渲染"></a>使用<code>hexo-renderer-kramed</code>引擎渲染</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure>
<p>但<code>hexo-renderer-kramed</code>引擎也有语义冲突（行内公式，{问题）：</p>
<p>接下来到博客根目录下，找到<code>node_modules\kramed\lib\rules\inline.js</code>，修改如下两处</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="line">  escape: /^\\([`*\[\]()#$+\-.!_&gt;])/</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="line">  em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></pre></td></tr></table></figure>
<h3 id="在主题文件中开启mathjax开关"><a href="#在主题文件中开启mathjax开关" class="headerlink" title="在主题文件中开启mathjax开关"></a>在主题文件中开启mathjax开关</h3><p>进入主题目录，打开<code>_config.yml</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Math Formulas Render Support</span></span><br><span class="line">math:</span><br><span class="line">  per_page: true</span><br><span class="line">  engine: mathjax   </span><br><span class="line">  mathjax:</span><br><span class="line">    enable: true    </span><br><span class="line">    mhchem: true</span><br></pre></td></tr></table></figure>
<h3 id="在Front-matter中打开mathjax开关"><a href="#在Front-matter中打开mathjax开关" class="headerlink" title="在Front-matter中打开mathjax开关"></a>在Front-matter中打开mathjax开关</h3><p>因为之前配置文件中设置了<code>per_page: true</code>，意味着：</p>
<blockquote>
<p>Default (true) will load mathjax / katex script on demand.</p>
<p>That is it only render those page which has <code>mathjax: true</code> in Front-matter.</p>
<p>If you set it to false, it will load mathjax / katex srcipt EVERY PAGE.</p>
</blockquote>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: </span><br><span class="line">date: </span><br><span class="line">tags:</span><br><span class="line">category: </span><br><span class="line">mathjax: true</span><br><span class="line">--</span><br></pre></td></tr></table></figure>
<p>但我把<code>per_page: false</code>，尝试不在front-matter中加上 <code>mathjax: true</code> ，没有效果。</p>
<hr>
<p>参考：</p>
<p><a href="https://blog.csdn.net/ssjdoudou/article/details/103318019" target="_blank" rel="noopener">https://blog.csdn.net/ssjdoudou/article/details/103318019</a></p>
<p><a href="https://www.jianshu.com/p/7ab21c7f0674" target="_blank" rel="noopener">https://www.jianshu.com/p/7ab21c7f0674</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/03/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/09/03/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/" class="post-title-link" itemprop="url">《Scikit-Learn与TensorFlow机器学习实用指南》-第二部分</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-03 18:28:14" itemprop="dateCreated datePublished" datetime="2020-09-03T18:28:14+08:00">2020-09-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 10:15:51" itemprop="dateModified" datetime="2020-09-16T10:15:51+08:00">2020-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>学习资料参考：</p>
<p><a href="https://www.cntofu.com/book/27/docs/2.%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">一个完整的机器学习项目.md</a></p>
<p><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">原书Github上代码</a></p>
<p><a href="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/" target="_blank" rel="noopener">Oreilly上原书第二版（可以在线阅读）</a></p>
<p><a href="https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88.md" target="_blank" rel="noopener">第一版翻译</a></p>
<p><a href="https://www.jianshu.com/p/3470a6efbe8d" target="_blank" rel="noopener">简书第一版</a></p>
<p><a href="https://www.jianshu.com/p/86626c79814a" target="_blank" rel="noopener">简书第二版第二部分</a></p>
<p><a href="https://www.jianshu.com/p/4a94798f7dcc" target="_blank" rel="noopener">简书《Scikit-Learn、Keras与TensorFlow机器学习实用指南》第一版和第二版对照</a></p>
<p><a href="https://blog.csdn.net/jiaoyangwm/article/details/82387883#%E7%BB%83%E4%B9%A0%E9%A2%987" target="_blank" rel="noopener">练习题答案参考</a> <a href="https://blog.csdn.net/leowinbow/article/details/88581039" target="_blank" rel="noopener">参考2</a></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/09/03/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/Markdown%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/29/Markdown%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/" class="post-title-link" itemprop="url">Markdown文件恢复</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-29 19:55:49" itemprop="dateCreated datePublished" datetime="2020-08-29T19:55:49+08:00">2020-08-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-04 15:56:14" itemprop="dateModified" datetime="2020-09-04T15:56:14+08:00">2020-09-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index">
                    <span itemprop="name">markdown</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>忘了点保存，打开一看文件是空的。</p>
<ol>
<li>打开Typora $\rightarrow $ 文件$\rightarrow $ 偏好设置</li>
<li>向下滚动到 “保存 &amp; 恢复” 区域</li>
<li>点击 “恢复未保存的草稿”</li>
</ol>
<p>方法参考：<a href="https://blog.csdn.net/makesomethings/article/details/90181198" target="_blank" rel="noopener">https://blog.csdn.net/makesomethings/article/details/90181198</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/29/Markdown%E4%B9%8B%E8%A1%A8%E6%83%85%EF%BC%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2020/08/29/Markdown%E4%B9%8B%E8%A1%A8%E6%83%85%EF%BC%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/" class="post-title-link" itemprop="url">Markdown之表情，删除线和任务列表</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2020-08-29 19:35:28 / Modified: 20:10:47" itemprop="dateCreated datePublished" datetime="2020-08-29T19:35:28+08:00">2020-08-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/markdown/" itemprop="url" rel="index">
                    <span itemprop="name">markdown</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p><strong>aliases编码：语法：</strong> <code>:&lt;emoji&gt;:</code></p>
<p>🔽 😓😄</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2020/08/29/Markdown%E4%B9%8B%E8%A1%A8%E6%83%85%EF%BC%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/#more" rel="contents">
                Read more &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QQAI"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">QQAI</p>
  <div class="site-description" itemprop="description">Home is behind, the world ahead</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QQAI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
