<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>记人生的第一次面试</title>
    <url>/2020/07/21/%E8%AE%B0%E4%BA%BA%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>写在最前面：快26岁高龄才经历人生中第一次工作面试，值得写篇博客纪念一下。</p>
<a id="more"></a>

<h2 id="形式："><a href="#形式：" class="headerlink" title="形式："></a>形式：</h2><p>网络面试；2个HR，10分钟。</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li><p>1分钟自我介绍；</p>
</li>
<li><p>问了本科院系是下属院系（民办挂名）还是正经院系？</p>
<blockquote>
<p>原话不太一样，导致一开始竟然没有听出来HR的意思，还一本正经地向HR介绍。</p>
</blockquote>
</li>
<li><p>研究生升学是保研还是考研？</p>
</li>
<li><p>为什么选择招商银行，之后不打算做研究了么？</p>
<blockquote>
<p>主要从所学专业既可以继续在实验室探究更前沿的东西，也可以与企业，工业结合起来，并且战略客户部（有细分，房地产，新能源，电力等等）以及投资银行部（涉及行业研究）的岗位和专业有相关性，这样可以做到学以致用。</p>
</blockquote>
</li>
<li><p>能否接受城市的调剂？</p>
<blockquote>
<p>只有北京和深圳两个选项，个人无所谓，所以回答可以接受。</p>
</blockquote>
</li>
<li><p>能否接受岗位的调剂？</p>
<blockquote>
<p>报名表需要填写三个志愿，我先表示可以接受调剂，然后陈述第二个志愿与自己的契合点，但第三个志愿表现得有点不太乐意，HR问我帮你修改成前两个志愿可以么，我表示可以ORZ。深圳的职位和北京的不太一样（不一样怎么调剂城市呢），忘了问能不能加上深圳那边的某一个岗位。</p>
</blockquote>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>语速过快。</li>
<li>有点抢话，有时候没有听完HR的问题就开始接话准备回答了。</li>
</ol>
<hr>
<p>耐心等待结果！</p>
<p>​</p>
<p>​</p>
<p>​</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>python之csv</title>
    <url>/2020/07/25/python%E4%B9%8Bcsv/</url>
    <content><![CDATA[<h2 id="1-什么是csv？"><a href="#1-什么是csv？" class="headerlink" title="1. 什么是csv？"></a>1. 什么是csv？</h2><p><strong>Comma Separated Values</strong> (CSV), also called called <strong>Character Separated Values</strong> or <strong>Comma Delimited files</strong>, is a file format for data storage which looks like a text file, which contains a list of data separated by commas or other characters.</p>
<a id="more"></a>

<details>
<summary><mark><font color=darkred>csv的格式特点</font></mark></summary>

<ul>
<li>One line for each record</li>
<li>Comma separated fields</li>
<li>Space-characters adjacent to commas are ignored</li>
<li>Fields with in-built commas are separated by double quote characters</li>
<li>Fields with double quote characters must be surrounded by double quotes. Each inbuilt double quote must be represented by a pair of consecutive quotes</li>
<li>Fields that contain inbuilt line-breaks must be surrounded by double quotes</li>
</ul>
</details>

<h2 id="2-为什么使用csv文件？"><a href="#2-为什么使用csv文件？" class="headerlink" title="2. 为什么使用csv文件？"></a>2. 为什么使用csv文件？</h2><p>CSV结构简单，是纯文本文件，和txt的区别仅在于后缀名不同。用来做数据存储，容量比XML小（其数据由key-value组成），功能比TXT强大，另外Excel也直接支持CSV文件的查看和生成。</p>
<h3 id="Excel-打开-CSV-文件时遇到的问题。"><a href="#Excel-打开-CSV-文件时遇到的问题。" class="headerlink" title="Excel 打开  CSV 文件时遇到的问题。"></a>Excel 打开  CSV 文件时遇到的问题。</h3><p>直接用 Excel 打开 UTF-8 编码的 CSV 文件会导致汉字部分出现乱码，原因是 Excel 以 ANSI 格式打开，不会做编码识别。打开 UTF-8 编码的 CSV 文件的方法：</p>
<h4 id="1-从数据导入文本"><a href="#1-从数据导入文本" class="headerlink" title="1. 从数据导入文本"></a>1. 从数据导入文本</h4><ul>
<li>打开 Excel </li>
<li>执行“数据”-&gt;“自文本”</li>
</ul>
<ul>
<li>选择 CSV 文件，出现文本导入向导</li>
<li>选择“分隔符号”，下一步</li>
<li>勾选“逗号”，去掉“ Tab 键”，下一步，完成</li>
<li>在“导入数据”对话框里，直接点确定</li>
</ul>
<h4 id="2-转存为ANSI格式"><a href="#2-转存为ANSI格式" class="headerlink" title="2. 转存为ANSI格式"></a>2. 转存为ANSI格式</h4><p>用文本编辑器打开CSV文件，另存为ANSI格式，再用Excel打开。</p>
<h2 id="3-python自带模块csv"><a href="#3-python自带模块csv" class="headerlink" title="3. python自带模块csv"></a>3. python自带模块csv</h2><p><a href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv" target="_blank" rel="noopener"><code>csv</code></a> 模块实现了 CSV 格式表单数据的读写。其提供了诸如“以兼容 Excel 的方式输出数据文件”或“读取 Excel 程序输出的数据文件”的功能，</p>
<p><code>csv</code>定义了以下函数：</p>
<blockquote>
<p><code>csv.reader</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, **fmtparams)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamreader = csv.reader(csvfile, delimiter=<span class="string">' '</span>, quotechar=<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line">        print(<span class="string">', '</span>.join(row))</span><br></pre></td></tr></table></figure>

<p><code>csv.writer</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, **fmtparams)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamwriter = csv.writer(csvfile, delimiter=<span class="string">' '</span>,</span><br><span class="line">                            quotechar=<span class="string">'|'</span>, quoting=csv.QUOTE_MINIMAL)</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>] * <span class="number">5</span> + [<span class="string">'Baked Beans'</span>])</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>, <span class="string">'Lovely Spam'</span>, <span class="string">'Wonderful Spam'</span>])</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>csv</code>定义了以下类：</p>
<blockquote>
<p>class csv.DictReader(<em>f</em>, <em>fieldnames=None</em>, <em>restkey=None</em>, <em>restval=None</em>, <em>dialect=’excel’</em>, <em>args, *</em>kwds) </p>
<p>将csv数据读取为字典</p>
<table>
<thead>
<tr>
<th align="left">Name</th>
<th align="right">Age</th>
<th align="center">Class</th>
</tr>
</thead>
<tbody><tr>
<td align="left">A</td>
<td align="right">20</td>
<td align="center">two</td>
</tr>
<tr>
<td align="left">B</td>
<td align="right">21</td>
<td align="center">one</td>
</tr>
<tr>
<td align="left">C</td>
<td align="right">22</td>
<td align="center">one</td>
</tr>
<tr>
<td align="left">D</td>
<td align="right">23</td>
<td align="center">three</td>
</tr>
<tr>
<td align="left">E</td>
<td align="right">24</td>
<td align="center">one</td>
</tr>
</tbody></table>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"csv.csv"</span>,<span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line"> reader = csv.reader(f)</span><br><span class="line"> fieldnames = next(reader)<span class="comment">#获取数据的第一列，作为后续要转为字典的键名 生成器，next方法获取</span></span><br><span class="line"> <span class="comment"># print(fieldnames)</span></span><br><span class="line"> csv_reader = csv.DictReader(f,fieldnames=fieldnames) <span class="comment">#self._fieldnames = fieldnames # list of keys for the dict 以list的形式存放键名</span></span><br><span class="line"> <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:</span><br><span class="line">  d=&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> k,v <span class="keyword">in</span> row.items():</span><br><span class="line">   d[k]=v</span><br><span class="line">  print(d)</span><br></pre></td></tr></table></figure>

<p>class csv.DictWriter(<em>f</em>, <em>fieldnames=None</em>, <em>extrasaction=’raise’</em>, <em>dialect=’excel’</em>, <em>args, *</em>kwds)</p>
<p>将字典写入csv文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_path = <span class="string">r"E:\new.csv"</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">"w"</span>, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    fieldnames = [<span class="string">"书名"</span>, <span class="string">"作者"</span>, <span class="string">"出版时间"</span>, <span class="string">"价格"</span>, <span class="string">"评分"</span>, <span class="string">"评价人数"</span>]</span><br><span class="line">    f_csv = csv.DictWriter(f, fieldnames)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(time_list)):</span><br><span class="line">        f_csv.writerow(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"书名"</span>: book_name_list[i],</span><br><span class="line">                <span class="string">"作者"</span>: author_list[i],</span><br><span class="line">                <span class="string">"出版时间"</span>: time_list[i],</span><br><span class="line">                <span class="string">"价格"</span>: price_list[i],</span><br><span class="line">                <span class="string">"评分"</span>: score_list[i],</span><br><span class="line">                <span class="string">"评价人数"</span>: evaluator_list[i]</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考资源：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv" target="_blank" rel="noopener">Python中文文档-module csv</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>csv</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之隐藏内容</title>
    <url>/2020/07/25/Markdown%E4%B9%8B%E9%9A%90%E8%97%8F%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="1-HTML标签隐藏"><a href="#1-HTML标签隐藏" class="headerlink" title="1. HTML标签隐藏"></a>1. HTML标签隐藏</h2><p>Markdown内嵌html语法，所以可以用隐藏的html标签。</p>
<a id="more"></a>

<p><strong>注意：前面需空一行</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'display: none'</span>&gt;</span></span><br><span class="line">注释</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>测试（在浏览器中看不到即为成功）：</p>
<div style='display: none'>
注释
</div>

<h2 id="2-HTML注释隐藏"><a href="#2-HTML注释隐藏" class="headerlink" title="2. HTML注释隐藏"></a>2. HTML注释隐藏</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释，不会在浏览器中显示。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">多段</span></span><br><span class="line"><span class="comment">注释，</span></span><br><span class="line"><span class="comment">不会在浏览器中显示。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>




<p>测试（在浏览器中看不到即为成功）：</p>
<!--注释，不会在浏览器中显示。-->
<!--
多段
注释，
不会在浏览器中显示。
-->

<h2 id="3-hack-方法隐藏"><a href="#3-hack-方法隐藏" class="headerlink" title="3. hack 方法隐藏"></a>3. hack 方法隐藏</h2><p>hack方法利用markdown的解析原理来实现注释。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。</p>
<p>hack方法比上面2种方法稳定，但是语义化太差。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[comment]: <span class="tag">&lt;&gt;</span> (注释，不会在浏览器中显示。)</span><br><span class="line">[//]: <span class="tag">&lt;&gt;</span> (注释，不会在浏览器中显示。)</span><br><span class="line">[//]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure>
<p>其中，这种方法最稳定，适用性最强：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[//]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure>
<p>还可以：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[^_^]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure>
<p>测试（在浏览器中看不到即为成功）：</p>
<h2 id="4-HTML标签折叠"><a href="#4-HTML标签折叠" class="headerlink" title="4. HTML标签折叠"></a>4. HTML标签折叠</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">darkred</span>&gt;</span>摘要<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">mark</span>&gt;</span><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> -title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>  </span><br><span class="line">   隐藏代码块</span><br><span class="line">  <span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>summary：折叠语法展示的摘要</p>
<p>details：折叠语法标签</p>
<p>pre：以原有格式显示元素内的文字是已经格式化的文本。</p>
<p>blockcode：表示程序的代码块。</p>
<p>code：指定代码范例。</p>
<p><strong>隐藏内容也可以是markdown格式。</strong></p>
<p><strong><em>效果</em></strong>：</p>
<details>
<summary><mark><font color=darkred>markdown隐藏内容</font></mark></summary>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;&lt;mark&gt;&lt;font color&#x3D;darkred&gt;摘要&lt;&#x2F;font&gt;&lt;&#x2F;mark&gt;&lt;&#x2F;summary&gt;</span><br><span class="line"></span><br><span class="line">隐藏内容</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

</details>

<hr>
<p>来源：<a href="https://www.imooc.com/article/23400" target="_blank" rel="noopener">慕课网CandyBullet</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之表格</title>
    <url>/2020/07/25/Markdown%E4%B9%8B%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="1-Markdown自带表格编辑语法"><a href="#1-Markdown自带表格编辑语法" class="headerlink" title="1. Markdown自带表格编辑语法"></a>1. Markdown自带表格编辑语法</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"> |水果        | 价格    |  数量  |</span><br><span class="line"> |:--------   | -----:   | :----: |</span><br><span class="line">|香蕉        | $1      |   5    |</span><br><span class="line"> |苹果        | $1      |   6    |</span><br><span class="line"> |草莓        | $1      |   7    |</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>效果：</p>
<table>
<thead>
<tr>
<th align="left">水果</th>
<th align="right">价格</th>
<th align="center">数量</th>
</tr>
</thead>
<tbody><tr>
<td align="left">香蕉</td>
<td align="right">$1</td>
<td align="center">5</td>
</tr>
<tr>
<td align="left">苹果</td>
<td align="right">$1</td>
<td align="center">6</td>
</tr>
<tr>
<td align="left">草莓</td>
<td align="right">$1</td>
<td align="center">7</td>
</tr>
</tbody></table>
<h2 id="2-HTML表格"><a href="#2-HTML表格" class="headerlink" title="2. HTML表格"></a>2. HTML表格</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>期中<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>期末<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>88<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>96<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>97<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<th>和<td>标签都可以显示表格单元格。不同的是<th>在单元格中加粗显示。

<p><strong><th>：定义表格内的表头单元格。此th元素内部的文本通常会呈现为粗体。</strong></p>
<p>效果：</p>
<table>
<caption>学生成绩表</caption>
<tr>

<th>学号</th>
<th>期中</th>
<th>期末</th>

</tr>
<tr>

<td>001</td>
<td>88</td>
<td>90</td>

</tr> 
<tr>

<td>002</td>
<td>96</td>
<td>97</td>

</tr> 
</table>

<h2 id="3-Excel表格"><a href="#3-Excel表格" class="headerlink" title="3. Excel表格"></a>3. Excel表格</h2><p>markdown支持html语法，所以可以先使用Excel生成需要的表格，单击另存为，选择导出格式为html，此时可选择所需表格区间。保存后打开生成的html文件，将其中<code>&lt;table&gt;&lt;/table&gt;</code> 间的数据复制到markdown中即可。</p>
<p><strong>此方式可以创建复杂的表格，比如合并单元格等。</strong></p>
<h2 id="4-exceltk工具"><a href="#4-exceltk工具" class="headerlink" title="4. exceltk工具"></a>4. exceltk工具</h2><p><a href="[http://fanfeilong.github.io/](http://fanfeilong.github.io/)">范飞龙</a>开发的<a href="https://github.com/fanfeilong/exceltk" target="_blank" rel="noopener">exceltk工具</a>，通过简单的cmd命令即可把excel表格中的内容转换为Markdown所能识别的格式，直接把转换后的md格式内容复制到简书即可输出期望的表格样式。</p>
<pre><code>exceltk用例
整个表格： exceltk.exe -t md -xls xxx.xls  
          exceltk.exe -t md -xls xxx.xlsx
指定sheet：
          exceltk.exe -t md -xls xx.xls -sheet sheetname   
          exceltk.exe -t md -xls xx.xlsx -sheet sheetnameexceltk</code></pre><h2 id="5-在线Markdown表格生成"><a href="#5-在线Markdown表格生成" class="headerlink" title="5. 在线Markdown表格生成"></a>5. 在线Markdown表格生成</h2><p>​      <a href="https://tableconvert.com/" target="_blank" rel="noopener">tableconvert</a>可以在线制作表格，并将其转为Markdown，CSV，Excel，XML，HTML等格式。</p>
<hr>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python字符串过滤仅保留数字</title>
    <url>/2020/07/25/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4%E4%BB%85%E4%BF%9D%E7%95%99%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-内置-filter-函数"><a href="#1-内置-filter-函数" class="headerlink" title="1. 内置 filter() 函数"></a>1. 内置 filter() 函数</h2><p><code>filter(function, iterable)</code>函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表，<font face="黑体" color=green > <strong>注意:</strong> Pyhton2.7 返回列表，Python3.x 返回迭代器对象</font>。</p>
<a id="more"></a>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 过滤出列表中的所有奇数：</span></span><br><span class="line">newlist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># 过滤出1~100中平方根是整数的数：</span></span><br><span class="line">newlist = filter(is_sqr, range(<span class="number">1</span>, <span class="number">101</span>))</span><br><span class="line"><span class="comment"># 字符串过滤仅保留数字和字母</span></span><br><span class="line">string = <span class="string">'abc5fg67.!aa99'</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isdigit,string))) <span class="comment">#只保留数字</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isalpha,string))) <span class="comment">#只保留字母</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isalnum,string))) <span class="comment">#保留数字和字母</span></span><br><span class="line"><span class="comment"># 如果想保留数字0-9和小数点’.’ 则需要自定义函数</span></span><br><span class="line"><span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> ch: ch <span class="keyword">in</span> <span class="string">'1234567890.'</span>, string)))</span><br></pre></td></tr></table></figure>

<h2 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h2><p>python自带<code>re</code> 模块，使 Python 语言拥有全部的正则表达式功能。</p>
<p>从字符串中提取数字，一般形式如：—.–，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">string=<span class="string">"A1.45，b5，6.45，8.82"</span></span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"\d+.?\d*"</span>,string)</span><br><span class="line"><span class="comment"># \d+匹配1次或者多次数字</span></span><br><span class="line"><span class="comment"># \.?匹配小数点，可能有或者没有</span></span><br><span class="line"><span class="comment"># \d* 匹配小数点之后的数字，零到任意。</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><p><a href="https://blog.csdn.net/huoyuanshen/article/details/83106608" target="_blank" rel="noopener">https://blog.csdn.net/huoyuanshen/article/details/83106608</a></p>
</li>
<li><p><a href="https://www.runoob.com/python/python-func-filter.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-filter.html</a></p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
        <tag>正则表达式</tag>
        <tag>re</tag>
        <tag>filter()</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之字体颜色以及背景色</title>
    <url>/2020/07/26/Markdown%E4%B9%8B%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E8%89%B2/</url>
    <content><![CDATA[<h2 id="字体，大小和颜色"><a href="#字体，大小和颜色" class="headerlink" title="字体，大小和颜色"></a>字体，大小和颜色</h2><a id="more"></a>

<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span></span>我是黑体字<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span></span>我是微软雅黑<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span></span>我是华文彩云<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span></span>我是红色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#008000</span>&gt;</span></span>我是绿色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">Blue</span>&gt;</span></span>我是蓝色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>我是尺寸<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span> <span class="attr">color</span>=<span class="string">green</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>我是黑体，绿色，尺寸为5<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>效果如下： </p>
<p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color=red>我是红色</font><br><font color=#008000>我是绿色</font><br><font color=Blue>我是蓝色</font><br><font size=5>我是尺寸</font><br><font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font></p>
<h2 id="文字背景色"><a href="#文字背景色" class="headerlink" title="文字背景色"></a>文字背景色</h2><p>由于 Markdown中不支持 style 标签和 style 属性，所以这里只能是通过 table, tr, td 等表格标签的 bgcolor 属性来实现背景色，将一整行看作一个表格，更改单元格的背景色（bgcolor）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">blue</span>&gt;</span></span>颜色测试<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table><tr><td bgcolor=blue>颜色测试</td></tr></table>

<h2 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a>图片居中</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">right</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/timg.jfif"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"50%"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<div align=right><img src="image/timg.jfif" width="50%" height="50%"></div>

<hr>
<p>参考：<a href="https://blog.csdn.net/heimu24/article/details/81189700" target="_blank" rel="noopener">https://blog.csdn.net/heimu24/article/details/81189700</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习之Ajax,Selenium,Splash</title>
    <url>/2020/07/29/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8BAjax/</url>
    <content><![CDATA[<h2 id="异步数据加载"><a href="#异步数据加载" class="headerlink" title="异步数据加载"></a>异步数据加载</h2><p>向网站进行一次请求，一次只传部分数据。如：有些网页不需要点击下一页，其内容也可以源源不断地加载。</p>
<h2 id="Ajax数据爬取"><a href="#Ajax数据爬取" class="headerlink" title="Ajax数据爬取"></a>Ajax数据爬取</h2><a id="more"></a>

<h3 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h3><p>Ajax，全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML。它不是一门编程语言，而是利用 JavaScript （JavaScript 可以实现页面的各种交互功能）在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p>
<p>一般出现在页面底部有“加载更多”，这其实就是 JavaScript 向服务器发送了一个 Ajax 请求，然后获取新的微博数据，将其解析，并将其渲染在网页中。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>简单分为以下 3 步：</p>
<ul>
<li><p>发送请求：Ajax 有其特殊的请求类型，叫作 xhr（XMLHttpRequest）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();&#125; <span class="keyword">else</span> &#123;<span class="comment">//code for IE6, IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"/ajax/"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>

<p>新建了 XMLHttpRequest 对象，然后调用 onreadystatechange 属性设置了监听，然后调用 open() 和 send() 方法向某个链接（也就是服务器）发送了请求。</p>
<p>前面用 Python 实现请求发送之后，可以得到响应结果，但这里请求的发送变成 JavaScript 来完成。由于设置了监听，所以当服务器返回响应时，onreadystatechange 对应的方法便会被触发，然后在这个方法里面解析响应内容即可。</p>
</li>
<li><p>解析内容</p>
<p>得到响应之后，onreadystatechange 属性对应的方法便会被触发，此时利用 xmlhttp 的 responseText 属性便可取到响应内容。这类似于 Python 中利用 requests 向服务器发起请求，然后得到响应的过程。那么返回内容可能是 HTML，可能是 JSON，接下来只需要在方法中用 JavaScript 进一步处理即可。比如，如果是 JSON 的话，可以进行解析和转化。</p>
</li>
<li><p>渲染网页</p>
<p>JavaScript 有改变网页内容的能力，解析完响应内容之后，就可以调用 JavaScript 来针对解析完的内容对网页进行下一步处理了。比如，通过 document.getElementById().innerHTML 这样的操作，便可以对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这样的操作也被称作 DOM 操作，即对 Document 网页文档进行操作，如更改、删除等。</p>
<p><code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code> 便将 ID 为 myDiv 的节点内部的 HTML 代码更改为服务器返回的内容，这样 myDiv 元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p>
</li>
</ul>
<h2 id="动态渲染页面抓取"><a href="#动态渲染页面抓取" class="headerlink" title="动态渲染页面抓取"></a>动态渲染页面抓取</h2><p>JavaScript 动态渲染的页面不止 Ajax 这一种，并且淘宝这种页面，它即使是 Ajax 获取的数据，但是其 Ajax 接口含有很多加密参数，我们难以直接找出其规律，也很难直接分析 Ajax 来抓取。</p>
<p>为了解决这些问题，我们可以<strong>直接使用模拟浏览器运行的方式来实现</strong> ，这样就可以做到在浏览器中看到是什么样，抓取的源码就是什么样，也就是可见即可爬。这样我们就不用再去管网页内部的 JavaScript 用了什么算法渲染页面，不用管网页后台的 Ajax 接口到底有哪些参数。</p>
<h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p><a href="[http://www.selenium.org.cn/](http://www.selenium.org.cn/)">Selenium</a>是web自动化测试工具集，包括IDE、Grid、RC（selenium 1.0）、WebDriver（selenium 2.0）等。利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些 JavaScript 动态渲染的页面来说，此种抓取方式非常有效。</p>
<p> <a href="[https://blog.csdn.net/huilan_same/article/details/52615123](https://blog.csdn.net/huilan_same/article/details/52615123)">selenium自动化资源整理</a></p>
<p>[][<a href="https://selenium-python.readthedocs.io/][Selenium使用文档](https://selenium-python.readthedocs.io/)" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/][Selenium使用文档](https://selenium-python.readthedocs.io/)</a></p>
<h4 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h4><p>Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器。另外，也支持无界面浏览器 PhantomJS。初始化方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium.webdriver</span><br><span class="line"></span><br><span class="line">driver = selenium.webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.Safari()</span><br><span class="line"><span class="comment"># 浏览器对象的初始化并将其赋值为 browser 对象，接下来，可以调用 browser 对象，让其执行各个动作以模拟浏览器操作。</span></span><br><span class="line"><span class="comment"># 要下载浏览器相应的驱动，并将其放入PATH中。例如，FireFox需要下载geckodriver</span></span><br></pre></td></tr></table></figure>

<h4 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a>PhantomJS</h4><p>PhantomJS是一个无界面浏览器。抓取时，不会弹出窗口.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.PhantomJS()</span><br></pre></td></tr></table></figure>

<p>另外，它还支持命令行配置。比如，可以设置缓存和禁用图片加载的功能，进一步提高爬取效率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVICE_ARGS &#x3D; [&#39;--load-images&#x3D;false&#39;, &#39;--disk-cache&#x3D;true&#39;]</span><br><span class="line">browser &#x3D; webdriver.PhantomJS(service_args&#x3D;SERVICE_ARGS)</span><br></pre></td></tr></table></figure>

<ul>
<li>需要 “此电脑&gt;属性&gt;高级系统设置&gt;高级&gt;环境变量&gt;系统变量&gt;Path”里添加phantomjs.exe的解压路径</li>
<li>需要将指定参数executable_path=r’D:\software_apk\phantomjs-2.1.1-windows\bin\phantomjs.exe’否则会报错</li>
</ul>
<h4 id="Chrome-Headless-模式"><a href="#Chrome-Headless-模式" class="headerlink" title="Chrome Headless 模式"></a>Chrome Headless 模式</h4><p>从 Chrome 59 版本开始，已经开始支持 Headless 模式，也就是无界面模式，这样爬取的时候就不会弹出浏览器了。如果要使用此模式，请把 Chrome 升级到 59 版本及以上。启用 Headless 模式的方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>

<h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><p>用 get() 方法来请求网页，参数传入链接 URL 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(url)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。</p>
<p> Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。</p>
<h5 id="单个节点：-查找的目标在网页中只有一个"><a href="#单个节点：-查找的目标在网页中只有一个" class="headerlink" title="单个节点： 查找的目标在网页中只有一个"></a>单个节点： 查找的目标在网页中只有一个</h5><p>find_element_by_name() 是根据 name 值获取，find_element_by_id() 是根据 id 获取。另外，还有根据 XPath、CSS 选择器等获取的方式。</p>
<p>例如，从淘宝页面中提取搜索框这个节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)</span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">input_forth = browser.find_element(By.ID, <span class="string">'q'</span>)</span><br><span class="line">print(input_first, input_second, input_third, input_forth)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>

<h5 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h5><p>如果有多个节点，再用 find_element() 方法查找，就只能得到第一个节点了。如果要查找所有满足条件的节点，需要用 find_elements() 这样的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br></pre></td></tr></table></figure>

<p>结果为列表，每个节点都是WebElement类型。</p>
<p>其他获取多个节点的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br><span class="line">find_elements(By.CSS_SELECTOR, <span class="string">'.service-bd li'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h4><p>Selenium 可以驱动浏览器来执行一些操作。比较常见的用法有：输入文字时用 send_keys 方法，清空文字时用 clear 方法，点击按钮时用 click 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">input.clear()</span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>

<h4 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h4><p>有一些操作，它们<strong>没有特定的执行对象</strong> ，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是<strong>动作链</strong> 。</p>
<p>比如，实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>

<h4 id="执行-JavaScript"><a href="#执行-JavaScript" class="headerlink" title="执行 JavaScript"></a>执行 JavaScript</h4><p>Selenium API 并没有提供<strong>下拉进度条</strong> 等操作，但可以直接模拟运行 JavaScript，此时使用 execute_script() 方法即可实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h4><ul>
<li>通过 <code>page_source</code> 属性可以获取网页的源代码，也可以通过Selenium 提供的选择节点的方法，直接提取节点信息。</li>
</ul>
<ul>
<li>先通过查找节点，获取WebElement类型，再通过get_attribute() 方法，.text属性，.id属性，.location属性，.tag_name属性，.size属性，获取属性、文本、 ID、位置、标签名、大小</li>
</ul>
<h4 id="切换-Frame"><a href="#切换-Frame" class="headerlink" title="切换 Frame"></a>切换 Frame</h4><p>网页中有一种节点叫作 <strong>iframe</strong>，也就是<strong>子 Frame</strong>，相当于页面的<strong>子页面</strong>，它的结构和外部网页的结构完全一致。Selenium 打开页面后，它默认是在父级 Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。这时就需要使用 <code>switch_to.frame()</code> 方法来切换 Frame。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure>

<h4 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h4><p>get() 方法会在网页框架加载结束后结束执行，此时如果获取 page_source，可能并不是浏览器完全加载完成的页面，所以，这里需要延时等待一定时间，确保节点已经加载出来。</p>
<h5 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure>

<p>当使用隐式等待 (<code>implicitly_wait()</code>) 执行测试时，如果 Selenium 没有在 DOM 中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0。</p>
<h5 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h5><p>显式等待方法，指定要查找的节点，然后<strong>指定一个最长等待时间</strong>。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))</span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure>

<p>引入 WebDriverWait 对象，指定最长等待时间，调用其 until() 方法，传入要等待条件 expected_conditions。比如，传入 presence_of_element_located ，其参数是节点的定位元组( ID 为 q 的节点搜索框)。10 秒内如果 ID 为 q 的节点（即搜索框）成功加载出来，就返回该节点；否则，抛出异常。</p>
<p>按钮可以使用 element_to_be_clickable，( CSS 选择器为.btn-search 的按钮)，如果 10 秒内成功加载出来，即可点击，就返回该按钮节点；否则，抛出异常。</p>
<h6 id="其他等待条件"><a href="#其他等待条件" class="headerlink" title="其他等待条件"></a>其他等待条件</h6><p><a href="https://python3webspider.cuiqingcai.com/7.1selenium-de-shi-yong#xian-shi-deng-dai" target="_blank" rel="noopener">https://python3webspider.cuiqingcai.com/7.1selenium-de-shi-yong#xian-shi-deng-dai</a></p>
<h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><p>back() 和 forward() 方法 </p>
<h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>get_cookies() 方法获取所有的 Cookies，add_cookies() 添加删除， delete_all_cookies() 方法删除所有的 Cookies。</p>
<h4 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure>

<p>调用 execute_script() 方法，传入 window.open() 这个 JavaScript 语句新开启一个选项卡。</p>
<p>调用 window_handles 属性获取当前开启的所有选项卡，调用 switch_to_window() 方法切换到该选项卡。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>使用 try except 语句来捕获各种异常，都在selenium.common.exceptions下。</p>
<p>TimeoutException</p>
<p>NoSuchElementException</p>
<h3 id="Splash"><a href="#Splash" class="headerlink" title="Splash"></a>Splash</h3><p><a href="https://splash.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">Splash</a> 是一个 JavaScript 渲染服务，是一个带有 HTTP API 的轻量级浏览器，同时它对接了 Python 中的 Twisted 和 QT 库。</p>
<p>可以实现如下功能：</p>
<ul>
<li>异步方式处理多个网页渲染过程</li>
<li>获取渲染后的页面的源代码或截图</li>
<li>通过关闭图片渲染或者使用 Adblock 规则来加快页面渲染速度</li>
<li>可执行特定的 JavaScript 脚本</li>
<li>可通过 Lua 脚本来控制页面渲染过程</li>
<li>获取渲染的详细过程并通过 HAR（HTTP Archive）格式呈现</li>
</ul>
<p><a href="https://www.jianshu.com/p/feeb15f2e49b" target="_blank" rel="noopener">win10家庭版docker安装</a></p>
<ul>
<li>遇到问题，安装过程中将git bash卸载了。</li>
</ul>
<p><a href="https://www.cnblogs.com/samwu/p/10360943.html" target="_blank" rel="noopener">win10家庭版安装docker</a></p>
<ul>
<li>遇到问题，docker desk 无法启动，out of memory。。。</li>
</ul>
<p><a href="https://blog.csdn.net/pp_lan/article/details/90692510" target="_blank" rel="noopener">https://blog.csdn.net/pp_lan/article/details/90692510</a></p>
<h4 id="Splash-Lua-脚本"><a href="#Splash-Lua-脚本" class="headerlink" title="Splash Lua 脚本"></a>Splash Lua 脚本</h4><p>Splash 可以通过 Lua 脚本执行一系列渲染操作，这样我们就可以用 Splash 来模拟类似 Chrome、PhantomJS 的操作了。</p>
<h5 id="入口及返回值"><a href="#入口及返回值" class="headerlink" title="入口及返回值"></a>入口及返回值</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">  splash:wait(<span class="number">0.5</span>)</span><br><span class="line">  <span class="keyword">local</span> title = splash:evaljs(<span class="string">"document.title"</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;title=title&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Splash 会默认调用main 方法。</li>
<li>返回值可以是字典形式，也可以是字符串形式，最后都会转化为 Splash HTTP Response。</li>
</ul>
<h5 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="keyword">local</span> example_urls = &#123;<span class="string">"www.baidu.com"</span>, <span class="string">"www.taobao.com"</span>, <span class="string">"www.zhihu.com"</span>&#125;</span><br><span class="line">  <span class="keyword">local</span> urls = args.urls <span class="keyword">or</span> example_urls</span><br><span class="line">  <span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">ipairs</span>(urls) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> ok, reason = splash:go(<span class="string">"http://"</span> .. url)</span><br><span class="line">    <span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">      splash:wait(<span class="number">2</span>)</span><br><span class="line">      results[url] = splash:png()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>运行后的返回结果是 3 个站点的截图</p>
<ul>
<li>字符串拼接操作符<code>..</code>，而不是python中的<code>+</code></li>
<li>go 方法会返回加载页面的结果状态，如果页面出现 4xx 或 5xx 状态码，ok 变量就为空，就不会返回加载后的图片。</li>
</ul>
<h4 id="Splash-对象属性"><a href="#Splash-对象属性" class="headerlink" title="Splash 对象属性"></a>Splash 对象属性</h4><p>splash类似于 Selenium 中的 WebDriver 对象。</p>
<h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><h5 id="js-enabled"><a href="#js-enabled" class="headerlink" title="js_enabled"></a>js_enabled</h5><p>这个属性是 Splash 的 JavaScript 执行开关，可以将其配置为 true 或 false 来控制是否执行 JavaScript 代码，默认为 true。</p>
<h5 id="resource-timeout"><a href="#resource-timeout" class="headerlink" title="resource_timeout"></a>resource_timeout</h5><p>设置加载的超时时间，单位是秒。如果设置为 0 或 nil（类似 Python 中的 None），代表不检测超时。</p>
<h5 id="images-enabled"><a href="#images-enabled" class="headerlink" title="images_enabled"></a>images_enabled</h5><p>设置图片是否加载，默认情况下是加载的。禁用该属性后，可以节省网络流量并提高网页加载速度。</p>
<ul>
<li>禁用图片加载可能会影响 JavaScript 渲染。因为禁用图片之后，它的外层 DOM 节点的高度会受影响，进而影响 DOM 节点的位置。因此，如果 JavaScript 对图片节点有操作的话，其执行就会受到影响。</li>
<li>Splash 使用了缓存。如果一开始加载出来了网页图片，然后禁用了图片加载，再重新加载页面，之前加载好的图片可能还会显示出来，这时直接重启 Splash 即可。</li>
</ul>
<h5 id="plugins-enabled"><a href="#plugins-enabled" class="headerlink" title="plugins_enabled"></a>plugins_enabled</h5><p>控制浏览器插件（如 Flash 插件）是否开启。默认情况下，此属性是 false。</p>
<h5 id="scroll-position"><a href="#scroll-position" class="headerlink" title="scroll_position"></a>scroll_position</h5><p>控制页面上下或左右滚动</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash.scroll_position = &#123;y=<span class="number">400</span>&#125;</span><br><span class="line">splash.scroll_position = &#123;x=<span class="number">100</span>, y=<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Splash-对象方法"><a href="#Splash-对象方法" class="headerlink" title="Splash 对象方法"></a>Splash 对象方法</h4><h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>该方法用来请求某个链接，而且它可以模拟 GET 和 POST 请求，同时支持传入请求头、表单等数据，其用法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:go&#123;url, baseurl=<span class="literal">nil</span>, headers=<span class="literal">nil</span>, http_method=<span class="string">"GET"</span>, body=<span class="literal">nil</span>, formdata=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>

<p>返回值为ok和reason，如果 ok 为空，代表网页加载出现了错误，此时 reason 变量中包含了错误的原因，否则证明页面加载成功。</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p>控制页面等待时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:wait&#123;time, cancel_on_redirect=false, cancel_on_error=true&#125;</span><br></pre></td></tr></table></figure>

<h5 id="jsfunc"><a href="#jsfunc" class="headerlink" title="jsfunc"></a>jsfunc</h5><p>直接调用 JavaScript 定义的方法，但是所调用的方法需要用双中括号包围，这相当于实现了 JavaScript 方法到 Lua 脚本的转换。</p>
<p>首先，声明了 JavaScript 定义的方法，然后在页面加载成功后调用了此方法计算出了页面中 div 节点的个数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="keyword">local</span> get_div_count = splash:jsfunc(<span class="string">[[function () &#123;</span></span><br><span class="line"><span class="string">    var body = document.body;</span></span><br><span class="line"><span class="string">    var divs = body.getElementsByTagName('div');</span></span><br><span class="line"><span class="string">    return divs.length;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  ]]</span>)</span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">"There are % s DIVs"</span>):<span class="built_in">format</span>(get_div_count())</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="evaljs"><a href="#evaljs" class="headerlink" title="evaljs"></a>evaljs</h5><p>执行 JavaScript 代码并返回最后一条 JavaScript 语句的返回结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">result = splash:evaljs(js)</span><br></pre></td></tr></table></figure>

<h5 id="runjs"><a href="#runjs" class="headerlink" title="runjs"></a>runjs</h5><p>执行 JavaScript 代码，它与 evaljs 方法的功能类似，但是更偏向于<strong>执行某些动作</strong>或<strong>声明某些方法</strong>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  splash:runjs(<span class="string">"foo = function() &#123;return 'bar'&#125;"</span>)</span><br><span class="line">  <span class="keyword">local</span> result = splash:evaljs(<span class="string">"foo()"</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>用 runjs 方法先声明了一个 JavaScript 定义的方法，然后通过 evaljs 方法来调用得到的结果。</p>
<h5 id="autoload"><a href="#autoload" class="headerlink" title="autoload"></a>autoload</h5><p>设置每个页面访问时自动加载的对象。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:autoload&#123;source_or_url, source=<span class="literal">nil</span>, url=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法只负责加载 JavaScript 代码或库，不执行任何操作。如果要执行操作，可以调用 evaljs 或 runjs 方法。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:autoload(<span class="string">[[function get_document_title()&#123;return document.title;&#125;</span></span><br><span class="line"><span class="string">  ]]</span>)</span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:evaljs(<span class="string">"get_document_title()"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<ul>
<li>使用 autoload 方法加载某些方法库，如 jQuery，</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="built_in">assert</span>(splash:autoload(<span class="string">"https://code.jquery.com/jquery-2.1.3.min.js"</span>))</span><br><span class="line">  <span class="built_in">assert</span>(splash:go(<span class="string">"https://www.taobao.com"</span>))</span><br><span class="line">  <span class="keyword">local</span> version = splash:evaljs(<span class="string">"$.fn.jquery"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'JQuery version: '</span> .. version</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="call-later"><a href="#call-later" class="headerlink" title="call_later"></a>call_later</h5><p>设置定时任务和延迟时间来实现任务延时执行，并且可以在执行前通过 cancel 方法重新执行定时任务。</p>
<h5 id="htttp-get"><a href="#htttp-get" class="headerlink" title="htttp_get"></a>htttp_get</h5><p>拟发送 HTTP 的 GET 请求</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">response = splash:http_get&#123;url, headers=<span class="literal">nil</span>, follow_redirects=<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="http-post"><a href="#http-post" class="headerlink" title="http_post"></a>http_post</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">response = splash:http_post&#123;url, headers=<span class="literal">nil</span>, follow_redirects=<span class="literal">true</span>, body=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>body，可选参数，默认为空，即表单数据。</li>
</ul>
<h5 id="set-content"><a href="#set-content" class="headerlink" title="set_content"></a>set_content</h5><p>用来设置页面的内容</p>
<h5 id="html"><a href="#html" class="headerlink" title="html"></a>html</h5><p>用来获取网页的源代码</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://httpbin.org/get"</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:html()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h5 id="png"><a href="#png" class="headerlink" title="png"></a>png</h5><p>获取 PNG 格式的网页截图</p>
<h5 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h5><p>用来获取 JPEG 格式的网页截图</p>
<h5 id="har"><a href="#har" class="headerlink" title="har"></a>har</h5><p>用来获取页面加载过程描述</p>
<h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><p>获取当前正在访问的 URL</p>
<h5 id="get-cokies"><a href="#get-cokies" class="headerlink" title="get_cokies"></a>get_cokies</h5><p>获取当前页面的 Cookies</p>
<h5 id="add-cokies"><a href="#add-cokies" class="headerlink" title="add_cokies"></a>add_cokies</h5><p>为当前页面添加 Cookies</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">cookies = splash:add_cookie&#123;name, value, <span class="built_in">path</span>=<span class="literal">nil</span>, domain=<span class="literal">nil</span>, expires=<span class="literal">nil</span>, httpOnly=<span class="literal">nil</span>, secure=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>

<h5 id="clear-cookies"><a href="#clear-cookies" class="headerlink" title="clear_cookies"></a>clear_cookies</h5><p>清除所有的 Cookies</p>
<h5 id="get-viewport-size"><a href="#get-viewport-size" class="headerlink" title="get_viewport_size"></a>get_viewport_size</h5><p>获取当前浏览器页面的大小，即宽高</p>
<h5 id="set-viewport-size"><a href="#set-viewport-size" class="headerlink" title="set_viewport_size"></a>set_viewport_size</h5><p>设置当前浏览器页面的大小，即宽高</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_viewport_size(width, height)</span><br></pre></td></tr></table></figure>

<h5 id="set-viewport-full"><a href="#set-viewport-full" class="headerlink" title="set_viewport_full"></a>set_viewport_full</h5><p>此方法可以设置浏览器全屏显示</p>
<h5 id="set-user-agent"><a href="#set-user-agent" class="headerlink" title="set_user_agent"></a>set_user_agent</h5><p>此方法可以设置浏览器的 User-Agent</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_user_agent(<span class="string">'Splash'</span>)</span><br></pre></td></tr></table></figure>

<h5 id="set-custom-headers"><a href="#set-custom-headers" class="headerlink" title="set_custom_headers()"></a>set_custom_headers()</h5><p>此方法可以设置请求的 Headers</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_custom_headers(&#123;[<span class="string">"User-Agent"</span>] = <span class="string">"Splash"</span>,</span><br><span class="line">     [<span class="string">"Site"</span>] = <span class="string">"Splash"</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>可以选中符合条件的第一个节点，如果有多个节点符合条件，则只会返回一个，其参数是 CSS 选择器。</p>
<h5 id="select-all"><a href="#select-all" class="headerlink" title="select_all()"></a>select_all()</h5><p>此方法可以选中所有的符合条件的节点，其参数是 CSS 选择器。</p>
<h5 id="mouse-click"><a href="#mouse-click" class="headerlink" title="mouse_click"></a>mouse_click</h5><p>此方法可以模拟鼠标点击操作，传入的参数为坐标值 x、y，也可以直接选中某个节点直接调用此方法。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">  <span class="built_in">input</span> = splash:<span class="built_in">select</span>(<span class="string">"#kw"</span>)</span><br><span class="line">  <span class="built_in">input</span>:send_text(<span class="string">'Splash'</span>)</span><br><span class="line">  submit = splash:<span class="built_in">select</span>(<span class="string">'#su'</span>)</span><br><span class="line">  submit:mouse_click()</span><br><span class="line">  splash:wait(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:png()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<h4 id="Splash-API-调用"><a href="#Splash-API-调用" class="headerlink" title="Splash API 调用"></a>Splash API 调用</h4><p>上述Splash Lua 脚本的用法，是在 Splash 页面里面测试运行的。</p>
<p>Splash 提供了一些 HTTP API 接口，请求这些接口并传递相应的参数即可获取页面渲染后的结果。</p>
<h5 id="render-html"><a href="#render-html" class="headerlink" title="render.html"></a>render.html</h5><p>用于获取 JavaScript 渲染的页面的 HTML 代码，接口地址就是 Splash 的运行地址加此接口名称</p>
<p><code>url = &#39;http://localhost:8050/render.html?url=https://www.baidu.com&#39;</code></p>
<p><code>url = &#39;http://localhost:8050/render.html?url=https://www.taobao.com&amp;amp;wait=5&#39;</code></p>
<h5 id="render-png"><a href="#render-png" class="headerlink" title="render.png"></a>render.png</h5><p>此接口可以获取网页截图,返回的是 PNG 格式的图片二进制数据</p>
<p><code>&#39;http://localhost:8050/render.png?url=https://www.jd.com&amp;wait=5&amp;width=1000&amp;height=700&#39;</code></p>
<h5 id="render-jpeg"><a href="#render-jpeg" class="headerlink" title="render.jpeg"></a>render.jpeg</h5><p>和 render.png 类似，返回的是 JPEG 格式的图片二进制数据。</p>
<p>另外此接口相比 render.png 还多了一个参数 quality，可以用来设置图片质量。</p>
<h5 id="render-har"><a href="#render-har" class="headerlink" title="render.har"></a>render.har</h5><p>此接口用于获取页面加载的 HAR 数据</p>
<p><code>http://localhost:8050/render.har?url=https://www.jd.com&amp;wait=5</code></p>
<h5 id="render-json"><a href="#render-json" class="headerlink" title="render.json"></a>render.json</h5><p>此接口包含了前面接口的所有功能，返回结果是 Json 格式</p>
<p><code>http://localhost:8050/render.json?url=https://httpbin.org&amp;html=1&amp;har=1</code></p>
<p>可以通过传入不同参数控制其返回结果。比如，传入 html=1，返回结果即会增加源代码数据；传入 png=1，返回结果即会增加页面 PNG 截图数据；传入 har=1，则会获得页面 HAR 数据。</p>
<h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>用此接口便可实现与 Lua 脚本的对接。实现一些交互操作。</p>
<p>将lua脚本转化为 URL 编码后的字符串，拼接到 execute 接口后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">lua = <span class="string">'''</span></span><br><span class="line"><span class="string">function main(splash)</span></span><br><span class="line"><span class="string">    return 'hello'</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://localhost:8050/execute?lua_source='</span> + quote(lua)</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Selenium</tag>
        <tag>Slash</tag>
      </tags>
  </entry>
  <entry>
    <title>python之字符串和列表之间的转换</title>
    <url>/2020/07/28/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%97%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="str-to-list"><a href="#str-to-list" class="headerlink" title="str to list"></a>str to list</h2><a id="more"></a>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"12345"</span></span><br><span class="line">list1 = list(str1)</span><br><span class="line">print(list1)  <span class="comment"># ['1', '2', '3', '4', '5']</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">"123 sjhid dhi"</span></span><br><span class="line">list2 = str2.split() <span class="comment">#or list2 = str2.split(" ")</span></span><br><span class="line">print(list2)   <span class="comment"># ['123', 'sjhid', 'dhi']</span></span><br><span class="line"> </span><br><span class="line">str3 = <span class="string">"www.google.com"</span></span><br><span class="line">list3 = str3.split(<span class="string">"."</span>)</span><br><span class="line">print(list3)   <span class="comment"># ['www', 'google', 'com']</span></span><br></pre></td></tr></table></figure>

<h2 id="list-to-str"><a href="#list-to-str" class="headerlink" title="list to str"></a>list to str</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str4 = <span class="string">""</span>.join(list3)</span><br><span class="line">print(str4)    <span class="comment"># wwwgooglecom</span></span><br><span class="line">str5 = <span class="string">"."</span>.join(list3)  <span class="comment"># www.google.com</span></span><br><span class="line">print(str5)</span><br><span class="line">str6 = <span class="string">" "</span>.join(list3)   <span class="comment"># www google com</span></span><br><span class="line"><span class="keyword">print</span> (str6)</span><br></pre></td></tr></table></figure>

<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/roytao2/article/details/53433373" target="_blank" rel="noopener">https://blog.csdn.net/roytao2/article/details/53433373</a></p>
<p><a href="https://www.jb51.net/article/107092.htm" target="_blank" rel="noopener">https://www.jb51.net/article/107092.htm</a></p>
<div style='display: none'>

<p>尝试爬取博客页面</p>
</div>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python爬虫学习</title>
    <url>/2020/07/24/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%BA%93%E5%92%8C%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><h3 id="1-anaconda安装"><a href="#1-anaconda安装" class="headerlink" title="1. anaconda安装"></a>1. anaconda安装</h3><ol>
<li><p>配置环境，将python写入环境变量。</p>
<a id="more"></a>

</li>
</ol>
<h3 id="2-IDE：-pycharm安装"><a href="#2-IDE：-pycharm安装" class="headerlink" title="2. IDE： pycharm安装"></a>2. IDE： pycharm安装</h3><ol>
<li>使用虚拟环境（virtual environment）</li>
<li>settings 安装python包，可以直接从anaconda中把安装包直接拷到Lib-site_package下，如果网速限制，可以替换镜像源。</li>
</ol>
<h2 id="2-urllib"><a href="#2-urllib" class="headerlink" title="2. urllib"></a>2. urllib</h2><p><code>urllib</code> 是Python 内置的 HTTP 请求库，包含如4 个模块：<code>request</code>, <code>error</code>, <code>parse</code>, <code>robotparser</code></p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>该模块可以发送请求并得到响应。</p>
<ol>
<li><p><code>urlopen</code></p>
<p>其结果返回一个 HTTPResposne 类型的对象，主要包含 <code>read、getheader、getheaders</code>等方法，以及 <code>msg、version、status、reason</code>等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">data = response.read().decode()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<blockquote>
<p><code>response.status</code> 1**：信息状态，2**：成功状态，请求成功为200 ，3**：重定向，4**：客户端错误，400代表解析失败，404 代表网页未找到。</p>
<p><code>response.getheaders()</code> 得到headers</p>
</blockquote>
<ol start="2">
<li><p><code>Request</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)  </span><br><span class="line">response = request.urlopen(req)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>build_opener</code> 和 <code>Handler</code> 可以实现代理，密码登录等复杂请求，例子可<a href="https://python3webspider.cuiqingcai.com/3.1-shi-yong-urllib#2-request" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>该模块定义了由 request 模块产生的异常。</p>
<ol>
<li><p><code>URLError</code> 有一个属性<code>reason</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="number">404</span>_url)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    print(e.reason)  <span class="comment">#  Not Found （对应403）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HTTPError</code> 专门处理HTTP请求的错误，具有<code>code</code>, <code>reason</code>, <code>headers</code> 三个属性</p>
</li>
</ol>
<h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>该模块定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。</p>
<ol>
<li><p><code>quote</code> 将内容转化为 URL 编码的格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">"小说"</span></span><br><span class="line">key_ASCII = quote(key)</span><br><span class="line">print(key_ASCII)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unquote</code> 将 URL 格式内容解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">"%E5%B0%8F%E8%AF%B4"</span></span><br><span class="line">print(unqoute(key))</span><br></pre></td></tr></table></figure>

<p><strong><code>request</code> 中也有qoute</strong></p>
</li>
</ol>
<h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>该模块可以实现网站 Robots 协议的分析。</p>
<p>requests是用于爬取网页源码的一个库。</p>
<h2 id="3-requests"><a href="#3-requests" class="headerlink" title="3. requests"></a>3. requests</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get</code> 方法以 GET 方式请求网页，返回得到一个 Response 对象，有<code>status_code，text，cookies</code> 等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response=requests.get(url) </span><br><span class="line">data=response.text</span><br><span class="line">file_path = <span class="string">r"E:\pycharm\test.html"</span>  <span class="comment"># 'r'是防止字符转义,否则\需要变成/</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(data)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>因为Windows操作系统默认字符编码为GBK，而Python默认Unicode.utf-8，如果不写“encoding=‘utf-8’ ”就会报错。</p>
<p>对于二进制数据，可以使用<code>content</code> 属性，可以直接写入文件，直接获得图片，音频，视屏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: <span class="comment"># wb 以二进制方式写入</span></span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></table></figure>

<p>有些网站禁止抓取，如B站，可以使用headers包含 User-Agent 字段信息，也就是浏览器标识信息。<a href="https://www.jianshu.com/p/da6a44d0791e" target="_blank" rel="noopener" title="User-agent大全">User-agent大全</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urllib.error.HTTPError: HTTP Error 403: Forbidden</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">data = response.read().decode() </span><br><span class="line"><span class="comment"># 没有问题</span></span><br><span class="line">response=requests.get(url) </span><br><span class="line">data=response.text</span><br></pre></td></tr></table></figure>

<p>在设置 Headers 使用Cookie来维持登录状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="string">'cookie_content'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外，<code>request</code>还有<code>put, post, delete, options</code> 等方法实现 POST、PUT、DELETE、OPTIONS 等请求。</p>
<h3 id="session会话维持"><a href="#session会话维持" class="headerlink" title="session会话维持"></a>session会话维持</h3><p>通过用 get 方法登录某个网站，用 get 方法第二次去请求个人信息页面，并不能成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text) <span class="comment"># cookies 是空字典</span></span><br></pre></td></tr></table></figure>

<p>如何设置一次cookies，维持对话，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>

<h2 id="4-使用Selenium调用浏览器"><a href="#4-使用Selenium调用浏览器" class="headerlink" title="4. 使用Selenium调用浏览器"></a>4. 使用Selenium调用浏览器</h2><p><a href="[http://www.selenium.org.cn/](http://www.selenium.org.cn/)">Selenium</a>是web自动化测试工具集，包括IDE、Grid、RC（selenium 1.0）、WebDriver（selenium 2.0）等。</p>
<p> <a href="[https://blog.csdn.net/huilan_same/article/details/52615123](https://blog.csdn.net/huilan_same/article/details/52615123)">selenium自动化资源整理</a></p>
<h3 id="1-调用Chrome浏览器"><a href="#1-调用Chrome浏览器" class="headerlink" title="1. 调用Chrome浏览器"></a>1. 调用Chrome浏览器</h3><ol>
<li><p>查看本地Chrome版本</p>
</li>
<li><p>下载<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">Chromedriver</a></p>
</li>
<li><p>将chromedriver.exe放到python path下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium.webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line"></span><br><span class="line">driver = selenium.webdriver.Chrome()</span><br><span class="line">driver.get(url)</span><br><span class="line">data = driver.page_source</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">r"E:\pycharm-爬虫\bilibili\首页_selenium.html"</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="2-调用FireFox浏览器"><a href="#2-调用FireFox浏览器" class="headerlink" title="2. 调用FireFox浏览器"></a>2. 调用FireFox浏览器</h3><ol>
<li>下载<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">geckodriver</a>，并将其放入PATH中。</li>
<li>driver = selenium.webdriver.Firefox()</li>
</ol>
<h2 id="5-bs4-BeautifulSoup解析HTML"><a href="#5-bs4-BeautifulSoup解析HTML" class="headerlink" title="5. bs4.BeautifulSoup解析HTML"></a>5. bs4.BeautifulSoup解析HTML</h2><p>bs4即<a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">BeautifulSoup4</a> ，是一个可以从HTML或XML文件中提取数据的Python库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">data = <span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span></span><br><span class="line">soup = BeautifulSoup(data, <span class="string">"html.parser"</span>) <span class="comment"># data为html格式的数据</span></span><br></pre></td></tr></table></figure>

<p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code>, <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> 。</p>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p><code>tag</code> 的属性有<code>name</code> 和 <code>attributes</code>，方法<code>get()</code> , 如果不确定某个属性是否存在时,用 <code>tag.get(&#39;attr&#39;)</code> 方法去获取它,跟获取Python字典的key一样&gt;</p>
<p>一个<code>tag</code> 可能有很多属性，属性的操作与<strong>字典</strong>相同，可以被添加，删除或修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag = soup.b <span class="comment"># tag b</span></span><br><span class="line">tag.name  <span class="comment"># 'b'</span></span><br><span class="line">tag.name = <span class="string">"blockquote"</span> <span class="comment"># tag &lt;blockquote class="boldest"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">tag[<span class="string">'class'</span>] <span class="comment"># boldest</span></span><br><span class="line">tag.attrs <span class="comment"># &#123;'class': 'boldest'&#125;</span></span><br><span class="line">tag[<span class="string">'class'</span>] = <span class="string">'verybold'</span> <span class="comment"># 修改 &lt;blockquote class="verybold" &gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line">tag[<span class="string">'id'</span>] = <span class="number">1</span>   <span class="comment"># 添加 &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'class'</span>] <span class="comment"># &lt;blockquote id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'id'</span>]    <span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>HTML5</code> 中定义了一系列可以包含多个值的属性，<code>class</code> (一个tag可以有多个CSS的class). <code>rel</code>  <code>rev</code> ， <code>accept-charset</code> ， <code>headers</code> ， <code>accesskey</code> 等。</p>
<p>多值属性的返回值为list， 非多值属性的返回值为字符串：</p>
<p><strong>注意：XML格式的tag不包含多值属性。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多值属性class</span></span><br><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body", "strikeout"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非多值属性id</span></span><br><span class="line">id_soup = BeautifulSoup(<span class="string">'&lt;p id="my id"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">id_soup.p[<span class="string">'id'</span>]</span><br><span class="line"><span class="comment"># 'my id'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多值属性修改时</span></span><br><span class="line">rel_soup = BeautifulSoup(<span class="string">'&lt;p&gt;Back to the &lt;a rel="index"&gt;homepage&lt;/a&gt;&lt;/p&gt;'</span>)</span><br><span class="line">rel_soup.a[<span class="string">'rel'</span>] = [<span class="string">'index'</span>, <span class="string">'contents'</span>]</span><br><span class="line">print(rel_soup.p)</span><br><span class="line"><span class="comment"># &lt;p&gt;Back to the &lt;a rel="index contents"&gt;homepage&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h3><p>字符串常被包含在<code>tag</code> 内。Beautiful Soup用<code>NavigableString</code>类来包装tag中的字符串: <code>tag.string</code></p>
<p>tag中包含的字符串不能编辑,但是可以用 <code>replace_with()</code> 方法替换成其它的字符串</p>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p><code>BeautifulSoup</code> 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 <code>Tag</code> 对象，它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法。</p>
<h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>处理HTML和XML中的注释部分，<code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，但是当它出现在HTML文档中时, <code>Comment</code> 对象会使用特殊的格式输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markup = <span class="string">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">comment = soup.b.string</span><br><span class="line">type(comment)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.Comment'&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h3><p>一个<code>tag</code> 可能包含多个字符串或其他<code>tag</code> ，这些都是该<code>tag</code> 的子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 点取属性的方式只能获得当前名字的第一个tag</span></span><br><span class="line">soup.head</span><br><span class="line">soup.body.b</span><br><span class="line"><span class="comment"># 想要得到所有的&lt;a&gt;标签</span></span><br><span class="line">soup.find_all(<span class="string">'a'</span>) <span class="comment"># 返回list</span></span><br></pre></td></tr></table></figure>

<h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><h5 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h5><p><code>tag</code> 的 <code>.contents</code> 属性可以将<code>tag</code> 的子节点以列表的方式输出:</p>
<p>通过<code>tag</code> 的 <code>.children</code> 生成器,可以对<code>tag</code> 的子节点进行循环:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head_tag = soup.head  <span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line">title_tag = head_tag.contents[<span class="number">0</span>]  <span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">title_tag.contents    <span class="comment"># [u'The Dormouse's story']</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> title_tag.children:</span><br><span class="line">    print(child)      <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure>

<h5 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h5><p><code>.contents</code> 和 <code>.children</code> 属性仅包含tag的直接子节点.例如,<head>标签只有一个直接子节点<code>&lt;title&gt;</code> 但<code>&lt;title&gt;</code> 标签也包含一个子节点:字符串 “The Dormouse’s story”，这种情况下字符串 “The Dormouse’s story”也属于<code>&lt;head&gt;</code> 标签的子孙节点. <code>.descendants</code> 属性可以对所有tag的子孙节点进行递归循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> head_tag.descendants:</span><br><span class="line">    print(child)</span><br><span class="line">    <span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">    <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure>

<h5 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h5><p>如果<code>tag</code> 只有一个 <code>NavigableString</code> 类型子节点,那么这个<code>tag</code> 可以使用 <code>.string</code> 得到子节点</p>
<p>否则，<code>.string</code> 的输出结果是 <code>None</code></p>
<p>输出的字符串中可能包含了很多空格或空行,使用 <code>.stripped_strings</code> 可以去除多余空白内容</p>
<h6 id="bs4-element-get-text"><a href="#bs4-element-get-text" class="headerlink" title="bs4.element.get_text()"></a>bs4.element.get_text()</h6><p> Get all child strings, concatenated using the given separator (默认是空格)</p>
<h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><h5 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h5><h5 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h5><p>通过元素的 <code>.parents</code> 属性可以递归得到元素的所有父辈节点</p>
<h5 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h5><p>同一个元素的子节点</p>
<h5 id="next-sibling-和-previous-sibling"><a href="#next-sibling-和-previous-sibling" class="headerlink" title=".next_sibling 和 .previous_sibling"></a>.next_sibling 和 .previous_sibling</h5><p>在文档树中,使用 <code>.next_sibling</code> 和 <code>.previous_sibling</code> 属性来查询兄弟节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sibling_soup = BeautifulSoup(<span class="string">"&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;"</span>)</span><br><span class="line">sibling_soup.b.next_sibling  <span class="comment"># &lt;c&gt;text2&lt;/c&gt;</span></span><br><span class="line">sibling_soup.c.previous_sibling <span class="comment"># &lt;b&gt;text1&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="next-siblings-和-previous-siblings"><a href="#next-siblings-和-previous-siblings" class="headerlink" title=".next_siblings 和 .previous_siblings"></a>.next_siblings 和 .previous_siblings</h5><p>对当前节点的兄弟节点迭代输出</p>
<h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><p><code>Beautiful Soup</code> 中定义的搜索方法，比如 <code>find()</code> 和 <code>find_all()</code></p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>find_all()</p>
<p>可以是字符串，正则表达式，列表，True，方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">'b'</span>) <span class="comment"># b 标签</span></span><br><span class="line">soup.find_all(re.compile(<span class="string">"^b"</span>)) <span class="comment"># 以b开头的标签</span></span><br><span class="line">soup.find_all([<span class="string">"a"</span>, <span class="string">"b"</span>]) <span class="comment"># 含有a或b的标签</span></span><br><span class="line">soup.find_all(<span class="literal">True</span>) <span class="comment"># True 可以匹配任何值,找到所有的tag,但是不会返回字符串节点</span></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_class_but_no_id</span><span class="params">(tag)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">'id'</span>) <span class="comment"># 有class，无id</span></span><br><span class="line">soup.find_all(has_class_but_no_id)</span><br></pre></td></tr></table></figure>

<h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all())"></a>find_all())</h4><p><code>find_all(name, attrs, recursive , text , **kwargs)</code></p>
<ol>
<li><p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字<code>tag</code> 的属性来搜索<code>soup.find_all(id=&#39;link2&#39;)</code> </p>
</li>
<li><p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性,但是可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的tag: <code>data_soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})</code></p>
</li>
<li><p>按照CSS类名搜索<code>tag</code> , 但标识CSS类名的关键字 <code>class</code> 在Python中是保留字,使用 <code>class</code> 做参数会导致语法错误.从<code>Beautiful Soup</code> 的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的<code>tag</code> : <code>soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)</code></p>
</li>
<li><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容</p>
</li>
<li><p><code>find_all()</code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果不需要全部结果,可以使用 <code>limit</code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code>limit</code> 的限制时,就停止搜索返回结果.  <code>soup.find_all(&quot;a&quot;, limit=2)</code></p>
</li>
<li><p>recursive 默认为True，检索当前tag的所有子孙节点，<code>soup.html.find_all(&quot;title&quot;, recursive=False)</code> 搜索<code>tag</code> 的直接子节点</p>
</li>
<li><pre><code class="python"><span class="comment"># 这两行代码等价</span>
soup.find_all(<span class="string">"a"</span>)
soup(<span class="string">"a"</span>)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### find()</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># 这两行代码几乎等价</span><br><span class="line">soup.find_all(&#39;title&#39;, limit&#x3D;1) # 返回列表</span><br><span class="line">soup.find(&#39;title&#39;) # 返回结果 等价于 soup.title</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
<h4 id="selector-CSS选择器-的用法"><a href="#selector-CSS选择器-的用法" class="headerlink" title="selector (CSS选择器) 的用法"></a>selector (CSS选择器) 的用法</h4><p>Beautiful Soup支持大部分的CSS（CSS，全称叫作 Cascading Style Sheets，即层叠样式表）选择器， 在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag。</p>
<h5 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#head_wrapper</span><span class="selector-class">.s-ps-islite</span> <span class="selector-class">.s-p-top</span> &#123;   </span><br><span class="line">    <span class="attribute">position</span>: absolute;  </span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">40px</span>;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">181px</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>表示 id =head_wrapper 且（没有空格表是&amp;）class 为 s-ps-islite的节点，然后再选中其内部（有空格表示内部）的 class 为 s-p-top 的节点。字典定义了这个元素的布局方式</p>
<p>谷歌浏览器→右键→检查→鼠标放到网页书名上，在检查窗口右键→copy→copy selector，结果如下(&gt; 找到某个tag标签下的子标签)：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#subject_list</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.info</span> &gt; <span class="selector-tag">h2</span> &gt; <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure>

<h5 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h5><ul>
<li>CSS 选择器用来定位节点，根据 <strong>id、class、标签名筛选</strong>是其中最常用的3种表示方式。</li>
<li>CSS 选择器还支持嵌套选择，各个选择器之间<strong>空格分隔</strong>代表<strong>嵌套关系</strong>，如果<strong>不加空格</strong>，代表<strong>并列</strong>关系。</li>
<li><code>ul &gt; li</code>表示选择父节点为 ul 节点的所有 li 节点</li>
<li><code>li:nth-child(n)</code> 表示选择属于其父节点的第n个子节点的所有 li 节点</li>
<li>CSS选择器及其他语法规则参见<a href="https://python3webspider.cuiqingcai.com/2.2web-wang-ye-ji-chu#2-2-4-xuan-ze-qi" target="_blank" rel="noopener">该表格</a></li>
</ul>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>通过get_text()可以通过下面代码得到每一页面的书名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_name_list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">21</span>): <span class="comment"># 每页20本书</span></span><br><span class="line">        book_name = soup.select(<span class="string">"#subject_list &gt; ul &gt; li:nth-child("</span> + str(j) + <span class="string">") &gt; div.info &gt; h2 &gt; a"</span>)  </span><br><span class="line">        <span class="comment"># 第29页只有19本书</span></span><br><span class="line">        <span class="keyword">for</span> book_name <span class="keyword">in</span> book_name:</span><br><span class="line">            book_name_list.append(book_name.get_text().replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">"\r"</span>, <span class="string">""</span>).replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br></pre></td></tr></table></figure>

<h3 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h3><h3 id="解析部分文档"><a href="#解析部分文档" class="headerlink" title="解析部分文档"></a>解析部分文档</h3><p>如果仅仅因为想要查找文档中的<a>标签而将整片文档进行解析,实在是浪费内存和时间.最快的方法是从一开始就把<a>标签以外的东西都忽略掉. <code>SoupStrainer</code> 类可以定义文档的某段内容,这样搜索文档时就不必先解析整篇文档,只会解析在 <code>SoupStrainer</code> 中定义过的文档. 创建一个 <code>SoupStrainer</code> 对象并作为 <code>parse_only</code> 参数给 <code>BeautifulSoup</code> 的构造方法即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> SoupStrainer</span><br><span class="line">only_a_tags = SoupStrainer(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="6-解析库pyquery"><a href="#6-解析库pyquery" class="headerlink" title="6. 解析库pyquery"></a>6. 解析库pyquery</h2><p>用法和JQuery类似</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html = <span class="string">" &lt;html blabla"</span></span><br><span class="line">pq(html)</span><br></pre></td></tr></table></figure>

<h4 id="URL初始化"><a href="#URL初始化" class="headerlink" title="URL初始化"></a>URL初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">'http://cuiqingcai.com'</span>)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure>

<p>PyQuery 对象会首先请求这个 URL，然后用得到的 HTML 内容完成初始化，这其实就相当于用网页的源代码以字符串的形式传递给 PyQuery 类来初始化。</p>
<p>相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">doc = pq(requests.get(<span class="string">'http://cuiqingcai.com'</span>).text)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure>

<h4 id="文件初始化"><a href="#文件初始化" class="headerlink" title="文件初始化"></a>文件初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(filename=<span class="string">'dem.html'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="CSS选择器-1"><a href="#CSS选择器-1" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc=pq(html)</span><br><span class="line">print(doc(<span class="string">"#content .info name"</span>))</span><br></pre></td></tr></table></figure>

<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><h4 id="子节点-1"><a href="#子节点-1" class="headerlink" title="子节点"></a>子节点</h4><h5 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h5><p>查找所有子孙节点</p>
<p>会找到所有符合条件的节点，和BeautifulSoup中的find()不同，类似于BS中的find_all()</p>
<h5 id="children"><a href="#children" class="headerlink" title="children()"></a>children()</h5><p>只查找子节点 ， 支持CSS选择器</p>
<h4 id="父节点-1"><a href="#父节点-1" class="headerlink" title="父节点"></a>父节点</h4><h5 id="parent-1"><a href="#parent-1" class="headerlink" title="parent()"></a>parent()</h5><p>直接父节点</p>
<h5 id="parents-1"><a href="#parents-1" class="headerlink" title="parents()"></a>parents()</h5><p>祖贤父节点</p>
<h4 id="兄弟节点-1"><a href="#兄弟节点-1" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><h5 id="sublings"><a href="#sublings" class="headerlink" title="sublings()"></a>sublings()</h5><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>PyQuery的选择结果不会像BeautifulSoup一样返回list，而是直接返回多个或单个节点</p>
<p>返回单个节点可以直接用str()u转化为字符串，</p>
<p>返回多个节点需要遍历，斯奥用items()方法，返回生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = doc(<span class="string">'li'</span>).items()</span><br><span class="line">print(type(lis)) <span class="comment"># class 'generator'</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">    print(li, type(li))</span><br></pre></td></tr></table></figure>

<h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><h4 id="获取属性attr"><a href="#获取属性attr" class="headerlink" title="获取属性attr()"></a>获取属性attr()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = doc(<span class="string">'a'</span>)</span><br><span class="line">a.attr(<span class="string">'href'</span>)  <span class="comment"># 只会返回第一个满足条件的标签（节点）的href属性</span></span><br></pre></td></tr></table></figure>

<p>如果获取所有节点的属性，需要调用items()遍历。</p>
<h4 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h4><p>text()方法返回<strong>所有</strong>节点下纯文字内容，即不需要遍历。</p>
<p>html()方法返回HTML文本，多个节点时，需要<strong>遍历</strong>。</p>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><h4 id="addClass-和-removeClass"><a href="#addClass-和-removeClass" class="headerlink" title="addClass 和 removeClass"></a>addClass 和 removeClass</h4><p>添加，删除class这个属性</p>
<h4 id="attr、text、html"><a href="#attr、text、html" class="headerlink" title="attr、text、html"></a>attr、text、html</h4><p>attr操作其他属性，<code>li.attr(&#39;name&#39;, &#39;link&#39;)</code> 将name属性的值修改为link，如果不存在，则创建改属性。</p>
<p>如果 attr 方法只传入第一个参数的属性名，则是获取这个属性值；如果传入第二个参数，可以用来修改属性值。text 和 html 方法如果不传参数，则是获取节点内纯文本和 HTML 文本；如果传入参数，则进行赋值。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p><strong>为提取信息带来便利</strong></p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>CSS选择器支持各种各样的伪类选择器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">li = doc(<span class="string">'li:first-child'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:last-child'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:nth-child(2)'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:gt(2)'</span>) <span class="comment"># 三个以后的li节点</span></span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:nth-child(2n)'</span>) <span class="comment"># 偶数位置的li节点</span></span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:contains(second)'</span>) <span class="comment">#包含second的li节点</span></span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>

<h2 id="7-使用代理IP"><a href="#7-使用代理IP" class="headerlink" title="7. 使用代理IP"></a>7. 使用代理IP</h2><p>很多网站对于爬虫做了一定限制，IP容易进小黑屋，所以需要采用代理IP。</p>
<h3 id="代理的种类"><a href="#代理的种类" class="headerlink" title="代理的种类"></a>代理的种类</h3><ul>
<li><p><strong>透明代理 (Transparent Proxy)</strong>: 不但改动了数据包，还会告诉服务器客户端的真实IP，约等于没用。</p>
<ul>
<li>REMOTE_ADDR = Proxy IP</li>
<li>HTTP_VIA = Proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = Your IP</li>
</ul>
</li>
<li><p><strong>普通匿名代理 (Anonymous Proxy)</strong>：会在数据包上做一些改动，服务器上发现这是个代理服务器，但是一般不清楚真实IP地址（有一定几率能追查到）。</p>
<ul>
<li>REMOTE_ADDR = proxy IP</li>
<li>HTTP_VIA = proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = proxy IP</li>
</ul>
</li>
<li><p><strong>混淆代理(Distorting Proxies)</strong>：会在数据包上做一些改动，服务器上发现这是个代理服务器，但会得到一个假的IP地址.</p>
<ul>
<li>REMOTE_ADDR = proxy IP</li>
<li>HTTP_VIA = proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = Random IP address</li>
</ul>
</li>
<li><p><strong>高匿代理(Elite proxy或High Anonymity Proxy)</strong>：会将数据包原封不动的转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP则是代理服务器的IP。</p>
<ul>
<li>REMOTE_ADDR = Proxy IP</li>
<li>HTTP_VIA = not determined</li>
<li>HTTP_X_FORWARDED_FOR = not determined</li>
</ul>
<p><strong>参考</strong>：<a href="https://blog.csdn.net/a19860903/article/details/47146715" target="_blank" rel="noopener">https://blog.csdn.net/a19860903/article/details/47146715</a></p>
</li>
</ul>
<h3 id="代理IP网站"><a href="#代理IP网站" class="headerlink" title="代理IP网站"></a>代理IP网站</h3><ol>
<li><a href="https://www.kuaidaili.com/ops/proxylist/1/" target="_blank" rel="noopener">快代理</a></li>
<li><a href="http://www.66ip.cn/index.html" target="_blank" rel="noopener">66代理</a></li>
</ol>
<h3 id="建立代理IP池"><a href="#建立代理IP池" class="headerlink" title="建立代理IP池"></a>建立代理IP池</h3><p>以<a href="https://www.kuaidaili.com/ops/proxylist/1/" target="_blank" rel="noopener">快代理</a>为例：</p>
<details>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span><span class="params">(headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取代理IP列表</span></span><br><span class="line"><span class="string">    :return: ip_list [&#123;"https": ip&#125;,…]</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    ip_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="comment"># 快代理</span></span><br><span class="line">        base_url = <span class="string">"https://www.kuaidaili.com/ops/proxylist/"</span> + str(i)</span><br><span class="line">        html = requests.get(base_url, headers=headers).text</span><br><span class="line"> </span><br><span class="line">        pattern = <span class="string">'\d+\.\d+\.\d+\.\d+'</span></span><br><span class="line">        re_list = re.findall(pattern, html)</span><br><span class="line">        <span class="keyword">for</span> ip_port <span class="keyword">in</span> re_list:</span><br><span class="line">            ip_list.append(&#123;<span class="string">"https"</span>: ip_port&#125;)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"><span class="comment"># 快代理 上有些IP类型仅为http，有些为http，https</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="测试代理IP"><a href="#测试代理IP" class="headerlink" title="测试代理IP"></a>测试代理IP</h3><p>通过request直接请求一个网址，看是否通过或者看状态码是否为200(<strong><code>request.status_code == 200</code></strong>)</p>
<details>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_proxy</span><span class="params">(ip_list, headers, test_url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    测试代理IP</span></span><br><span class="line"><span class="string">    :param ip_list:</span></span><br><span class="line"><span class="string">    :return: ip_list [&#123;"https": ip&#125;,…]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=<span class="number">5</span>)  </span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectTimeout:</span><br><span class="line">            ip_list.pop(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>

<details>
**但是上述代码的问题是设置了代理IP，请求网站通过，也不代表IP有效，因为有可能不是用了设置的代理IP而是用了自己公网下的IP（可以用ifconfig查询所在局域网下的IP，及私网IP）**[参考](https://blog.csdn.net/Chenftli/article/details/86701563)

<details>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_proxy_3</span><span class="params">(ip_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    测试是理IP</span></span><br><span class="line"><span class="string">    :param ip_list:</span></span><br><span class="line"><span class="string">    :return ip_valid_list: [&#123;https: ip&#125;,…]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ip_valid_list = []</span><br><span class="line">    test_url =  <span class="string">"http://httpbin.org/get"</span> <span class="comment"># 改网站可测试目前请求的IP</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(test_url, proxies=proxy, headers=headers, timeout=<span class="number">8</span>)</span><br><span class="line">            data = response.text.strip()</span><br><span class="line">            proxyIP = json.loads(data)[<span class="string">'origin'</span>]</span><br><span class="line">            <span class="keyword">if</span> proxyIP != proxy[<span class="string">"https"</span>]:</span><br><span class="line">                ip_list.pop(i)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#print("proxy invalid")</span></span><br><span class="line">            ip_list.pop(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ip_valid_list</span><br></pre></td></tr></table></figure>

<details>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><details>
<summary><mark>隐藏</mark></summary>

<p>Max retries exceeded with url</p>
<ol>
<li><p>requests.exceptions.<strong>ProxyError</strong>: HTTPConnectionPool(host=’**<em>‘, port=443): Max retries exceeded with url: **\</em> (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘&lt;urllib3.connection.HTTPConnection object at 0x0000015363189190&gt;: </p>
<blockquote>
<p>IP代理使用的协议不正常，http和https不能写错。</p>
</blockquote>
</li>
<li><p>requests.exceptions.<strong>ConnectionError</strong>: HTTPSConnectionPool(host=<em>*<em>, , port=443): Max retries exceeded with url: \</em>*\</em> (Caused by NewConnectionError(‘&lt;urllib3.connection.VerifiedHTTPSConnection object at 0x7fb51433af98&gt;:</p>
<blockquote>
<p>http的连接数超过最大限制，默认的情况下连接是Keep-alive的，所以导致服务器保持了太多连接而不能再新建连接。</p>
</blockquote>
</li>
<li><p>HTTPSConnectionPool(host=’***‘, port=443): Max retries exceeded with url: ***(Caused by SSLError(SSLError(1, u’[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:579)’),))</p>
<blockquote>
<p>Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证失败，Requests 会抛出 SSLError。</p>
<ul>
<li><p>不用ssl证书验证，将verify 设置为 False，<strong>page=requests.get(url，verify=False)</strong></p>
</li>
<li><p>requests默认是keep-alive的，可能没有释放，加参数 headers={‘Connection’:’close’}</p>
</li>
<li><p>增加连接重试次数：<code>requests.adapters.DEFAULT_RETRIES = 5</code> </p>
</li>
<li><p>关闭多余的连接：requests使用了urllib3库，默认的http connection是keep-alive的，requests设置False关闭。<code>s = requests.session()       s.keep_alive = False</code> </p>
<p>参考：<a href="https://blog.csdn.net/wdh315172/article/details/80491668" target="_blank" rel="noopener">https://blog.csdn.net/wdh315172/article/details/80491668</a></p>
</li>
</ul>
</blockquote>
<details>

</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><a href="https://github.com/Hopetree/Jobs-search" target="_blank" rel="noopener">招聘网站爬虫</a></li>
<li><a href="https://github.com/Hopetree/E-commerce-crawlers" target="_blank" rel="noopener">电商网站爬虫</a></li>
<li><a href="https://github.com/Hopetree/Spiders100" target="_blank" rel="noopener">Spiders100</a></li>
<li><a href="https://github.com/Hopetree/MyTools" target="_blank" rel="noopener">一些界面化的爬虫小工具</a></li>
</ul>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">BeautifulSoup4官方中文文档</a></li>
<li><a href="[https://www.jianshu.com/p/2b783f7914c6](https://www.jianshu.com/p/2b783f7914c6)">bs4模块使用指南</a></li>
<li><a href="https://python3webspider.cuiqingcai.com/" target="_blank" rel="noopener">Python3网络爬虫开发实战</a>​</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习之数据存储</title>
    <url>/2020/07/29/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>TXT, JSON, CSV等，以及关系型数据库MySQL，菲关系型数据库MongoDB、Redis 等</p>
<a id="more"></a>

<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><h4 id="TXT文本存储"><a href="#TXT文本存储" class="headerlink" title="TXT文本存储"></a>TXT文本存储</h4><p>文件写入还有一种简写方法，那就是使用 with as 语法。在 with 控制块结束时，文件会自动关闭，所以就不需要再调用 close 方法了。这种保存方式可以简写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'explore.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">'\n'</span>.join([question, author, answer]))</span><br><span class="line">    file.write(<span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON，全称为 JavaScript Object Notation, 也就是 JavaScript 对象标记，它通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，是一种轻量级的数据交换格式。</p>
<h5 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h5><p>在 JavaScript 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等</p>
<p><strong>对象</strong> ：它在 JavaScript 中是使用花括号 {} 包裹起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</p>
<p><strong>数组</strong> ：数组在 JavaScript 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JavaScript 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引用得多。同样，值的类型可以是任意类型。</p>
<h5 id="读取和写入"><a href="#读取和写入" class="headerlink" title="读取和写入"></a>读取和写入</h5><p>loads() string to json # <strong>json数据需要使用双引号（</strong>double quotes<strong>）来包围</strong></p>
<p>dumps() json to string <code>son.dumps(data, indent=2)</code></p>
<p>注意：文本含有中文字符时，指定编码方式为<strong>utf-8</strong> 并且将ensure_ascii设为False：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'MaoYan_result.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>见前篇：<a href="https://yuqie.github.io/2020/07/25/python%E4%B9%8Bcsv/" target="_blank" rel="noopener">python之csv</a></p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库是基于<strong>关系模型</strong>的数据库，而关系模型是通过二维表来保存的，所以它的存储方式就是行列组成的表，每一列是一个字段，每一行是一条记录。表可以看作某个实体的集合，而实体之间存在联系，这就需要表与表之间的关联关系来体现，如主键外键的关联关系。多个表组成一个数据库，也就是关系型数据库。</p>
<p>关系型数据库有多种，如 SQLite、MySQL、Oracle、SQL Server、DB2 等。</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>在 Python 2 中，连接 MySQL 的库大多是使用 MySQLdb，但是此库的官方并不支持 Python 3，所以在Python3中使用 PyMySQL 操作 MySQL 数据库。</p>
<h5 id="创建新的数据库："><a href="#创建新的数据库：" class="headerlink" title="创建新的数据库："></a>创建新的数据库：</h5><p><code>&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>,user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>)  </span><br><span class="line">cursor = db.cursor()  </span><br><span class="line">cursor.execute(<span class="string">"CREATE DATABASE spiders DEFAULT CHARACTER SET utf8"</span>)  </span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<p>之后重新连接数据库，指定参数db</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>, db=<span class="string">'spiders'</span>)</span><br><span class="line">cursor = db.cursor()</span><br></pre></td></tr></table></figure>

<h5 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h5><p><code>&#39;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&#39;</code></p>
<h5 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h5><p><code>&#39;INSERT INTO students(id, name, age) values(% s, % s, % s)&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    cursor.execute(sql, (id, user, age))</span><br><span class="line">    db.commit()</span><br><span class="line">except:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<ul>
<li>对于数据插入、更新、删除操作，都需要执行 db 对象的 commit 方法才能真正生效，这个方法才是真正将语句提交到数据库执行的方法。</li>
<li>异常处理。如果执行失败，则调用 rollback 执行数据回滚，可以保证事务的一致性。</li>
<li>事务机制可以确保数据的一致性，也就是这件事要么发生了，要么没有发生。比如插入一条数据，不会存在插入一半的情况，要么全部插入，要么都不插入，这就是事务的原子性。</li>
<li>事务的 4 个属性，也称为 ACID 特性。</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>原子性（atomicity）</td>
<td>事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做</td>
</tr>
<tr>
<td>一致性（consistency）</td>
<td>事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</td>
</tr>
<tr>
<td>隔离性（isolation）</td>
<td>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</td>
</tr>
<tr>
<td>持久性（durability）</td>
<td>持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</td>
</tr>
</tbody></table>
<p><strong>动态数据传入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20120001'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Bob'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">'students'</span></span><br><span class="line">keys = <span class="string">', '</span>.join(data.keys())</span><br><span class="line">values = <span class="string">', '</span>.join([<span class="string">'% s'</span>] * len(data))</span><br><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)'</span>.format(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="keyword">if</span> cursor.execute(sql, tuple(data.values())):</span><br><span class="line">       print(<span class="string">'Successful'</span>)</span><br><span class="line">       db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>

<h5 id="更新数据："><a href="#更新数据：" class="headerlink" title="更新数据："></a>更新数据：</h5><p>现一种去重的方法，如果数据存在，则更新数据；如果数据不存在，则插入数据。</p>
<p><code>INSERT INTO students(id, name, age) VALUES (% s, % s, % s) ON DUPLICATE KEY UPDATE id = % s, name = % s, age = % s</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;) ON DUPLICATE KEY UPDATE'</span>.format(table=table, keys=keys, values=values)</span><br><span class="line">update = <span class="string">','</span>.join([<span class="string">"&#123;key&#125; = % s"</span>.format(key=key) <span class="keyword">for</span> key <span class="keyword">in</span> data])</span><br><span class="line">sql += update</span><br></pre></td></tr></table></figure>

<h5 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h5><p><code>&#39;DELETE FROM  {table} WHERE {condition}&#39;.format(table=table, condition=condition)</code></p>
<h5 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h5><p>查询年龄 20 岁及以上的学生<code>&#39;SELECT * FROM students WHERE age &gt;= 20&#39;</code></p>
<p>fetchone 方法，这个方法可以获取结果的第一条数据，返回结果是元组形式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    print(<span class="string">'Count:'</span>, cursor.rowcount)</span><br><span class="line">    row = cursor.fetchone()</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(<span class="string">'Row:'</span>, row)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre></td></tr></table></figure>

<p>fetchall 方法，它可以得到结果的所有数据。然后将其结果和类型打印出来，它是二重元组，每个元素都是一条记录，我们将其遍历输出出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        print(row)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="非关系型数据库存储"><a href="#非关系型数据库存储" class="headerlink" title="非关系型数据库存储"></a>非关系型数据库存储</h3><p>NoSQL，全称 Not Only SQL，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于<strong>键值对</strong>的，而且不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>代表</th>
</tr>
</thead>
<tbody><tr>
<td>键值存储数据库</td>
<td>Redis、Voldemort 和 Oracle BDB 等</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra、HBase 和 Riak 等</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB 和 MongoDB 等</td>
</tr>
<tr>
<td>图形数据库</td>
<td>Neo4J、InfoGrid 和 Infinite Graph 等</td>
</tr>
</tbody></table>
<p>对于<strong>爬虫的数据存储</strong>来说，一条数据可能存在<strong>某些字段提取失败而缺失</strong>的情况，而且<strong>数据可能随时调整</strong>。另外，数据之间还存在<strong>嵌套关系</strong>。如果使用关系型数据库存储，一是需要提前建表，二是如果存在数据嵌套关系的话，需要进行序列化操作才可以存储，这非常不方便。</p>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>MongoDB 是由 <strong>C++ ** 语言编写的非关系型数据库，是一个基于</strong>分布式文件存储** 的开源数据库系统，其内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组。</p>
<p><a href="https://www.jianshu.com/p/d99f6fd8b209" target="_blank" rel="noopener">安装MongoDB</a></p>
<p>CMD命令进入某个目录: 进入某个磁盘，直接盘符代号：如D：，不用CD 命令切换; 进入除根录以下的文件夹, cd 文件夹路径.</p>
<p>遇到warning：Access control is not enabled for the database.</p>
<p>原因分析：新版本的MongDB增加了安全性设计，推荐用户创建使用数据库时进行验证。如果用户想建立简单连接，则会提示警示信息。</p>
<p>解决办法：创建管理员并设置密码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: "userAdmin", //用户名</span><br><span class="line">    pwd: "123", //密码</span><br><span class="line">    roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] //权限</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>重启MongoDB服务器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mongod --auth --port <span class="number">27017</span> --dbpath &lt;关联路径:bin/&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>端口默认就是27017可以不指定</p>
<p><a href="https://blog.csdn.net/ttxsely/article/details/77726164" target="_blank" rel="noopener">https://blog.csdn.net/ttxsely/article/details/77726164</a></p>
</li>
</ul>
<h5 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</span><br></pre></td></tr></table></figure>

<h5 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = client.test</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">db = client[test]</span><br></pre></td></tr></table></figure>

<h5 id="指定集合（collection）"><a href="#指定集合（collection）" class="headerlink" title="指定集合（collection）"></a>指定集合（collection）</h5><p><strong>集合</strong>类似于关系型数据库中的<strong>表</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection = db.students</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">collection = db[<span class="string">'students'</span>]</span><br></pre></td></tr></table></figure>

<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert(student)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>在 MongoDB 中，每条数据其实都有一个_id 属性来唯一标识。如果没有显式指明该属性，MongoDB 会自动产生一个 ObjectId 类型的_id 属性。insert() 方法会在执行后返回_id 值。</p>
</li>
<li><p>以列表形式传递可同时插入多条数据。</p>
</li>
<li><p>PyMongo 3.x 版本中，官方不推荐使用 insert() 方法。而是推荐使用 insert_one() 和 insert_many() 方法来分别插入单条记录和多条记录。</p>
<p>insert_one() （返回InsertOneResult对象），用其 inserted_id 属性获取_id。</p>
<p>insert_many() （返回的类型是 InsertManyResult），调用 inserted_ids 属性可以获取插入数据的_id 列表。</p>
</li>
</ul>
<h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><ul>
<li>find_one() 查询得到的是单个结果，类型为字典：<code>result = collection.find_one({&#39;name&#39;: &#39;Mike&#39;})</code></li>
<li>find() 则返结果是 Cursor 类型，它相当于一个生成器：<code>results = collection.find({&#39;age&#39;: 20})</code></li>
<li>比较符号和功能符号：</li>
</ul>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>$lt</td>
<td>小于</td>
<td>{‘age’: {‘$lt’: 20}}</td>
</tr>
<tr>
<td>$gt</td>
<td>大于</td>
<td>{‘age’: {‘$gt’: 20}}</td>
</tr>
<tr>
<td>$lte</td>
<td>小于等于</td>
<td>{‘age’: {‘$lte’: 20}}</td>
</tr>
<tr>
<td>$gte</td>
<td>大于等于</td>
<td>{‘age’: {‘$gte’: 20}}</td>
</tr>
<tr>
<td>$ne</td>
<td>不等于</td>
<td>{‘age’: {‘$ne’: 20}}</td>
</tr>
<tr>
<td>$in</td>
<td>在范围内</td>
<td>{‘age’: {‘$in’: [20, 23]}}</td>
</tr>
<tr>
<td>$nin</td>
<td>不在范围内</td>
<td>{‘age’: {‘$nin’: [20, 23]}}</td>
</tr>
<tr>
<td>正则匹配查询</td>
<td>以 M 开头</td>
<td>{‘$regex’: ‘^M.*’}</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>示例含义</th>
</tr>
</thead>
<tbody><tr>
<td>$regex</td>
<td>匹配正则表达式</td>
<td>{‘$regex’: ‘^M.*’}</td>
<td>name 以 M 开头</td>
</tr>
<tr>
<td>$exists</td>
<td>属性是否存在</td>
<td>{‘name’: {‘$exists’: True}}</td>
<td>name 属性存在</td>
</tr>
<tr>
<td>$type</td>
<td>类型判断</td>
<td>{‘age’: {‘$type’: ‘int’}}</td>
<td>age 的类型为 int</td>
</tr>
<tr>
<td>$mod</td>
<td>数字模操作</td>
<td>{‘age’: {‘$mod’: [5, 0]}}</td>
<td>年龄模 5 余 0</td>
</tr>
<tr>
<td>$text</td>
<td>文本查询</td>
<td>{‘$text’: {‘$search’: ‘Mike’}}</td>
<td>text 类型的属性中包含 Mike 字符串</td>
</tr>
<tr>
<td>$where</td>
<td>高级条件查询</td>
<td>{‘$where’: ‘obj.fans_count == obj.follows_count’}</td>
<td>自身粉丝数等于关注数</td>
</tr>
</tbody></table>
<h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><p><code>count = collection.find({&#39;age&#39;: 20}).count()</code></p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING)</code></p>
<p>调用 pymongo.ASCENDING 指定升序。如果要降序排列，可以传入 pymongo.DESCENDING。</p>
<h5 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h5><p>例如，忽略前两个元素，得到第三个及以后的元素：</p>
<p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2)</code></p>
<p>可以用 limit() 方法指定要取的结果个数：</p>
<p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2).limit(2)</code></p>
<ul>
<li><p>在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，因为这样很可能导致内存溢出。这时需要记录好上次查询的_id，使用类似如下操作来查询:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bson.objectid import ObjectId</span><br><span class="line">collection.find(&#123;&#39;_id&#39;: &#123;&#39;$gt&#39;: ObjectId(&#39;593278c815c2602678bb2b8d&#39;)&#125;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><ul>
<li><p>update</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line"><span class="comment"># 使用 $set 操作符对数据进行更新</span></span><br><span class="line">result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>update_one()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二个参数不能再直接传入修改后的字典,而是需要使用 &#123;'$set': student&#125;</span></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;) <span class="comment"># 执行之后会将第一条符合条件的数据年龄加 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>update_many()，则会将所有符合条件的数据都更新</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li><p>remove()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete_one()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete_many()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">25</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><ul>
<li>组合方法，如 find_one_and_delete()、find_one_and_replace() 和 find_one_and_update(</li>
<li>对索引进行操作，如 create_index()、create_indexes() 和 drop_index() 等。</li>
</ul>
<h4 id="Redis-存储"><a href="#Redis-存储" class="headerlink" title="Redis 存储"></a>Redis 存储</h4><p>Redis 是一个基于<strong>内存</strong> 的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构。</p>
<p>StrictRedis：set和get操作。</p>
<h5 id="连接-Redis"><a href="#连接-Redis" class="headerlink" title="连接 Redis"></a>连接 Redis</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis  </span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)  <span class="comment"># default： localhost、6379、0 和 None</span></span><br></pre></td></tr></table></figure>

<p>使用 ConnectionPool 来连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool  </span><br><span class="line"></span><br><span class="line">pool = ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)  </span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure>

<p>ConnectionPool 还支持通过 URL 来构建, URL 的格式支持有如下 3 种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis://[:password]@host:port/db   # 创建 Redis TCP 连接</span></span><br><span class="line"><span class="comment"># rediss://[:password]@host:port/db  # Redis TCP+SSL 连接</span></span><br><span class="line"><span class="comment"># unix://[:password]@/path/to/socket.sock?db=db # Redis UNIX socket 连接</span></span><br><span class="line">    </span><br><span class="line">url = <span class="string">'redis://:foobared@localhost:6379/0'</span>  </span><br><span class="line">pool = ConnectionPool.from_url(url)  </span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure>

<h5 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h5><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>键值对形式存储</p>
<p>set(name,value) </p>
<p>mset(name,value)</p>
<p>get(value)</p>
<p>mget(value)</p>
<p>getset(name, value)</p>
<p>incr(name, amount=1)  键名为 name 的 value 增值操作，默认为 1，键不存在则被创建并设为 </p>
<p>decr(name, amount=1)</p>
<p>append(key, value)</p>
<h5 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h5><table>
<thead>
<tr>
<th>方　　法</th>
<th>作　　用</th>
<th>参数说明</th>
<th>示　　例</th>
<th>示例说明</th>
<th>示例结果</th>
</tr>
</thead>
<tbody><tr>
<td>rpush(name, *values)</td>
<td>在键名为 name 的列表末尾添加值为 value 的元素，可以传多个</td>
<td>name：键名；values：值</td>
<td>redis.rpush(‘list’, 1, 2, 3)</td>
<td>向键名为 list 的列表尾添加 1、2、3</td>
<td>3，列表大小</td>
</tr>
<tr>
<td>lpush(name, *values)</td>
<td>在键名为 name 的列表头添加值为 value 的元素，可以传多个</td>
<td>name：键名；values：值</td>
<td>redis.lpush(‘list’, 0)</td>
<td>向键名为 list 的列表头部添加 0</td>
<td>4，列表大小</td>
</tr>
<tr>
<td>llen(name)</td>
<td>返回键名为 name 的列表的长度</td>
<td>name：键名</td>
<td>redis.llen(‘list’)</td>
<td>返回键名为 list 的列表的长度</td>
<td>4</td>
</tr>
<tr>
<td>lrange(name, start, end)</td>
<td>返回键名为 name 的列表中 start 至 end 之间的元素</td>
<td>name：键名；start：起始索引；end：终止索引</td>
<td>redis.lrange(‘list’, 1, 3)</td>
<td>返回起始索引为 1 终止索引为 3 的索引范围对应的列表</td>
<td>[b’3’, b’2’, b’1’]</td>
</tr>
<tr>
<td>ltrim(name, start, end)</td>
<td>截取键名为 name 的列表，保留索引为 start 到 end 的内容</td>
<td>name：键名；start：起始索引；end：终止索引</td>
<td>ltrim(‘list’, 1, 3)</td>
<td>保留键名为 list 的索引为 1 到 3 的元素</td>
<td>True</td>
</tr>
</tbody></table>
<h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p>集合中的元素都是不重复的</p>
<h5 id="有序集合操作"><a href="#有序集合操作" class="headerlink" title="有序集合操作"></a>有序集合操作</h5><p>有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序</p>
<h5 id="散列操作"><a href="#散列操作" class="headerlink" title="散列操作"></a>散列操作</h5><p>散列表的数据结构</p>
<h5 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h5><p>提供了 Redis 数据的导入和导出功能，redis-dump 用于导出数据，redis-load 用于导入数据。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
        <tag>json，csv，数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫之实战问题</title>
    <url>/2020/08/03/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-selenium调用Chrome打开淘宝时需要登录"><a href="#1-selenium调用Chrome打开淘宝时需要登录" class="headerlink" title="1. selenium调用Chrome打开淘宝时需要登录"></a>1. selenium调用Chrome打开淘宝时需要登录</h2><a id="more"></a>

<p>由于需要登录用户信息，导致爬虫程序被打断，可以再使用selenium去模拟人的登录，输入账号和密码以及滑动，但是觉得很麻烦还会有各种各样的bug，所以决定用类似于cookie的方法即利用保存在电脑上的chrome用户信息来登录淘宝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()        <span class="comment">#初始化</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)         <span class="comment">#设置浏览器无头模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>)      <span class="comment">#避免一些报错</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--no-sandbox'</span>)       <span class="comment">#避免出错</span></span><br><span class="line">chrome_options.add_argument(<span class="string">r'user-data-dir=C:\Users\username\AppData\Local\Google\Chrome\User Data'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=chrome_options)</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>注意：</strong> 为chrome浏览器设置参数,如果使用用户信息，不会调起新的chrome，所以需要将Chrome所有窗口关闭，否则因为占用会出错。</li>
</ul>
<p>另外还可以直接传入cookies。或者，或者使用requests.post() 传入账号，密码。</p>
<h2 id="2-淘宝搜索button，使用click点击无反应"><a href="#2-淘宝搜索button，使用click点击无反应" class="headerlink" title="2. 淘宝搜索button，使用click点击无反应"></a>2. 淘宝搜索button，使用click点击无反应</h2><p>有些需要enter</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(url)</span><br><span class="line">input = driver.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">input.clear()  <span class="comment"># 清空搜索框数据</span></span><br><span class="line">input.send_keys(<span class="string">'ipad'</span>)  <span class="comment"># 输入检索词</span></span><br><span class="line">input.send_keys(Keys.ENTER)</span><br></pre></td></tr></table></figure>

<h2 id="3-淘宝搜索结果的下一页点击失败"><a href="#3-淘宝搜索结果的下一页点击失败" class="headerlink" title="3.淘宝搜索结果的下一页点击失败"></a>3.淘宝搜索结果的下一页点击失败</h2><p>解决方法：在页码框输入页码，然后点击确定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = wait.until(EC.presence_of_element_located((By.XPATH, <span class="string">'//*[@id="mainsrp-pager"]/div/div/div/div[2]/input'</span>))) <span class="comment"># 输入框</span></span><br><span class="line">submit = wait.until(EC.element_to_be_clickable((By.XPATH, <span class="string">'//*[@id="mainsrp-pager"]/div/div/div/div[2]/span[3]'</span>))) <span class="comment"># 确定按钮</span></span><br><span class="line">input.clear()</span><br><span class="line">input.send_keys(str(page))</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Jupyter Notebook中使用Python虚拟环境？</title>
    <url>/2020/08/25/%E5%A6%82%E4%BD%95%E5%9C%A8Jupyter%20Notebook%E4%B8%AD%E4%BD%BF%E7%94%A8Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%9F/</url>
    <content><![CDATA[<p>电脑中多版本python并存，直接安装过python，使用过anaconda全家桶，同时创建过虚拟环境（虽然我也不知道两个都是python3.7为啥要用虚拟环境），这就导致了一个问题。</p>
<a id="more"></a>

<h2 id="虚拟环境下运行spyder"><a href="#虚拟环境下运行spyder" class="headerlink" title="虚拟环境下运行spyder"></a>虚拟环境下运行spyder</h2><p>在打开spyder时，默认使用base，如何使用虚拟环境呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入环境后</span></span><br><span class="line">spyder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经打开spyder了</span></span><br><span class="line">spyder --new-instance</span><br></pre></td></tr></table></figure>

<h2 id="Jupyter-notebook使用虚拟环境"><a href="#Jupyter-notebook使用虚拟环境" class="headerlink" title="Jupyter notebook使用虚拟环境"></a>Jupyter notebook使用虚拟环境</h2><p>即便通过anaconda创造了新的虚拟环境，但是在jupyter 中并没有体现出来。</p>
<blockquote>
<p>尝试过<code>conda activate env</code> 进入虚拟环境，再执行jupyter notebook，结果还是使用默认python（D:\Program Files (x86)\Anaconda3\py37\python.exe’），此时会出现一些包import失败的问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何查看使用的是哪个版本的python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure>

<h3 id="解决办法1："><a href="#解决办法1：" class="headerlink" title="解决办法1："></a>解决办法1：</h3><p>直接在sys.path这个列表append虚拟环境下的python路径和python库路径。</p>
<p>但是这种解决方案没有永久性，退出之后重新打开该文件运行时，则又会import失败，输出sys.path，发现之前加入的路径也不存在了。</p>
<h3 id="解决办法2："><a href="#解决办法2：" class="headerlink" title="解决办法2："></a>解决办法2：</h3><p><strong>用anaconda内生插件解决问题</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install nb_conda</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已有的kernels</span></span><br><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>

<p>再次启动jupyter notebook，就能看到<strong>所有虚拟环境</strong>都显示出来了。</p>
<p><strong>用jupyter插件解决问题</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line">conda install ipykernel</span><br><span class="line">python -m ipykernel install --name --display-name</span><br></pre></td></tr></table></figure>

<p>网上还有方法是安装ipykernel，不知道为什么，我可以看到kernel显示了虚拟环境，但是切换之后，没有效果，sys.exectubale仍然输出默认python的路径。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>anaconda powershell prompt 和 anaconda prompt的区别：前者多了一些linux命令，如pwd等，类似windows下cmd和windows powershell的区别。</li>
<li>虽然可以在prompt中通过cd切换文件夹，再打开jupyter notebook，或者在jupyter notebook命令后指定文件夹路径，但略显繁琐。<ul>
<li>在windows powershell下也可以运行jupyter notebook，所以可以在windows下打开文件夹，shift+鼠标右键，打开windows powershell，输入jupyter notebook命令</li>
<li>打开目标文件夹，选中上方文件位置栏，输入jupyter notebook即可</li>
<li>另外，如果想在windows powershell中激活虚拟环境，可执行：<code>conda init</code></li>
</ul>
</li>
<li>也可以到该文件夹下，右键-git bash，在git bash中启动jupyter notebook</li>
<li>注意2,3需要将anaconda安装路径里面的Scripts和Library\bin路径添加到windows系统环境变量中。</li>
</ol>
<h2 id="jupyter-notebook快捷键"><a href="#jupyter-notebook快捷键" class="headerlink" title="jupyter notebook快捷键"></a>jupyter notebook快捷键</h2><p>Jupyter Notebook 有两种键盘输入模式。</p>
<ol>
<li>编辑模式（enter进入），可以向单元中键入代码或文本；此时单元框线为绿色。</li>
<li>命令模式（Esc开启），键盘输入运行程序命令；此时单元框线为灰蓝色。</li>
</ol>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>tab</td>
<td>代码补全或缩进</td>
<td>Ctrl+Up</td>
<td>跳到单元开头</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>shift+tab</td>
<td>提示</td>
<td>Ctrl+End</td>
<td>跳到单元末尾</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>ctrl+]</td>
<td>缩进</td>
<td>Ctrl+Down</td>
<td>跳到单元末尾</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>ctrl+[</td>
<td>解除缩进</td>
<td>Ctrl+Left</td>
<td>跳到左边一个字首</td>
<td>Ctrl+Shift+-</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+A</td>
<td>全选</td>
<td>Ctrl+Right</td>
<td>跳到右边一个字首</td>
<td>Ctrl+Shift+Subtract</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+Z</td>
<td>复原</td>
<td>Ctrl+Backspace</td>
<td>删除前面一个字</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
</tr>
<tr>
<td>ctrl+shift+z</td>
<td>再做</td>
<td>Ctrl+Delete</td>
<td>删除后面一个字</td>
<td>Shift</td>
<td>忽略</td>
</tr>
<tr>
<td>ctrl+y</td>
<td>再做</td>
<td>Esc</td>
<td>进入命令模式</td>
<td>Up</td>
<td>光标上移或转入上一单元</td>
</tr>
<tr>
<td>ctrl+Home</td>
<td>跳到单元开头</td>
<td>Ctrl+M</td>
<td>进入命令模式</td>
<td>Down</td>
<td>光标下移或转入下一单元</td>
</tr>
</tbody></table>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>enter</td>
<td>转入编辑模式</td>
<td>C</td>
<td>复制选中的单元</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>Y</td>
<td>单元转入代码状态</td>
<td>V</td>
<td>粘贴到下方单元</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>M</td>
<td>单元转入markdown状态</td>
<td>Z</td>
<td>恢复删除的最后一个单元</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>R</td>
<td>单元转入raw状态</td>
<td>DD</td>
<td>删除选中的单元</td>
<td>shift+K</td>
<td>扩大选中上方单元</td>
</tr>
<tr>
<td>1</td>
<td>设定 1 级标题</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
<td>shift+J</td>
<td>扩大选中下方单元</td>
</tr>
<tr>
<td>2</td>
<td>设定 12级标题</td>
<td>S</td>
<td>文件存盘</td>
<td>shift+O</td>
<td>转换输出滚动</td>
</tr>
<tr>
<td>A</td>
<td>在上方插入新单元</td>
<td>L</td>
<td>转换行号</td>
<td>shift</td>
<td>忽略</td>
</tr>
<tr>
<td>B</td>
<td>在下方插入新单元</td>
<td>O</td>
<td>转换输出</td>
<td>K</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>X</td>
<td>剪切选中的单元</td>
<td>Q</td>
<td>关闭页面</td>
<td>J</td>
<td>选中下方单元</td>
</tr>
<tr>
<td>shift+V</td>
<td>粘贴到上方单元</td>
<td>H</td>
<td>显示快捷键帮助</td>
<td>Up</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>shift+M</td>
<td>合并选中的单元</td>
<td>space</td>
<td>向下滚动</td>
<td>Down</td>
<td>选中下方单元</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/w55100/article/details/88925697" target="_blank" rel="noopener">简书：使用anaconda虚拟环境运行Jupyter Notebook详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50456606" target="_blank" rel="noopener">Jupyter notebok 环境配置，与kernel切换（切换虚拟环境）</a></p>
<p><a href="https://blog.csdn.net/guolaoban11/article/details/103469952?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">jupyter notebook 打开任意文件夹，最简捷！！</a></p>
<p><a href="https://blog.csdn.net/lzbmc/article/details/102955750" target="_blank" rel="noopener">Jupyter Notebook在指定文件夹（位置）打开</a></p>
<p><a href="https://blog.csdn.net/lawme/article/details/51034543" target="_blank" rel="noopener">Jupyter Notebook 的快捷键</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>三星平板N8000刷机</title>
    <url>/2020/08/26/%E4%B8%89%E6%98%9F%E5%B9%B3%E6%9D%BFN8000%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>刷机包+工具如下：</p>
<p>CWMRecoveryGTN8000.tar +  lineage-14.1-20170116-UNOFFICIAL-n8000.zip</p>
<p>线刷宝（用以进入挖煤模式）+ Odin</p>
</blockquote>
<a id="more"></a>

<p>家里小朋友在上网课，想买个平板，唤起了我对三星平板的记忆，大概13年入手，不过一两年没开过机了。</p>
<p>好不容易返校，拿出平板，发现不错，还能充电，也能开机。里面乱七八糟都是些啥，还有人人，干脆恢复出厂设置吧。</p>
<p>问题就出在这里，恢复出厂设置后发现没有三星应用中心了，也不能更新，因为之前用了kingsroot。那似乎只能刷机了。</p>
<ol>
<li><p>开机键+电源上键进入recovery模式，有install from external storage的选项，但是不支持第三方ROM包。</p>
<p>强行刷第三方包，会出出现：</p>
<p>E:failed to verify whole-file signature<br>e:signature verification failed<br>installation aborted</p>
</li>
<li><p>要刷第三方ROM包，需要先刷第三方recovery包。</p>
<p>电源键+音量下键进入挖煤模式，使用Odin刷入第三方REC包，旧版选择PDA，新版选择AP，其他不要勾选，一些默认勾选的也要去掉，点击start，几秒钟就可以了。</p>
</li>
</ol>
<p><img src="http://www.galaxyclub.cn//Upload/IMAGES/18/0507/126b124121ee40feb9f95aa5bc78c040_650x0.png" alt="【技术】Odin中的术语BL、AP、CP、CSC是什么意思？"></p>
<table>
<thead>
<tr>
<th><strong>BL(Bootloader) **</strong>：**</th>
<th>代表 <strong>引导程序</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>AP (Application Processor or PDA)  **</strong>：**</td>
<td>表示<strong>Android系统</strong>（可能代表Android系统分区）; 在之前的Odin版本中，这被称为“PDA”</td>
</tr>
<tr>
<td><strong>CP(Core Processor**</strong>） ：**</td>
<td>** <strong>代表 **调制解调器</strong></td>
</tr>
<tr>
<td><strong>CSC(Co numer Software Customization) **</strong>：**</td>
<td>代表 <strong>消费者软件定制</strong>，它包含特定于该地区的软件包，运营商品牌和APN设置（就像不同的运营商的数据接入点名称不通）。</td>
</tr>
<tr>
<td><strong>PIT (Partition Information Table)  **</strong>：**</td>
<td>代表 <strong>分区信息表</strong>，如果你搞砸分区表，或者由于分区表布局的变化，你只需要用它就好了。</td>
</tr>
</tbody></table>
<p>但又遇到问题了：电源键+音量下键无法进入挖煤模式，不知道是否跟之前用第三方软件root过有关，并且我的板子的电源键也不太好用，事态似乎陷入了僵局，只能求助第三方刷机软件<a href="http://www.xianshuabao.com/features/?fromsite=bd_xsb" target="_blank" rel="noopener">线刷宝</a>。</p>
<p>进入挖煤模式后，ID:COM 变成蓝色（实际上，正常开机连接时，应该是蓝色，挖煤模式连接时应为黄色，可能还是之前root过得原因）</p>
<p>不需要付费模式，只需要借助工具箱进入挖煤模式即可！也可以通过线刷宝进入recovery模式（谁让我的电源键不好用呢）。</p>
<ol start="3">
<li>输入第三方ROM包</li>
</ol>
<p>将第三方包的zip文件放大存储卡中，卡刷，选择external card，这一步比较顺利。</p>
<p>因为一些帖子有反馈说无法联网，我没有遇到这个问题，顺利进入系统。但是无法调出键盘输入界面。</p>
<ol start="4">
<li>将平板变成显示器</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/81255397" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81255397</a></p>
<p><strong>Spacedesk</strong> 电脑和平板需要处于同一局域网下</p>
<p><strong>Splashtop Wired XDisplay</strong> 通过数据线连接，需要在google play上下载</p>
<p><strong>Twomon SE</strong></p>
<p><a href="https://www.splashtop.com/cn/wiredxdisplay](https://www.splashtop.com/cn/wiredxdisplay)" target="_blank" rel="noopener">https://www.splashtop.com/cn/wiredxdisplay](https://www.splashtop.com/cn/wiredxdisplay)</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>主要参考<a href="https://www.jianshu.com/p/182975bd9ee6" target="_blank" rel="noopener">简书</a>和<a href="https://blog.csdn.net/wulong710/article/details/91956773" target="_blank" rel="noopener">CSDN</a> 上的两个帖子。</p>
<p><a href="https://sspai.com/post/43338" target="_blank" rel="noopener">Android 玩机终极指南</a> 这个也值得一看。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>三星</tag>
        <tag>N8000</tag>
      </tags>
  </entry>
  <entry>
    <title>《Scikit-Learn与TensorFlow机器学习实用指南》</title>
    <url>/2020/08/25/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B/</url>
    <content><![CDATA[<p><a href="https://www.cntofu.com/book/27/docs/2.%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">https://www.cntofu.com/book/27/docs/2.一个完整的机器学习项目.md</a></p>
<p><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">https://github.com/ageron/handson-ml2</a></p>
<p><a href="https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88.md" target="_blank" rel="noopener">https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/</a></p>
<p><a href="https://www.jianshu.com/p/3470a6efbe8d" target="_blank" rel="noopener">https://www.jianshu.com/p/3470a6efbe8d</a></p>
<a id="more"></a>

<h2 id="《Scikit-Learn与TensorFlow机器学习实用指南》"><a href="#《Scikit-Learn与TensorFlow机器学习实用指南》" class="headerlink" title="《Scikit-Learn与TensorFlow机器学习实用指南》"></a>《Scikit-Learn与TensorFlow机器学习实用指南》</h2><h3 id="第01章-机器学习概览"><a href="#第01章-机器学习概览" class="headerlink" title="第01章 机器学习概览"></a>第01章 机器学习概览</h3><ol>
<li><p>os.makedirs(IMAGES_PATH, exist_ok=True)</p>
</li>
<li><p>pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True)</p>
<p>left_index和right_index：指定是否以索引为参考进行合并</p>
<p>​</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol>
<li>如何定义机器学习？</li>
</ol>
<blockquote>
<p>机器学习是通过编程让计算机从数据中进行学习的科学（和艺术）。</p>
<p><strong>更广义的概念：</strong></p>
<p>机器学习是让计算机具有学习的能力，无需进行明确编程。 —— 亚瑟·萨缪尔，1959</p>
<p><strong>工程性的概念：</strong></p>
<p>计算机程序利用经验 E 学习任务 T，性能是 P，如果针对任务 T 的性能 P 随着经验 E 不断增长，则称为机器学习。 —— 汤姆·米切尔，1997</p>
</blockquote>
<ol start="2">
<li>机器学习可以解决的四类问题？</li>
</ol>
<blockquote>
<p>分类，回归，聚类，降维</p>
<p>机器学习可以根据训练时监督的量和类型进行分类。主要有四类：监督学习、非监督学习、半监督学习和强化学习。</p>
</blockquote>
<ol start="3">
<li>什么是带标签的训练集？</li>
</ol>
<blockquote>
<p>在监督学习中，用来训练算法的训练数据包含了答案，称为标签。</p>
</blockquote>
<ol start="4">
<li>最常见的两个监督任务是什么？</li>
</ol>
<blockquote>
<ol>
<li>分类：例如垃圾邮件过滤器：用许多带有归类（垃圾邮件或普通邮件）的邮件样本进行训练，过滤器必须还能对新邮件进行分类。</li>
<li>回归：预测目标数值，例如给出一些特征（里程数、车龄、品牌等等）称作预测值，来预测一辆汽车的价格。。要训练这个系统，需要给出大量汽车样本，包括它们的预测值和标签（即，它们的价格）。</li>
</ol>
</blockquote>
<ol start="5">
<li>指出四个常见的非监督任务？</li>
</ol>
<blockquote>
<ol>
<li><strong>聚类算法</strong> ，检测相似访客的分组。假设有一份关于博客访客的大量数据，不告诉算法某个访客属于哪一类：它会自己找出关系，无需帮助。例如，算法可能注意到 40% 的访客是喜欢漫画书的男性，通常是晚上访问，20% 是科幻爱好者，他们是在周末访问等等。如果使用<strong>层次聚类分析</strong> ，它可能还会细分每个分组为更小的组。这可以帮助你为每个分组定位博文。</li>
<li><strong>可视化算法</strong> ：给算法大量复杂的且不加标签的数据，算法输出数据的2D或3D图像。算法会试图保留数据的结构（即尝试保留输入的独立聚类，避免在图像中重叠），这样就可以明白数据是如何组织起来的，也许还能发现隐藏的规律。</li>
<li><strong>降维</strong> ：降维的目的是简化数据、但是不能失去大部分信息。做法之一是合并若干相关的特征。例如，汽车的里程数与车龄高度相关，降维算法就会将它们合并成一个，表示汽车的磨损。这叫做<strong>特征提取</strong> 。</li>
<li><strong>异常检测（anomaly detection）</strong> ：例如，检测异常的信用卡转账以防欺诈，检测制造缺陷，或者在训练之前自动从训练数据集去除异常值。异常检测的系统使用正常值训练的，当它碰到一个新实例，它可以判断这个新实例是像正常值还是异常值。</li>
</ol>
</blockquote>
<ol start="6">
<li>要让一个机器人能在各种未知地形行走，你会采用什么机器学习算法？</li>
</ol>
<blockquote>
<p>强化学习：</p>
</blockquote>
<ol start="7">
<li>要对你的顾客进行分组，你会采用哪类算法？</li>
</ol>
<blockquote>
<p>非监督学习</p>
</blockquote>
<ol start="8">
<li>垃圾邮件检测是监督学习问题，还是非监督学习问题？</li>
</ol>
<blockquote>
<p>监督学习：因为有标签</p>
</blockquote>
<ol start="9">
<li>什么是在线学习系统？</li>
</ol>
<blockquote>
<p>从导入的数据流进行持续学习</p>
<p>在在线学习中，是用数据实例持续地进行训练，可以一次一个或一次几个实例（称为小批量）。每个学习步骤都很快且廉价，所以系统可以动态地学习收到的最新数据</p>
<p><img src="https://github.com/apachecn/hands-on-ml-zh/raw/master/images/chapter_1/1-13.png" alt="img"></p>
</blockquote>
<ol start="10">
<li>什么是核外学习？</li>
</ol>
<blockquote>
<p>在线学习算法也适用于在超大数据集（一台计算机不足以用于存储它）上训练系统（这称作核外学习，<em>out-of-core</em> learning）。算法每次只加载部分数据，用这些数据进行训练，然后重复这个过程，直到使用完所有数据</p>
</blockquote>
<ol start="11">
<li>什么学习算法是用相似度做预测？</li>
</ol>
<blockquote>
<p>基于实例学习：系统先用记忆学习案例，然后使用相似度测量推广到新的例子</p>
<p>例如，垃圾邮件检测器，不仅能标记和已知的垃圾邮件相同的邮件，也要能标记类似垃圾邮件的邮件。需要测量两封邮件的相似性。一个（简单的）相似度测量方法是统计两封邮件包含的相同单词的数量。如果一封邮件含有许多垃圾邮件中的词，就会被标记为垃圾邮件。</p>
</blockquote>
<ol start="12">
<li>模型参数和学习算法的超参数的区别是什么？</li>
</ol>
<blockquote>
<p>学习算法搜寻模型参数值，使代价函数最小</p>
<p>超参数（hyperparameter）是一个学习算法的参数（而不是模型的），控制正则化的度。</p>
</blockquote>
<ol start="13">
<li>基于模型学习的算法搜寻的是什么？最成功的策略是什么？基于模型学习如何做预测？</li>
</ol>
<blockquote>
<p>搜寻使得代价函数（测量线性模型的预测值和训练样本之间的距离差）最小的模型参数</p>
<p>线性回归算法</p>
<p>研究数据-选择模型-用训练数据进行训练（学习算法搜寻模型参数值，使得代价函数最小）-使用模型对新案例进行预测（这称作推断）</p>
</blockquote>
<ol start="14">
<li>机器学习的四个主要挑战是什么？</li>
</ol>
<blockquote>
<p>训练数据量不足</p>
<p>没有代表性的训练数据</p>
<p>低质量数据</p>
<p>不相关的特征</p>
<p>过拟合</p>
<p>欠拟合</p>
</blockquote>
<ol start="15">
<li>如果模型在训练集上表现好，但推广到新实例表现差，问题是什么？给出三个可能的解决方案。</li>
</ol>
<blockquote>
<p>过拟合：利用超参数正则化</p>
<p>不相关特征：</p>
<ul>
<li>特征选择：在所有存在的特征中选取最有用的特征进行训练。</li>
<li>特征提取：组合存在的特征，生成一个更有用的特征（如前面看到的，可以使用降维算法）。</li>
<li>收集新数据创建新特征。</li>
</ul>
<p>低质量数据：如果训练集中的错误、异常值和噪声（错误测量引入的）太多，系统检测出潜在规律的难度就会变大，性能就会降低。</p>
<ul>
<li>如果一些实例是明显的异常值，最好删掉它们或尝试手工修改错误；</li>
<li>如果一些实例缺少特征（比如，你的 5% 的顾客没有说明年龄），你必须决定是否忽略这个属性、忽略这些实例、填入缺失值（比如，年龄中位数），或者训练一个含有这个特征的模型和一个不含有这个特征的模型，等等。</li>
</ul>
</blockquote>
<ol start="16">
<li>什么是测试集，为什么要使用它？</li>
</ol>
<blockquote>
<p>测试集：用来训练模型的数据集</p>
</blockquote>
<ol start="17">
<li>验证集的目的是什么？</li>
</ol>
<blockquote>
<p>验证集：数据中分出来，对模型进行测试的数据集。</p>
<p>评估模型推广到新样本的效果（即对新样本的性能），可以将模型部署到生产环境，观察它的性能。这么做可以，但如果模型的性能很差，就会引起用户抱怨。更好的选项是将数据分成训练集和测试集。用训练集进行训练，用测试集进行测试。对新样本的错误率称作<strong>推广错误（或样本外错误）</strong> ，通过模型对测试集的评估，可以预估这个错误。这个值可以我们模型对新样本的性能。</p>
</blockquote>
<ol start="18">
<li>如果用测试集调节超参数，会发生什么？</li>
</ol>
<blockquote>
<p>过拟合</p>
<p>在测试集上多次测量了推广误差率，调整了模型和超参数，以使模型最适合这个集合。这意味着模型对新数据的性能不会高。</p>
</blockquote>
<ol start="19">
<li>什么是交叉验证，为什么它比验证集好？</li>
</ol>
<blockquote>
<p>交叉验证：训练集分成互补的子集，每个模型用不同的子集训练，再用剩下的子集验证。一旦确定模型类型和超参数，最终的模型使用这些超参数和全部的训练集进行训练，用测试集得到推广误差率。</p>
<p>而使用验证集：用训练集和多个超参数训练多个模型，选择在验证集上有最佳性能的模型和超参数。当对模型满意时，用测试集再做最后一次测试，以得到推广误差率的预估，会“浪费”过多训练数据在验证集上。</p>
</blockquote>
</li>
</ol>
<h3 id="第02章-一个完整的机器学习项目"><a href="#第02章-一个完整的机器学习项目" class="headerlink" title="第02章 一个完整的机器学习项目"></a>第02章 一个完整的机器学习项目</h3><p>[Python API：crc32函数 计算CRC校验值](<a href="https://b" target="_blank" rel="noopener">https://b</a></p>
<p><a href="https://blog.csdn.net/liuyu60305002/article/details/6307152" target="_blank" rel="noopener">模2运算</a></p>
<p><a href="https://blog.csdn.net/sparkliang/article/details/5671510" target="_blank" rel="noopener">CRC32算法详细推导</a></p>
<blockquote>
<p>crc32用于计算 <em>data</em> 的 CRC (A cyclic redundancy check 32，循环冗余校验) 值。计算的结果是一个 32 位的整数。本质是<strong>模2除法模2运算包括模2加、模2减、模2乘、模2除四种二进制运算，不考虑进位和借位）</strong>， 的余数，采用的除数不同，CRC的类型也就不一样。通常，CRC的除数用生成多项式来表示。</p>
<p>此算法没有加密强度，不应用于身份验证和数字签名。仅<strong>为验证数据的正确性</strong> ，不适合作为通用散列算法。</p>
<h4 id="特点：检错能力极强，开销小等"><a href="#特点：检错能力极强，开销小等" class="headerlink" title="特点：检错能力极强，开销小等"></a>特点：检错能力极强，开销小等</h4><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>CRC 算法是以 GF(2) 多项式算术为数学基础的， GF(2) 多项式中只有一个变量 x ，其系数也只有 0 和 1 ，比如：</p>
<p>​    1 <em>x^6 + 0</em>x^5 + 1<em>x^4 + 0</em>x^3 + 0<em>x^2 +1</em>x^1 + 1*x^0</p>
<p>​       = x^6 + x^4 + x + 1</p>
<p>加减运算不考虑进位和退位。说白了就是下面的运算规则：</p>
<p>​    0 + 0 = 0    0 - 0 = 0</p>
<p>​    0 + 1 = 1    0 - 1 = 1</p>
<p>​    1 + 0 = 1    1 - 0 = 1</p>
<p>​    1 + 1 = 0    1 - 1 = 0<br>看看这个规则，其实就是一个<strong>异或运算</strong> 。</p>
<p>每个生成多项式的系数只能是 0 或 1 ，因此可以把它转化为二进制形式表示， 比如 g(x)=x^4 + x + 1 ，那么 g(x) 对应的二进制形式就是 10011 ， 于是把 GF(2) 多项式的除法转换成了二进制形式，和普通除法没有区别，只是加减运算没有进位和退位。</p>
<p>比如基于上述规则计算 11010/1001 ，那么商是 11 ，余数就是 1。</p>
<h4 id="CRC-校验的基本过程"><a href="#CRC-校验的基本过程" class="headerlink" title="CRC 校验的基本过程"></a>CRC 校验的基本过程</h4><p>采用 CRC 校验时，发送方和接收方用同一个生成多项式 g(x) ， g(x) 是一个 GF(2) 多项式，并且 g(x) 的首位和最后一位的系数必须为 1 。</p>
<p>CRC 的处理方法是：发送方用发送数据的二进制多项式 t(x) 除以 g(x) ，得到余数 y(x) 作为 CRC 校验码。校验时，以计算的校正结果是否为 0 为据，判断数据帧是否出错。设生成多项式是 r 阶的（最高位是 x^r ）具体步骤如下面的描述。</p>
<p>发送方：</p>
<p>1 ）在发送的 m 位数据的二进制多项式 t(x) 后添加 r 个 0 ，扩张到 m+ r 位，以容纳 r 位的校验码，追加 0 后的二进制多项式为  T(x) ；</p>
<p>2 ）用 T(x) 除以生成多项式 g(x) ，得到 r 位的余数 y(x) ，它就是 CRC 校验码；</p>
<p>3 ）把 y(x) 追加到 t(x) 后面，此时的数据 s(x) 就是包含了 CRC 校验码的待发送字符串；由于 s(x) = t(x) y(x) ，因此 s(x) 肯定能被 g(x) 除尽。</p>
<p>接收方：</p>
<p>1 ）接收数据 n(x) ，这个 n(x) 就是包含了 CRC 校验码的 m+r 位数据；</p>
<p>2 ）计算 n(x) 除以 g(x) ，如果余数为 0 则表示传输过程没有错误，否则表示有错误。从 n(x) 去掉尾部的 r 位数据，得到的就是原始数据。</p>
<p>生成多项式不是随意选择的，以下是一些标准的 CRC 算法的生成多项式：</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>生成多项式</th>
<th>16 进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>CRC12</td>
<td>x^12 + x^11 + x^3 + x^2 + x + 1</td>
<td>0x80F</td>
</tr>
<tr>
<td>CRC16</td>
<td>x^16 + x^15 + x^2 + 1</td>
<td>0x8005</td>
</tr>
<tr>
<td>CRC16-CCITT</td>
<td>x^16 + x^12 + x^5 + 1</td>
<td>0x1021</td>
</tr>
<tr>
<td>CRC32</td>
<td>x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1</td>
<td>0x04C11DB7</td>
</tr>
</tbody></table>
<p>在python 3.0 之后: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <strong>crc32(data) &amp; 0xffffffff</strong>。</p>
</blockquote>
<p><strong>问题：</strong> </p>
<p>使用本章的房产数据集：</p>
<ol>
<li>尝试一个支持向量机回归器（<code>sklearn.svm.SVR</code>），使用多个超参数，比如<code>kernel=&quot;linear&quot;</code>（多个超参数<code>C</code>值）。现在不用担心这些超参数是什么含义。最佳的<code>SVR</code>预测表现如何？</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line">&gt;svm_reg = SVR(kernel=<span class="string">"linear"</span>)</span><br><span class="line">&gt;svm_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">&gt;housing_predictions = svm_reg.predict(housing_prepared)</span><br><span class="line">&gt;svm_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">&gt;svm_rmse = np.sqrt(svm_mse)</span><br><span class="line">&gt;svm_rmse <span class="comment"># output: 111094.6308539982</span></span><br></pre></td></tr></table></figure>

<p>结果不好。</p>
</blockquote>
<ol start="2">
<li>尝试用<code>RandomizedSearchCV</code>替换<code>GridSearchCV</code>。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line">&gt;<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">&gt;param_distribs = &#123;</span><br><span class="line">       <span class="string">'n_estimators'</span>: randint(low=<span class="number">1</span>, high=<span class="number">200</span>),</span><br><span class="line">       <span class="string">'max_features'</span>: randint(low=<span class="number">1</span>, high=<span class="number">8</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;forest_reg = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search = RandomizedSearchCV(forest_reg, param_distributions=param_distribs,</span><br><span class="line">                               n_iter=<span class="number">10</span>, cv=<span class="number">5</span>, scoring=<span class="string">'neg_mean_squared_error'</span>, random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>尝试在准备流水线中添加一个只选择最重要属性的转换器。</li>
</ol>
<blockquote>
<p>​</p>
</blockquote>
<ol start="4">
<li>尝试创建一个单独的可以完成数据准备和最终预测的流水线。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;full_pipeline_with_predictor = Pipeline([</span><br><span class="line">       (<span class="string">"preparation"</span>, full_pipeline),</span><br><span class="line">       (<span class="string">"linear"</span>, LinearRegression())</span><br><span class="line">   ])</span><br><span class="line"></span><br><span class="line">&gt;full_pipeline_with_predictor.fit(housing, housing_labels)</span><br><span class="line">&gt;full_pipeline_with_predictor.predict(some_data)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="5">
<li>使用<code>GridSearchCV</code>自动探索一些准备过程中的候选项。</li>
</ol>
<h3 id="第03章-分类"><a href="#第03章-分类" class="headerlink" title="第03章 分类"></a>第03章 分类</h3><p><a href="https://blog.csdn.net/weixin_38145317/article/details/79650188" target="_blank" rel="noopener">SVM、SVC、SVR</a> </p>
<p>####练习</p>
<ol>
<li><p>尝试在 MNIST 数据集上建立一个分类器，使它在测试集上的精度超过 97%。提示：<code>KNeighborsClassifier</code>非常适合这个任务。你只需要找出一个好的超参数值（试一下对权重和超参数<code>n_neighbors</code>进行网格搜索）。</p>
<p>​</p>
</li>
<li><p>写一个函数可以是 MNIST 中的图像任意方向移动（上下左右）一个像素。然后，对训练集上的每张图片，复制四个移动后的副本（每个方向一个副本），把它们加到训练集当中去。最后在扩展后的训练集上训练你最好的模型，并且在测试集上测量它的精度。你应该会观察到你的模型会有更好的表现。这种人工扩大训练集的方法叫做数据增强，或者训练集扩张。</p>
<p>​</p>
</li>
<li><p>拿 Titanic 数据集去捣鼓一番。开始这个项目有一个很棒的平台：Kaggle</p>
<p>​</p>
</li>
<li><p>建立一个垃圾邮件分类器（这是一个更有挑战性的练习）：</p>
</li>
</ol>
<ul>
<li>下载垃圾邮件和非垃圾邮件的样例数据。地址是<a href="https://spamassassin.apache.org/publiccorpus/" target="_blank" rel="noopener">Apache SpamAssassin 的公共数据集</a></li>
<li>解压这些数据集，并且熟悉它的数据格式。</li>
<li>将数据集分成训练集和测试集</li>
<li>写一个数据准备的流水线，将每一封邮件转换为特征向量。你的流水线应该将一封邮件转换为一个稀疏向量，对于所有可能的词，这个向量标志哪个词出现了，哪个词没有出现。举例子，如果所有邮件只包含了<code>&quot;Hello&quot;,&quot;How&quot;,&quot;are&quot;, &quot;you&quot;</code>这四个词，那么一封邮件（内容是：<code>&quot;Hello you Hello Hello you&quot;</code>）将会被转换为向量<code>[1, 0, 0, 1]</code>(意思是：<code>&quot;Hello&quot;</code>出现，<code>&quot;How&quot;</code>不出现，<code>&quot;are&quot;</code>不出现，<code>&quot;you&quot;</code>出现)，或者<code>[3, 0, 0, 2]</code>，如果你想数出每个单词出现的次数。</li>
<li>你也许想给你的流水线增加超参数，控制是否剥过邮件头、将邮件转换为小写、去除标点符号、将所有 URL 替换成<code>&quot;URL&quot;</code>，将所有数字替换成<code>&quot;NUMBER&quot;</code>，或者甚至提取词干（比如，截断词尾。有现成的 Python 库可以做到这点）。</li>
<li>然后 尝试几个不同的分类器，看看你可否建立一个很棒的垃圾邮件分类器，同时有着高召回率和高准确率。</li>
</ul>
<h3 id="第04章-训练模型"><a href="#第04章-训练模型" class="headerlink" title="第04章 训练模型"></a>第04章 训练模型</h3><h4 id="正态方程"><a href="#正态方程" class="headerlink" title="正态方程"></a><strong>正态方程</strong></h4><p>最小化损失函数 $\hat{\theta} =   (X^T \cdot X)^{-1} \cdot X^T \cdot y $</p>
<p>复杂度：需要计算$X^T\cdot X$ 的逆矩阵，是一个n*n的矩阵，运算复杂度大约在$O(n^{24})$ 到$O(n^{3})$之间。</p>
<p>可以numpy直接求解，也可以使用sklearn：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X, y)</span><br><span class="line">lin_reg.intercept_, lin_reg.coef_</span><br></pre></td></tr></table></figure>

<p><code>LinearRegression类基于numpy.linalg.lstsq （least squares）</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=<span class="number">1e-6</span>)</span><br><span class="line">theta_best_svd</span><br></pre></td></tr></table></figure>

<p>#####pseudoinverse (Moore-Penrose inverse)</p>
<p>该函数求解的是伪逆矩阵（pseudoinverse），即广义矩阵。其中最著名的伪逆矩阵为摩尔－彭若斯广义逆 A+（Moore–Penrose pseudoinverse)，常应用于求非一致线性方程组的最小范数最小二乘解（最小二乘法），并使得解的形式变得简单。矩阵的摩尔－彭若斯广义逆在实数域和复数域上都是唯一的，并且可以通过奇异值分解求得。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.pinv(X_b).dot(y)</span><br></pre></td></tr></table></figure>

<p>满足摩尔-彭若斯条件的矩阵G称为矩阵A的摩尔－彭若斯广义逆矩阵，记作A+：</p>
<p><img src="https://img-blog.csdn.net/20170824103329707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="条件"></p>
<p>从摩尔－彭若斯条件出发，彭若斯推导出了摩尔－彭若斯广义逆的一些性质：<br><img src="https://img-blog.csdn.net/20170824103423352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p> 参考：<a href="https://blog.csdn.net/zealfory/article/details/77526815" target="_blank" rel="noopener">https://blog.csdn.net/zealfory/article/details/77526815</a></p>
<h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>超参数学习率的值决定了步长的大小。如果学习率太小，必须经过多次迭代，算法才能收敛，这是非常耗时的，如果学习率太大，你可能使算法发散，函数值变得越来越大，永远不可能找到一个好的答案。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-4.PNG" alt="学习率过小"></p>
<center>学习率过小</center>

<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-5.PNG" alt="img"></p>
<center>学习率过大</center>

<p><strong>两个主要挑战</strong></p>
<ol>
<li>收敛到局部最小值</li>
</ol>
<p>当使用梯度下降的时候，应该确保所有的特征有着相近的尺度范围（例如：使用 Scikit Learn 的 <code>StandardScaler</code>类），否则它将需要很长的时间才能够收敛。</p>
<h4 id="batch-GD"><a href="#batch-GD" class="headerlink" title="batch-GD"></a>batch-GD</h4><p>使用梯度下降的过程中，需要计算每一个 $\theta_j$ 下损失函数的梯度，即计算关于$\theta_j$ 的损失函数的偏导数，记为： </p>
<p>$$\frac{\partial}{\partial \theta_j} MSE(\theta)=\frac{2}{m}\sum_{i=1}^{m}({\theta^T\cdot x^{(i)}-y^{(i)})x_j^{}(i)}$$</p>
<p>写成矩阵的形式：</p>
<p>$$\nabla_\theta MSE(\theta)=\left( \begin{array}{c} \frac{\partial}{\partial \theta_0} MSE(\theta)\\frac{\partial}{\partial \theta_1} MSE(\theta)\…\\frac{\partial}{\partial \theta_n} MSE(\theta) \end{array} \right)=\frac {2}{m} X^T\cdot (X\cdot \theta-y)$$</p>
<blockquote>
<p>在这个方程中每一步计算时都包含了整个训练集$X$，这也是为什么这个算法称为<strong>批量梯度下降</strong>：每一次训练过程都使用所有的的训练数据。因此，在大数据集上，其会变得相当的慢。然而，梯度下降的运算规模和特征的数量成正比。训练一个数千数量特征的线性回归模型使用梯度下降要比使用正态方程快的多。</p>
</blockquote>
<p>梯度下降的步长：</p>
<p>$$\theta^{(next step)}=\theta-\eta\nabla_\theta MSE(\theta)$$</p>
<p>$\eta$ 为学习率</p>
<p>为了找到一个好的学习率，可以使用网格搜索，设置一个<strong>迭代次数</strong>。设置一个非常大的迭代次数，但是当梯度向量变得非常小（容差 $\epsilon$ ）的时候，结束迭代。</p>
<blockquote>
<p>收敛速率：</p>
<p>当损失函数是凸函数，且斜率不能突变（就像均方差损失函数那样），则它的批量梯度下降算法固定学习率之后，收敛速率是 $O(\frac{1}{iterations})$。换句话说，如果将容差 $\epsilon$ 缩小 10 倍（这样可以得到一个更精确的结果），算法的迭代次数大约会变成原来的 10 倍。</p>
</blockquote>
<h4 id="stochastic-gradient-descent"><a href="#stochastic-gradient-descent" class="headerlink" title="stochastic gradient descent"></a>stochastic gradient descent</h4><p>批量梯度下降的最要问题是计算每一步的梯度时都需要使用整个训练集，这导致在规模较大的数据集上，其会变得非常的慢。</p>
<p>而随机梯度下降，每一步的梯度计算只随机选取训练集中的一个样本。由于每一次迭代，只需要在内存中有一个实例，算法非常快，这使随机梯度算法可以在大规模训练集上使用。</p>
<p>另一方面，由于其随机性，SGD呈现出更多的不规律性：到达最小值不是平缓的下降，损失函数会忽高忽低，只在大体上呈下降趋势。随着时间的推移，非常的靠近最小值，但不会停止在一个值上，而是一直在这个值附近摆动。因此，算法停止时，最后的参数不是最优值。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-9.PNG" alt="img"></p>
<p>当损失函数很不规则时，随机梯度下降算法能够跳过局部最小值。因此，随机梯度下降在寻找全局最小值上比批量梯度下降表现要好。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-6.PNG" alt="img"></p>
<p>虽然随机性可以很好的跳过局部最优值，但同时它却不能达到最小值。解决这个难题的一个办法是<strong>逐渐降低学习率</strong>。</p>
<p>开始时，走的每一步较大（有助于快速前进同时跳过局部最小值），然后变得越来越小，从而使算法到达全局最小值。，这个过程被称为<strong>模拟退火</strong>。</p>
<p>决定每次迭代的学习率的函数称为<code>learning schedule</code>。 如果学习速度降低得过快，可能会陷入局部最小值，甚至在到达最小值的半路就停止了。 如果学习速度降低得太慢，可能在最小值的附近长时间摆动，同时如果过早停止训练，最终只会出现次优解。</p>
<h4 id="mini-batch-GD"><a href="#mini-batch-GD" class="headerlink" title="mini-batch GD"></a>mini-batch GD</h4><p>在迭代的每一步，小批量梯度下降使用一个随机的小型实例集。与随机梯度相比主要优点在于可以通过矩阵运算的硬件优化得到一个较好的训练表现。</p>
<p>小批量梯度下降在参数空间上的表现比随机梯度下降要好的多，尤其在有大量的小型实例集时。作为结果，小批量梯度下降会比随机梯度更靠近最小值。但是，另一方面，它有可能陷在局部最小值中（在遇到局部最小值问题的情况下，和我们之前看到的线性回归不一样）。 </p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-11.PNG" alt="img"></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E8%A1%A84-1.PNG" alt="img"></p>
<h4 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h4><p>对每个特征进行加权后作为新的特征，然后训练一个线性模型在这个扩展的特征集。 这种方法称为多项式回归。</p>
<p><code>from sklearn.preprocessing import PolynomialFeatures</code></p>
<p>当存在多个特征时，多项式回归能够找出特征之间的关系（这是普通线性回归模型无法做到的）。 这是因为<code>LinearRegression</code>会自动添加当前阶数下特征的所有组合。例如，如果有两个特征 $a,b$，使用 3 阶（<code>degree=3</code>）的<code>LinearRegression</code>时，不仅有 $a^3, a^2, b^3, b^2$，同时也会有它们的其他组合项 $ab, ab^2, a^2b$</p>
<p><code>PolynomialFeatures(degree=d)</code>把一个包含$n$个特征的数组转换为一个包含 $\frac{(n+d)!}{d!n!}$特征的数组。小心大量特征的组合爆炸！</p>
<h4 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h4><p><strong>如何估计一个模型的泛化能力</strong> </p>
<ol>
<li>使用交叉验证。若模型在训练集上表现良好，通过交叉验证指标却得出其泛化能力很差，模型过拟合。如果在这两方面都表现不好，那么欠拟合。这种方法可以告诉我们模型是太复杂还是太简单了。</li>
<li>观察学习曲线：画出模型在训练集上的表现，同时画出以训练集规模为自变量的训练集函数。为了得到图像，需要在训练集的不同规模子集上进行多次训练。</li>
</ol>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-15.PNG" alt="img"></p>
<center>欠拟合</center>

<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-16.PNG" alt="img"></p>
<center>过拟合</center>

<blockquote>
<p>偏差和方差的权衡</p>
<p>在统计和机器学习领域有个重要的理论：一个模型的<strong>泛化误差</strong>由三个不同误差的和决定：</p>
<ul>
<li>偏差：泛化误差的这部分误差是由于错误的假设决定的。例如实际是一个二次模型，你却假设了一个线性模型。一个高偏差的模型最容易出现欠拟合。</li>
<li>方差：这部分误差是由于模型对训练数据的微小变化较为敏感，一个多自由度的模型更容易有高的方差（例如一个高阶多项式模型），因此会导致模型过拟合。</li>
<li>不可约误差：这部分误差是由于数据本身的噪声决定的。降低这部分误差的唯一方法就是进行数据清洗（例如：修复数据源，修复坏的传感器，识别和剔除异常值）。</li>
</ul>
</blockquote>
<h4 id="线性模型的正则化"><a href="#线性模型的正则化" class="headerlink" title="线性模型的正则化"></a>线性模型的正则化</h4><p>正则化这个模型（即限制它）：模型有越少的自由度，就越难以拟合数据。例如，正则化一个多项式模型，一个简单的方法就是减少多项式的阶数。</p>
<p>对于一个线性模型，正则化的典型实现就是约束模型中参数的权重。</p>
<h5 id="岭回归（Ridge）"><a href="#岭回归（Ridge）" class="headerlink" title="岭回归（Ridge）"></a>岭回归（Ridge）</h5><p>岭回归（也称为 Tikhonov 正则化）是线性回归的正则化版：在损失函数上直接加上一个正则项。这使得学习算法不仅能够拟合数据，而且能够使模型的参数权重尽量的小。注意到这个正则项只有在训练过程中才会被加到损失函数。当得到完成训练的模型后，我们应该使用没有正则化的测量方法去评价模型的表现。</p>
<blockquote>
<p>提示</p>
<p>一般情况下，训练过程使用的损失函数和测试过程使用的评价函数是不一样的。除了正则化，还有一个不同：训练时的损失函数应该在优化过程中易于求导，而在测试过程中，评价函数更应该接近最后的客观表现。一个好的例子：在分类训练中我们使用对数损失（马上我们会讨论它）作为损失函数，但是我们却使用精确率/召回率来作为它的评价函数。</p>
</blockquote>
<p>岭回归损失函数：</p>
<p>$J(\theta)=MSE(\theta)+\alpha \frac{1}{2} \sum_{i=1}^{n}{\theta _i ^2}$</p>
<p>$\theta_0$是没有被正则化的，所以累加从i=1开始，而不是i=0开始。如果定义w作为特征的权重向量（$\theta_1$到$\theta_n$），则正则项可以简写成$\frac{1}{2}(||w||_2)^2$ ，$||\cdot||_2$表示$l_2$范数。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-17.PNG" alt="img"></p>
<p>######封闭方程的解</p>
<p>$$\hat \theta=(X^T\cdot X+\alpha A)^{-1}\cdot X^T\cdot y$$</p>
<p>A是一个除了左上角有一个0的nxn的单位矩阵，表示偏差$\theta_0$不被正则化。</p>
<h6 id="随机梯度下降法求解"><a href="#随机梯度下降法求解" class="headerlink" title="随机梯度下降法求解"></a>随机梯度下降法求解</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sgd_reg = SGDRegressor(penalty=<span class="string">"l2"</span>)</span><br><span class="line"><span class="comment"># penalty参数指的是正则项的惩罚类型。指定“l2”表明你要在损失函数上添加一项：权重向量 l2 范数平方的一半，这就是简单的岭回归。</span></span><br></pre></td></tr></table></figure>

<h5 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h5><p>Lasso 回归（也称 Least Absolute Shrinkage，或者 Selection Operator Regression）是另一种正则化版的线性回归：就像岭回归那样，它也在损失函数上添加了一个正则化项，但是它使用权重向量的$l_1$ 范数而不是权重向量 $l_2$范数平方的一半。</p>
<p>$J(\theta)=MSE(\theta)+\alpha \sum_{i=1}^{n}{|\theta _i|}$</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-18.PNG" alt="img"></p>
<p>Lasso 回归的一个重要特征是它倾向于完全消除最不重要的特征的权重（即将它们设置为零）。例如，右图中的虚线所示$\alpha=10^{-7}$，曲线看起来像一条二次曲线，而且几乎是线性的，这是因为所有的高阶多项特征都被设置为零。换句话说，Lasso回归自动的进行特征选择同时输出一个稀疏模型（即，具有很少的非零权重）。</p>
<p>Lasso 回归子梯度向量:</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-93eea6b5c197bbc8d7be8b4c14e9f8f3.gif" alt="g(\theta,J)=\nabla_{\theta}MSE(\theta)+ \alpha{\left(\begin{matrix} sign(\theta_1)\\ sign(\theta_2)\\ \vdots \\ sign(\theta_n)\\ \end{matrix}\right)}\ where\ sign(\theta_i)= \begin{cases} -1, &amp;\theta_i&lt;0 \\ 0, &amp;\theta_i=0 \\ +1,&amp;\theta_i&gt;0 \\ \end{cases}"></p>
<h5 id="弹性网络（ElasticNet）"><a href="#弹性网络（ElasticNet）" class="headerlink" title="弹性网络（ElasticNet）"></a>弹性网络（ElasticNet）</h5><p>弹性网络介于 Ridge 回归和 Lasso 回归之间。它的正则项是 Ridge 回归和 Lasso 回归正则项的简单混合，同时你可以控制它们的混合率 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-4b43b0aee35624cd95b910189b3dc231.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-4b43b0aee35624cd95b910189b3dc231.gif" alt="r"></a></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-e4da079f692fe35778bbdf1fdf120d99.gif" alt="J(\theta)=MSE(\theta)+r\alpha\sum\limits_{i=1}n\left|\theta_i \right|+\frac{1-r}{2}\alpha\sum\limits_{i=1}n\theta_i^2"></p>
<p>#####早起停止法（Early Stopping）</p>
<p>对于迭代学习算法，有一种非常特殊的正则化方法，就像梯度下降在验证错误达到最小值时立即停止训练那样。我们称为早期停止法。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-20.PNG" alt="img"></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>词云</title>
    <url>/2020/08/18/%E8%AF%8D%E4%BA%91/</url>
    <content><![CDATA[<p><a href="https://python123.io/tutorials/word_cloud/" target="_blank" rel="noopener">python123你不知道的词云</a></p>
<a id="more"></a>

<p>关键问题：<strong>如何做到词语之间紧密排布但又没有重叠</strong></p>
<h3 id="integral-image积分图"><a href="#integral-image积分图" class="headerlink" title="integral_image积分图"></a>integral_image积分图</h3><p>重叠检测方法：</p>
<p>词云布局方法：贪心策略</p>
<p><strong>矩形检测的积分图算法似乎不能很好的支持文字的旋转</strong></p>
<h3 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h3><p><strong>层次边界框</strong>（Hierarchical bounding boxes）来快速实现两个词语间的重叠检测。本质上是一棵记录空间信息的四叉树。</p>
<p>四叉树的构建并不困难，将图片横纵各切一刀，平均分割为「左上、左下、右上、右下」四个区域，如果某个区域中有内容（此时可以用积分图算法判断），那么继续将这个区域分割为四个部分，直到区域的大小小于某个值。</p>
<p>四叉树每深一层，对形状的描述就越精确，每一次分隔，都能排除一些空白矩形区域，剩下的有像素的区域，都记录到了树中。</p>
<p>之后两颗四叉树逐层判断。</p>
<h3 id="矩形螺旋布局"><a href="#矩形螺旋布局" class="headerlink" title="矩形螺旋布局"></a>矩形螺旋布局</h3><p>一种贪心布局策略，所有的单词紧密放置在图中心的螺旋形状上。每个单词都从螺旋的中心位置开始检测，如果不能放置，就移动到螺旋的下一个位置。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>一种策略的想法来源于四叉树。先把图像分割为多个矩形区域，比如 800×600 的图片，分割为 48（8×6）个区域，每个区域长宽都是 100 像素。布局每个单词后，就将这个单词添加到对应的区域中，这样在布局一个新的单词时，只要根据单词大概的大小和放置的位置，在有限的几个区域中进行重叠检测，大幅降低了需要进行重叠检测的次数。</p>
<p>第二种策略更多来源于经验。假如要放置数十个大小差不多的单词，第一个单词检测了螺旋上的 200 个坐标后，找到一个放置位置，那么下一个单词就跳过这 200 个坐标（因为大概率重叠），在第 300 个坐标上放置，下一个单词从第 300 个坐标开始……如果检测到了图片边界未找到可以放置的坐标，那么回到初始位置重新寻找。</p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p><a href="https://github.com/TommyZihao/zihaowordcloud" target="_blank" rel="noopener">同济子豪兄在github上的词云可视化教程（wordcloud）</a></p>
<p>在线词云生成网站：</p>
<p><a href="http://www.yciyun.com/" target="_blank" rel="noopener">易词云</a></p>
<p><a href="http://www.picdata.cn/picdata/index.php" target="_blank" rel="noopener">图悦</a></p>
<p><a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP</a></p>
<p><a href="https://www.jianshu.com/p/615c9d285c54" target="_blank" rel="noopener">https://www.jianshu.com/p/615c9d285c54</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>wordcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>《利用Python进行数据分析》学习</title>
    <url>/2020/08/23/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>简书： <a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">https://www.jianshu.com/p/04d180d90a3f</a></p>
<p>github： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fiamseancheney%2Fpython_for_data_analysis_2nd_chinese_version" target="_blank" rel="noopener">https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version</a></p>
<p>gitbook： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseancheney.gitbook.io%2Fpython-for-data-analysis-2nd%2F" target="_blank" rel="noopener">https://seancheney.gitbook.io/python-for-data-analysis-2nd/</a></p>
<h2 id="第2章-Python语法基础，IPython和Jupyter-Notebooks"><a href="#第2章-Python语法基础，IPython和Jupyter-Notebooks" class="headerlink" title="第2章 Python语法基础，IPython和Jupyter Notebooks"></a>第2章 Python语法基础，IPython和Jupyter Notebooks</h2><h3 id="IPython键盘快捷键"><a href="#IPython键盘快捷键" class="headerlink" title="IPython键盘快捷键"></a>IPython键盘快捷键</h3><a id="more"></a>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e179f5ea00e50691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="img"></p>
<h3 id="IPython魔术命令"><a href="#IPython魔术命令" class="headerlink" title="IPython魔术命令"></a>IPython魔术命令</h3><p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。</p>
<p>line magic %</p>
<p>cell magic %%</p>
<p><code>%timeit</code>可以测量任何Python语句的执行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">20.9</span> µs per loop</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c72b11add9b8ccf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp" alt="img"></p>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>IPython中集成了数据可视化和其它用户界面库，比如matplotlib。</p>
<p><code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。</p>
<p>在JUpyter中，命令有所不同：<code>%matplotlib inline</code></p>
<h3 id="Python语法基础"><a href="#Python语法基础" class="headerlink" title="Python语法基础"></a>Python语法基础</h3><h4 id="使用缩进"><a href="#使用缩进" class="headerlink" title="使用缩进"></a>使用缩进</h4><p>建议使用四个空格作为默认的缩进，可以使用tab代替四个空格。</p>
<h4 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h4><h4 id="位置和关键词参数"><a href="#位置和关键词参数" class="headerlink" title="位置和关键词参数"></a>位置和关键词参数</h4><p><code>result = f(a, b, c, d=5, e=&#39;foo&#39;)</code></p>
<h4 id="变量和参数传递："><a href="#变量和参数传递：" class="headerlink" title="变量和参数传递："></a>变量和参数传递：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3e3a8c6b9c5040fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/892/format/webp" alt="img"></p>
<p>在Python中，a和b实际上是同一个对象.赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
<p>将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。</p>
<h4 id="强类型化语言"><a href="#强类型化语言" class="headerlink" title="强类型化语言"></a>强类型化语言</h4><p><code>&#39;5&#39; + 5</code> 会报错，即每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: a = <span class="number">4.5</span></span><br><span class="line">In [<span class="number">18</span>]: b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># String formatting, to be visited later</span></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'a is &#123;0&#125;, b is &#123;1&#125;'</span>.format(type(a), type(b)))</span><br><span class="line">a is &lt;class 'float'&gt;, b is &lt;class 'int'&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a / b</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">2.25</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>isinstance</code>函数检查对象是某个类型的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">isinstance(a, int) <span class="comment">#检查对象是否是某个类型的实例</span></span><br><span class="line">isinstance(a, (int, float)) <span class="comment">#检查对象的类型是否在元组中</span></span><br></pre></td></tr></table></figure>

<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）</p>
<p>可以用<code>obj.attribute_name</code>访问属性和方法，也可以用<code>getattr</code>函数，通过名字访问属性和方法。</p>
<h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。</p>
<p>通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isiterable</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        iter(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>可以用这个功能编写可以接受多种输入类型的函数。例如编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。先检验对象是否是列表（或是NUmPy数组），如果不是，将其转变成列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure>

<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法，<code>is not</code>可以判断两个对象是不同的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: c = list(a) <span class="comment"># 因为list总是创建一个新的Python列表（即复制）</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br><span class="line">       </span><br><span class="line">In [<span class="number">40</span>]: a == c</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9fb5f25b33166acf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt="img"></p>
<h4 id="可变与不可变对象"><a href="#可变与不可变对象" class="headerlink" title="可变与不可变对象"></a>可变与不可变对象</h4><p>Python中的大多数对象，如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的，意味着这些对象或包含的值可以被修改。其它例如<strong>字符串和元组</strong> ，是不可变的。</p>
<h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型。</p>
<p>日期和时间处理会是由标准库的<code>datetime</code>模块提供的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-27a30ac3e7d262a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp" alt="img"></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p>Python的主要数值类型是<code>int</code>和<code>float</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>反斜杠是转义字符，意思是它被用来表示特殊字符。</p>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，可以在字符串前面加一个r，表明字符就是它自身。</p>
<p>字符串的模板化或格式化：</p>
<ol>
<li><p><code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: template = <span class="string">'&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;'</span></span><br><span class="line">In [<span class="number">75</span>]: template.format(<span class="number">4.5560</span>, <span class="string">'Argentine Pesos'</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">'4.56 Argentine Pesos are worth US$1'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="字节和Unicode"><a href="#字节和Unicode" class="headerlink" title="字节和Unicode"></a>字节和Unicode</h4><p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。</p>
<p>可以用<code>encode</code>将Unicode字符串编码为UTF-8，<code>decode</code> 将UTF-8解码为Unicode编码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: val = <span class="string">"español"</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: val</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">'español'</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">78</span>]: val_utf8 = val.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">b'espa\xc3\xb1ol'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: type(val_utf8)</span><br><span class="line">Out[<span class="number">80</span>]: bytes</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: val_utf8.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">Out[<span class="number">81</span>]: <span class="string">'español'</span></span><br></pre></td></tr></table></figure>

<p><strong>可以在字节文本前加上b</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: bytes_val = <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: decoded = bytes_val.decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: decoded  <span class="comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">'this is bytes'</span></span><br></pre></td></tr></table></figure>

<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None，None也常常作为函数的默认参数。</p>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: dt.day</span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="number">105</span>]: <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="number">106</span>]: datetime.date(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="number">107</span>]: datetime.time(<span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: dt.strftime(<span class="string">'%m/%d/%Y %H:%M'</span>)</span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'10/29/2011 20:30'</span></span><br></pre></td></tr></table></figure>

<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: datetime.strptime(<span class="string">'20091031'</span>, <span class="string">'%Y%m%d'</span>)</span><br><span class="line">Out[<span class="number">109</span>]: datetime.datetime(<span class="number">2009</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-100f9a20c1536553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repalce进行替换</span></span><br><span class="line">In [<span class="number">110</span>]: dt.replace(minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">110</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 两个datetime对象的差会产生一个datetime.timedelta类型：</span></span><br><span class="line">In [<span class="number">111</span>]: dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line">In [<span class="number">112</span>]: delta = dt2 - dt</span><br><span class="line">In [<span class="number">113</span>]: delta</span><br><span class="line">Out[<span class="number">113</span>]: datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>) <span class="comment"># 17天、7179秒</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: type(delta)</span><br><span class="line">Out[<span class="number">114</span>]: datetime.timedelta</span><br><span class="line"><span class="comment"># 可以将timedelta添加到datetime，产生一个新的偏移datetime </span></span><br><span class="line">In [<span class="number">115</span>]: dt</span><br><span class="line">Out[<span class="number">115</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="number">116</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><h5 id="if语句："><a href="#if语句：" class="headerlink" title="if语句："></a>if语句：</h5><p>if elif else</p>
<h5 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h5><p>可以用continue使for循环提前，跳过剩下的部分；可以用<code>break</code>跳出for循环，break只中断for循环的最内层，其余的for循环仍会运行。</p>
<h5 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h5><h5 id="pass："><a href="#pass：" class="headerlink" title="pass："></a>pass：</h5><p>Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass。</p>
<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p>Python中的三元表达式可以将if-else语句放到一行里，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>

<h2 id="第3章-Python的数据结构、函数和文件"><a href="#第3章-Python的数据结构、函数和文件" class="headerlink" title="第3章 Python的数据结构、函数和文件"></a>第3章 Python的数据结构、函数和文件</h2><h3 id="数据结构和序列"><a href="#数据结构和序列" class="headerlink" title="数据结构和序列"></a>数据结构和序列</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是一个固定长度，不可改变的Python序列对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组</span></span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="comment"># 当用复杂的表达式定义元组，最好将值放到圆括号内</span></span><br><span class="line">nested_tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 用tuple可以将任意序列或迭代器转换成元组</span></span><br><span class="line">tuple([<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>]) <span class="comment"># (4, 0, 2)</span></span><br><span class="line">tup = tuple(<span class="string">'string'</span>) <span class="comment"># ('s', 't', 'r', 'i', 'n', 'g')</span></span><br><span class="line"><span class="comment"># 可以用方括号访问元组中的元素，序列是从0开始</span></span><br><span class="line">tup[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改</span></span><br><span class="line">tup = tuple([<span class="string">'foo'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="literal">True</span>])</span><br><span class="line">tup[<span class="number">2</span>] = <span class="literal">False</span>  <span class="comment"># 会报错</span></span><br><span class="line"><span class="comment"># 如果元组中的某个对象是可变的，比如列表，可以在原位进行修改</span></span><br><span class="line">tup[<span class="number">1</span>].append(<span class="number">3</span>) <span class="comment"># ('foo', [1, 2, 3], True)</span></span><br><span class="line"><span class="comment"># 可以用加号运算符将元组串联起来</span></span><br><span class="line">(<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>) + (<span class="number">6</span>, <span class="number">0</span>) + (<span class="string">'bar'</span>,) <span class="comment"># (4, None, 'foo', 6, 0, 'bar')</span></span><br><span class="line"><span class="comment"># 元组乘以一个整数，像列表一样，会将几个元组的复制串联起来</span></span><br><span class="line">(<span class="string">'foo'</span>, <span class="string">'bar'</span>) * <span class="number">4</span> <span class="comment"># ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')</span></span><br><span class="line"><span class="comment"># 对象本身并没有被复制，只是引用了它</span></span><br></pre></td></tr></table></figure>

<h5 id="拆分元组"><a href="#拆分元组" class="headerlink" title="拆分元组"></a>拆分元组</h5><p>将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">a,b,c = tup</span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">a, b, (c, d) = tup</span><br><span class="line"><span class="comment"># 变量拆分常用来迭代元组或列表序列</span></span><br><span class="line">seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 另一个常见用法是从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级的元组拆分功能，例如，从元组的开头“摘取”几个元素。它使用了特殊的语法*rest</span></span><br><span class="line">values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, *rest = values</span><br><span class="line">rest <span class="comment"># [3, 4, 5]</span></span><br><span class="line"><span class="comment"># rest的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</span></span><br><span class="line">a, b, *_ = values</span><br></pre></td></tr></table></figure>

<p>在Python中，替换可以这样做:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure>

<h5 id="tuple方法"><a href="#tuple方法" class="headerlink" title="tuple方法"></a>tuple方法</h5><p>元组的大小和内容不能修改，所以其实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表的长度可变、内容可以被修改。可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">None</span>]</span><br><span class="line">tup = (<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>)</span><br><span class="line">b_list = list(tup) <span class="comment"># ['foo', 'bar', 'baz']</span></span><br></pre></td></tr></table></figure>

<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = range(<span class="number">10</span>)</span><br><span class="line">list(gen) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<p><code>append</code>在列表末尾添加元素</p>
<p><code>insert</code>在特定的位置插入元素，插入的序号必须在0和列表长度之间</p>
<p><strong>注意：</strong> 警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为需要对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，可以使用双尾部队列<code>collections.deque</code>。</p>
<p><code>pop</code>, <code>insert</code>的逆运算，移除并返回指定位置的元素</p>
<p><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去</p>
<p><strong>注意：</strong> 如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p><code>in</code> 和<code>not in</code>检查列表是否包含某个值， </p>
<p><strong>注意：</strong> 在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）</p>
<h5 id="串联和组合列表"><a href="#串联和组合列表" class="headerlink" title="串联和组合列表"></a>串联和组合列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用加号将两个列表串联起来</span></span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>] + [<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 用extend方法可以追加多个元素</span></span><br><span class="line">x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>]</span><br><span class="line">x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment">## 通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用extend追加元素，尤其是到一个大列表中，更为可取。</span></span><br></pre></td></tr></table></figure>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用sort函数将一个列表原地排序（不创建新的对象）</span></span><br><span class="line">a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment"># sort 二级排序key</span></span><br><span class="line">b = [<span class="string">'saw'</span>, <span class="string">'small'</span>, <span class="string">'He'</span>, <span class="string">'foxes'</span>, <span class="string">'six'</span>]</span><br><span class="line">b.sort(key=len)</span><br><span class="line"><span class="comment"># sorted函数，它可以产生一个排好序的序列副本</span></span><br></pre></td></tr></table></figure>

<h5 id="二分搜索和维护已排序的列表"><a href="#二分搜索和维护已排序的列表" class="headerlink" title="二分搜索和维护已排序的列表"></a>二分搜索和维护已排序的列表</h5><p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># bisect.bisect可以找到插入值后仍保证排序的位置</span></span><br><span class="line">bisect.bisect(c, <span class="number">5</span>) <span class="comment"># 6</span></span><br><span class="line"><span class="comment"># bisect.insort向这个位置插入值</span></span><br><span class="line">bisect.insort(c, <span class="number">6</span>)</span><br><span class="line"><span class="comment">##  bisect模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用bisect不会产生错误，但结果不一定正确。</span></span><br></pre></td></tr></table></figure>

<h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">seq[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># [2, 3, 7, 5]</span></span><br><span class="line"><span class="comment"># 切片也可以被序列赋值</span></span><br><span class="line">seq[<span class="number">3</span>:<span class="number">4</span>] = [<span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># start或stop都可以被省略，省略之后，分别默认序列的开头和结尾</span></span><br><span class="line">seq[<span class="number">3</span>:] </span><br><span class="line"><span class="comment"># 负数表明从后向前切片</span></span><br><span class="line">seq[<span class="number">-4</span>:]  <span class="comment"># [5, 6, 0, 1]</span></span><br><span class="line"><span class="comment"># 第二个冒号后面使用step，可以隔几个取一个元素</span></span><br><span class="line">seq[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用-1，它可以将列表或元组颠倒过来</span></span><br><span class="line">seq[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-522e2b688b755ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h4><p>Python有一些有用的序列函数。</p>
<h5 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h5><p>迭代一个序列时，想要跟踪当前项的序号，可以使用Python内建的<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_list = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">mapping <span class="comment">#  &#123;'bar': 1, 'baz': 2, 'foo': 0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h5><p>返回一个<strong>新的</strong> 排好序的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">b = sorted(a)</span><br><span class="line">b <span class="comment"># [0, 1, 2, 2, 3, 6, 7]</span></span><br><span class="line">a <span class="comment"># [7, 1, 2, 6, 0, 3, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h5><p>将多个列表、元组或其它序列成对组合成一个元组列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq1 = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">seq2 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">zipped = zip(seq1, seq2)</span><br><span class="line">list(zipped) <span class="comment"># [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]</span></span><br><span class="line"><span class="comment"># zip可以处理任意多的序列，元素的个数取决于最短的序列</span></span><br><span class="line">seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line">list(zip(seq1, seq2, seq3)) <span class="comment">#  [('foo', 'one', False), ('bar', 'two', True)]</span></span><br></pre></td></tr></table></figure>

<p><code>zip</code>可以被用来解压序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pitchers = [(<span class="string">'Nolan'</span>, <span class="string">'Ryan'</span>), (<span class="string">'Roger'</span>, <span class="string">'Clemens'</span>), (<span class="string">'Schilling'</span>, <span class="string">'Curt'</span>)]</span><br><span class="line">first_names, last_names = zip(*pitchers)</span><br><span class="line">first_names  <span class="comment"># ('Nolan', 'Roger', 'Schilling')</span></span><br><span class="line">last_names   <span class="comment"># ('Ryan', 'Clemens', 'Curt')</span></span><br></pre></td></tr></table></figure>

<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(seq1, seq2)):     </span><br><span class="line">    print(<span class="string">'&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'</span>.format(i, a, b))</span><br><span class="line"><span class="number">0</span>: foo, one</span><br><span class="line"><span class="number">1</span>: bar, two</span><br><span class="line"><span class="number">2</span>: baz, three</span><br></pre></td></tr></table></figure>

<h5 id="reversed函数"><a href="#reversed函数" class="headerlink" title="reversed函数"></a>reversed函数</h5><p><code>reversed</code>是一个生成器（zip也是），可以从后向前迭代一个序列。注意：只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(reversed(range(<span class="number">10</span>))) <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>也称为：哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由&#123;&#125;定义</span></span><br><span class="line">d1 = &#123;<span class="string">'a'</span> : <span class="string">'some value'</span>, <span class="string">'b'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">d1[<span class="number">7</span>] = <span class="string">'an integer'</span></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">d1[<span class="string">'b'</span>]  <span class="comment"># [1,2,3,4]</span></span><br><span class="line"><span class="comment"># 检查字典中是否包含某个键</span></span><br><span class="line"><span class="string">'b'</span> <span class="keyword">in</span> d1</span><br><span class="line"><span class="comment"># 用del关键字或pop方法（返回值的同时删除键）删除值</span></span><br><span class="line"><span class="keyword">del</span> d1[<span class="string">'b'</span>]</span><br><span class="line">ret = d1.pop(<span class="string">'b'</span>)  <span class="comment"># ret: [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># keys和values是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</span></span><br><span class="line">list(d1.keys()) <span class="comment"># ['a', 'b', 7]</span></span><br><span class="line">list(d1.values()) <span class="comment"># ['some value', [1, 2, 3, 4], 'an integer']</span></span><br><span class="line"><span class="comment"># update方法可以将一个字典与另一个融合</span></span><br><span class="line">d1.update(&#123;<span class="string">'b'</span> : <span class="string">'foo'</span>, <span class="string">'c'</span> : <span class="number">12</span>&#125;) <span class="comment"># 键'b'对应的值会改变</span></span><br><span class="line"><span class="comment"># update方法是原地改变字典，任何传递给update的键的旧的值都会被舍弃。</span></span><br></pre></td></tr></table></figure>

<h5 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h5><p>将两个序列配对组合成字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zip(key_list, value_list):</span><br><span class="line">    mapping[key] = val</span><br></pre></td></tr></table></figure>

<p>字典本质上是2元元组的集合，所以dict可以接受2元元组的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = dict(zip(range(<span class="number">5</span>), reversed(range(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>

<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>dict的方法get和pop可以取默认值进行返回。get默认会返回None，如果不存在键，pop会抛出一个例外。</p>
<p><code>value = some_dict.get(key, default_value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">'apple'</span>, <span class="string">'bat'</span>, <span class="string">'bar'</span>, <span class="string">'atom'</span>, <span class="string">'book'</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure>

<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure>

<h5 id="有效的键对类型"><a href="#有效的键对类型" class="headerlink" title="有效的键对类型"></a>有效的键对类型</h5><p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为<strong>“可哈希性”</strong> 。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>无序的不可重复的元素的集合。可看成只有键没有值的字典。可以通过set函数或使用尖括号set语句创建集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]) <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125; <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>集合支持合并、交集、差分和对称差等数学集合运算。</p>
<h5 id="合并（union方法，或者-运算符）"><a href="#合并（union方法，或者-运算符）" class="headerlink" title="合并（union方法，或者|运算符）"></a>合并（<code>union</code>方法，或者<code>|</code>运算符）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.union(b) <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">a | b <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="交集（intersection或-amp-运算符）"><a href="#交集（intersection或-amp-运算符）" class="headerlink" title="交集（intersection或&amp;运算符）"></a>交集（<code>intersection</code>或<code>&amp;</code>运算符）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.intersection(b) <span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">a &amp; b <span class="comment"># &#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-980efe5d98ecc4d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp" alt="img"></p>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容，对于大的集合，这么做效率更高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">c = a.copy()  <span class="comment"># 硬copy</span></span><br><span class="line">c |= b</span><br><span class="line">d = a.copy()</span><br><span class="line">d &amp;= b</span><br></pre></td></tr></table></figure>

<p>与字典的键类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_set = &#123;tuple(my_data)&#125;</span><br><span class="line"><span class="comment"># 直接 my_set = &#123;[1, 2, 3, 4]&#125; 会报错</span></span><br></pre></td></tr></table></figure>

<h5 id="列表，集合和字典推导式"><a href="#列表，集合和字典推导式" class="headerlink" title="列表，集合和字典推导式"></a>列表，集合和字典推导式</h5><p>该特性允许用户从一个集合过滤元素，形成列表，集合或字典，在传递参数的过程中还可以修改元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">[expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict_comp = &#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">loc_mapping = &#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(strings)&#125;</span><br><span class="line"><span class="comment"># 集合推导式</span></span><br><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># map函数</span></span><br><span class="line">strings = [<span class="string">'a'</span>, <span class="string">'as'</span>, <span class="string">'bat'</span>, <span class="string">'car'</span>, <span class="string">'dove'</span>, <span class="string">'python'</span>]</span><br><span class="line">unique_lengths = &#123;len(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line">set(map(len, strings)) <span class="comment"># map 返回可迭代器，也可以list(map(len,strings))</span></span><br></pre></td></tr></table></figure>

<h5 id="嵌套列表推导式"><a href="#嵌套列表推导式" class="headerlink" title="嵌套列表推导式"></a>嵌套列表推导式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_data = [[<span class="string">'John'</span>, <span class="string">'Emily'</span>, <span class="string">'Michael'</span>, <span class="string">'Mary'</span>, <span class="string">'Steven'</span>],[<span class="string">'Maria'</span>, <span class="string">'Juan'</span>, <span class="string">'Javier'</span>, <span class="string">'Natalia'</span>, <span class="string">'Pilar'</span>]]</span><br><span class="line">result = [name <span class="keyword">for</span> names <span class="keyword">in</span> all_data <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> name.count(<span class="string">'e'</span>) &gt;= <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将一个整数元组的列表扁平化成了一个整数列表</span></span><br><span class="line">some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line">[[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples] <span class="comment"># 这样产生一个列表</span></span><br><span class="line"><span class="comment"># for表达式的顺序是与嵌套for循环的顺序一样</span></span><br><span class="line">flattened = []</span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是Python中最主要也是最重要的<strong>代码组织和复用手段</strong> 。如果要<strong>重复使用相同或非常类似的代码</strong>，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：可以同时拥有多条return语句。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(x, y, z=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br><span class="line"><span class="comment"># z是关键字参数</span></span><br><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 关键字参数必须位于位置参数（如果有的话）之后，关键字参数顺序可以随便</span></span><br></pre></td></tr></table></figure>

<h4 id="命名空间、作用域和局部函数"><a href="#命名空间、作用域和局部函数" class="headerlink" title="命名空间、作用域和局部函数"></a>命名空间、作用域和局部函数</h4><p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）</p>
<p>Python中命名空间（namespace）用于描述变量作用域的名称。任何在函数中赋值的变量默认都被分配到局部命名空间（local namespace）中。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line">    <span class="comment">#return &#123;'a' : a, 'b' : b, 'c' : c&#125; #也可以返回字典</span></span><br></pre></td></tr></table></figure>

<p>该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。</p>
<h4 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h4><p>数据清洗：</p>
<p>为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">clean_strings(states)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line">clean_strings(states, clean_ops)</span><br></pre></td></tr></table></figure>

<h4 id="匿名（lambda）函数"><a href="#匿名（lambda）函数" class="headerlink" title="匿名（lambda）函数"></a>匿名（lambda）函数</h4><p>Python支持一种被称为匿名函数（lambda函数，这种函数对象本身是没有提供名称<strong>name</strong>属性）。仅由单条语句组成，该语句的结果就是返回值。通过lambda关键字定义的，该关键字没有含义，仅仅表明“正在声明的是一个匿名函数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h4><p>柯里化（currying）是一个计算机科学术语，是指通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有一个执行两数相加的简单函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 通过这个函数，可以派生出一个新的只有一个参数的函数</span></span><br><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br><span class="line"><span class="comment"># add_numbers的第二个参数称为“柯里化的”（curried）</span></span><br></pre></td></tr></table></figure>

<p>本质上是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>Python可以以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，是一个原生的使对象可迭代的方法。</p>
<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器。</p>
<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squares</span><span class="params">(n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Generating squares from 1 to &#123;0&#125;'</span>.format(n ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">              </span><br><span class="line"><span class="comment"># 调用该生成器时，没有任何代码会被立即执行</span></span><br><span class="line">gen = squares()</span><br><span class="line"><span class="comment"># 直到从该生成器中请求元素时，它才会开始执行其代码</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">    print(x,end=<span class="string">' '</span> )</span><br></pre></td></tr></table></figure>

<h5 id="生成器表达式（generator-expression）"><a href="#生成器表达式（generator-expression）" class="headerlink" title="生成器表达式（generator expression）"></a>生成器表达式（generator expression）</h5><p>另一种更简洁的构造生成器的方法。类似于列表、字典、集合推导式的生成器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其创建方式为，把列表推导式两端的方括号改成圆括号</span></span><br><span class="line">gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = _make_gen()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器表达式也可以取代列表推导式，作为函数参数</span></span><br><span class="line">sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line">dict((i, i **<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h5 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h5><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的<strong>连续元素进行分组</strong> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">'Alan'</span>, <span class="string">'Adam'</span>, <span class="string">'Wes'</span>, <span class="string">'Will'</span>, <span class="string">'Albert'</span>, <span class="string">'Steven'</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    print(letter, list(names)) <span class="comment"># names is a generator</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-111823d8767a104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp" alt="img"></p>
<h4 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 只想处理ValueError，其他错误可能是合理的bug    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="comment"># another thing  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以用元组包含多个异常    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##  不想抑制异常，无论try部分的代码是否成功，都执行一段代码   </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子</span></span><br><span class="line">f = open(path, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Succeeded'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h4 id="IPython的异常"><a href="#IPython的异常" class="headerlink" title="IPython的异常"></a>IPython的异常</h4><p>在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文。</p>
<p>IPython中以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h3 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">'examples/segismundo.txt'</span></span><br><span class="line">f = open(path)</span><br></pre></td></tr></table></figure>

<p>默认情况下，文件是以只读模式（’r’）打开的。然后，可以像处理列表那样来处理文件句柄f，比如对行进行迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 还可以</span></span><br><span class="line">lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> open(path)]</span><br></pre></td></tr></table></figure>

<p>从文件中取出的行都带有完整的行结束符（EOL）。</p>
<p>使用open创建文件对象，一定要用close关闭。关闭文件可以返回操作系统资源。</p>
<p>用with语句可以在退出代码块时，自动关闭文件，更容易地清理打开的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-28274484129f0ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="常用方法-read、seek、tell"><a href="#常用方法-read、seek、tell" class="headerlink" title="常用方法 read、seek、tell"></a>常用方法 read、seek、tell</h4><p>read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(path)</span><br><span class="line">f.read(<span class="number">10</span>) <span class="comment"># 'Sueña el r'</span></span><br><span class="line"></span><br><span class="line">f2 = open(path, <span class="string">'rb'</span>)  <span class="comment"># Binary mode</span></span><br><span class="line">f2.read(<span class="number">10</span>) <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</span></span><br><span class="line">f.tell() <span class="comment"># 11</span></span><br><span class="line">f2.tell() <span class="comment"># 10</span></span><br><span class="line"><span class="comment"># seek将文件位置更改为文件中的指定字节</span></span><br><span class="line">f.seek(<span class="number">3</span>) <span class="comment"># 3</span></span><br><span class="line">f.read(<span class="number">1</span>) <span class="comment"># ñ</span></span><br></pre></td></tr></table></figure>

<p>向文件写入，可以使用文件的write或writelines方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'tmp.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    handle.writelines(x <span class="keyword">for</span> x <span class="keyword">in</span> open(path) <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建一个无空行版文件</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d25bd6e730afeb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="文件的字节和Unicode"><a href="#文件的字节和Unicode" class="headerlink" title="文件的字节和Unicode"></a>文件的字节和Unicode</h4><p>Python文件的默认操作是“文本模式”，即处理Python的字符串（即Unicode）。二进制模式需要在文件模式后加一个b。</p>
<p>UTF-8是长度可变的Unicode编码，当从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    chars = f.read(<span class="number">10</span>)  <span class="comment"># 'Sueña el r'</span></span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read(<span class="number">10</span>)   <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"><span class="comment"># 可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</span></span><br><span class="line">    data.decode(<span class="string">'utf8'</span>) <span class="comment"># 'Sueña el '</span></span><br><span class="line"><span class="comment"># 不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</span></span><br></pre></td></tr></table></figure>

<h2 id="第4章-NumPy基础：数组和矢量计算"><a href="#第4章-NumPy基础：数组和矢量计算" class="headerlink" title="第4章 NumPy基础：数组和矢量计算"></a>第4章 NumPy基础：数组和矢量计算</h2><p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<h3 id="多维数组对象ndarray"><a href="#多维数组对象ndarray" class="headerlink" title="多维数组对象ndarray"></a>多维数组对象ndarray</h3><p>ndarray是一个通用的同构数据多维容器，所有元素必须是相同类型的。</p>
<h4 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用np.array函数创建。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组</span></span><br><span class="line">data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line"><span class="comment"># 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</span></span><br><span class="line">data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line"><span class="comment"># 属性：dtype，shape，ndim</span></span><br></pre></td></tr></table></figure>

<p>zeros, ones和empty可以创建指定长度或形状的全0，全1或者一个没有任何具体值的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>)</span><br><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>arange是Python内置函数range的数组版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp" alt="img"></p>
<p>如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<h4 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h4><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line">arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以通过ndarray的<code>astype</code>方法将一个数组从一个dtype转换成另一个dtype</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype('int64')</span></span><br><span class="line">float_arr = arr.astype(np.float64) <span class="comment"># 也可以写float，NumPy会将Python类型映射到等价的dtype上。也可用简洁类型代码表示dtype，f4</span></span><br><span class="line"><span class="comment"># 如果将浮点数转换成整数，则小数部分将会被截取删除</span></span><br><span class="line"><span class="comment"># 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式</span></span><br><span class="line">numeric_strings = np.array([<span class="string">'1.25'</span>, <span class="string">'-9.6'</span>, <span class="string">'42'</span>], dtype=np.string_)</span><br><span class="line">numeric_strings.astype(float)</span><br></pre></td></tr></table></figure>

<h4 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h4><p>不编写循环，使用数组即可对数据执行批量运算。NumPy用户称其为<strong>矢量化（vectorization）</strong> </p>
<ul>
<li>大小相等的数组之间的任何算术运算都会将运算应用到元素级</li>
<li>数组与标量的算术运算会将标量值传播到各个元素</li>
<li>大小相同的数组之间的比较会生成布尔值数组</li>
<li>不同大小的数组之间的运算叫做<strong>广播（broadcasting）</strong> </li>
</ul>
<h4 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>一维数组和列表最重要的区别在于：数组切片是原始数组的视图，即数据不会被复制，视图上的任何修改都会直接反映到源数组上。这是因为NumPy的设计目的是处理大数据，假如NumPy坚持要将数据复制会产生性能和内存问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 将一个标量值赋值给一个切片时，该值会自动传播（即“广播”）到整个选区</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span>  <span class="comment"># array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span></span><br><span class="line"><span class="comment"># 切片[ : ]会给数组中的所有值赋值</span></span><br><span class="line"><span class="comment"># 数组切片是原始数组的视图</span></span><br><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice[<span class="number">1</span>] = <span class="number">12345</span> <span class="comment"># arr也会发生变化</span></span><br><span class="line"><span class="comment"># 如果想要得到ndarray切片的副本而非视图</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>].copy()</span><br></pre></td></tr></table></figure>

<h5 id="高维度数组"><a href="#高维度数组" class="headerlink" title="高维度数组"></a>高维度数组</h5><p><strong>二维数组</strong> 中，各索引位置上的元素不是标量而是一维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 对各个元素进行递归访问</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 传入一个以逗号隔开的索引列表来选取单个元素</span></span><br><span class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt="img"></p>
<p>在<strong>多维数组</strong> 中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"><span class="comment"># 标量值和数组都可以被赋值给arr3d[0]：</span></span><br><span class="line">old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line">arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr3d[<span class="number">0</span>] = old_values</span><br></pre></td></tr></table></figure>

<h5 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h5><p>一维ndarray的切片语法跟Python列表差不多。</p>
<p>二维ndarray的切片方式稍显不同。切片是沿着一个轴向选取元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([[1, 2, 3],   # 第一个轴切片，取了前两行</span></span><br><span class="line"><span class="comment">#       [4, 5, 6]])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># array([[2, 3],   # 第一个轴切片，再第二个轴切片</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>

<p>这样切片只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[<span class="number">1</span>, :<span class="number">2</span>]  <span class="comment"># array([4, 5])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">2</span>]  <span class="comment"># array([3, 6])</span></span><br></pre></td></tr></table></figure>

<p><strong>“只有冒号”表示选取整个轴</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line"><span class="comment"># array([[1],</span></span><br><span class="line"><span class="comment">#       [4],</span></span><br><span class="line"><span class="comment">#       [7]])</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/867/format/webp" alt="img"></p>
<p><strong>对切片表达式的赋值操作也会被扩散到整个选区</strong></p>
<h5 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h5><p>布尔型数组的长度必须跟被索引的轴长度一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line">data[names == <span class="string">'Bob'</span>]  <span class="comment"># 可以选出对名字"Bob"对应的所有行</span></span><br><span class="line"><span class="comment"># 布尔型数组可以和切片、整数（或整数序列）混合使用</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]  <span class="comment"># array([[ 0.769 ,  1.2464], [-0.5397,  0.477 ]])</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">3</span>]   <span class="comment"># array([ 1.2464,  0.477 ])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以使用不等于符号（!=），或通过~对条件进行否定</span></span><br><span class="line">data[~(names == <span class="string">'Bob'</span>)]</span><br><span class="line">data[names != <span class="string">'Bob'</span>]</span><br><span class="line"><span class="comment"># 使用&amp;（和）、|（或）之类的布尔算术运算符</span></span><br><span class="line">data[mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)]</span><br><span class="line"><span class="comment"># 通过布尔型数组设置值。例如将data中的所有负值都设置为0</span></span><br><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>布尔型索引选取数组中的数据，总是创建数据的副本。</li>
<li>Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</li>
<li>这类二维数据的操作也可以用pandas</li>
</ul>
<h5 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h5><p>花式索引（Fancy indexing）是一个NumPy术语，是指利用整数数组进行索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">     arr[i] = i</span><br><span class="line"><span class="comment"># 可以传入一个用于指定顺序的整数列表或ndarray，特定顺序选取行子集</span></span><br><span class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="comment"># 使用负数索引将会从末尾开始选取行</span></span><br><span class="line">arr[[<span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>无论数组是多少维的，花式索引总是一维的</li>
<li>花式索引总是将数据复制到新数组中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一次传入多个索引数组的返回是一个一维数组</span></span><br><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># array([ 4, 23, 29, 10])</span></span><br><span class="line"><span class="comment"># 要想的到矩阵</span></span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="数组转置和轴兑换"><a href="#数组转置和轴兑换" class="headerlink" title="数组转置和轴兑换"></a>数组转置和轴兑换</h4><ul>
<li>转置是重塑的一种特殊形式，返回源数据的视图（不会进行任何复制操作）。</li>
</ul>
<p>数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr.T</span><br><span class="line">arr.transpose()</span><br></pre></td></tr></table></figure>

<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变</span></span><br><span class="line">arr.swapaxes(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># swapaxes方法，它需要接受一对轴编号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>swapaxes也是返回源数据的视图（不会进行任何复制操作）</li>
</ul>
<h3 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h3><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。可以看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的<strong>矢量化包装器</strong>。</p>
<ul>
<li><p>一元（unary）ufunc,如sqrt和exp,返回一个结果数组</p>
</li>
<li><p>二元（binary）ufunc，如add或maximum接受2个数组,并返回一个结果数组</p>
</li>
<li><p>有些ufunc可以返回多个数组，例如mod（Python内置函数divmod的矢量化版本），返回浮点数数组的小数和整数部分</p>
</li>
<li><p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作。</p>
</li>
<li><pre><code class="python">arr = array([<span class="number">-3.2623</span>, <span class="number">-6.0915</span>, <span class="number">-6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])
np.sqrt(arr)
<span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-1d494e73b61c7ced.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-2be79faf68ab6ff8.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-4e38d02a66481530.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-eff1e61e5464159f.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-236dba83b6a420cc.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">### 利用数组进行数据处理</span><br><span class="line"></span><br><span class="line">用数组表达式代替循环的做法，通常被称为**矢量化**。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多）。</span><br><span class="line"></span><br><span class="line">#### 将条件逻辑表述为数组运算</span><br><span class="line"></span><br><span class="line">&#96;numpy.where&#96;函数是三元表达式&#96;x if condition else y&#96;的矢量化版本</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">xarr &#x3D; np.array([1.1, 1.2, 1.3, 1.4, 1.5])</span><br><span class="line">yarr &#x3D; np.array([2.1, 2.2, 2.3, 2.4, 2.5])</span><br><span class="line">cond &#x3D; np.array([True, False, True, True, False])</span><br><span class="line"># 根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。</span><br><span class="line"># 列表推导式的写法  缺点：1, 对大数组的处理速度不是很快。2,无法用于多维数组</span><br><span class="line">result &#x3D; [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]</span><br><span class="line">#</span><br><span class="line">result &#x3D; np.where(cond, xarr, yarr)</span><br><span class="line"># 第二个和第三个参数也可以是标量值</span><br><span class="line">arr &#x3D; np.random.randn(4, 4)</span><br><span class="line">np.where(arr &gt; 0, 2, -2) # set positive values to 2, negative values to -2.</span><br><span class="line"># 可以将标量和数组结合起来</span><br><span class="line">np.where(arr &gt; 0, 2, arr) # set only positive values to 2</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h4><p>通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算</p>
<p>sum、mean, 标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">arr.mean()</span><br><span class="line">np.mean(arr)</span><br><span class="line"><span class="comment"># mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个低一维的数组</span></span><br><span class="line">arr.mean(axis=<span class="number">1</span>) <span class="comment"># 算行的平均值</span></span><br><span class="line">arr.sum(axis=<span class="number">0</span>) <span class="comment"># 计算每列的和</span></span><br></pre></td></tr></table></figure>

<p>其他如cumsum（累加）和cumprod（累乘）之类的方法则不聚合，而是产生一个由中间结果组成的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">arr.cumsum()  <span class="comment"># array([ 0,  1,  3,  6, 10, 15, 21, 28])</span></span><br><span class="line"><span class="comment"># 多维数组，返回同样大小的数组，每个低维的切片沿着标记轴计算部分聚类</span></span><br><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>) <span class="comment"># 列上累加</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>) <span class="comment"># 行上累乘</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h4><p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）</p>
<ul>
<li><p>sum经常被用来对布尔型数组中的True值计数：</p>
</li>
<li><pre><code class="python">arr = np.random.randn(<span class="number">100</span>)
(arr &gt; <span class="number">0</span>).sum()
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ any用于测试数组中是否存在一个或多个True</span><br><span class="line"></span><br><span class="line">+ all则检查数组中所有值是否都是True</span><br><span class="line"></span><br><span class="line">+ any,all 用于非布尔型数组时，所有非0元素将会被当做True</span><br><span class="line"></span><br><span class="line">#### 排序</span><br><span class="line"></span><br><span class="line">多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">arr &#x3D; np.random.randn(5, 3)</span><br><span class="line">arr.sort(1)  # 安行排序，地排序则会修改数组本身</span><br><span class="line">np.sum(arr,1) # 返回的是数组的已排序副本</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h4><p>NumPy提供了一些针对一维ndarray的基本集合运算。</p>
<ul>
<li>np.unique用于找出数组中的唯一值并返回已排序的结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">np.unique(names)  <span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')</span></span><br><span class="line"><span class="comment"># 纯python代码也可以</span></span><br><span class="line">sorted(set(names)) <span class="comment"># ['Bob', 'Joe', 'Will']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]) <span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="用于数组的文件输入输出"><a href="#用于数组的文件输入输出" class="headerlink" title="用于数组的文件输入输出"></a>用于数组的文件输入输出</h3><p>NumPy的内置二进制格式，使用pandas或其它工具加载文本或表格数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存，default：数组以未压缩的原始二进制格式保存在扩展名为.npy的文件中，如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"><span class="comment"># 将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br><span class="line"><span class="comment"># 加载.npz文件时，得到一个类似字典的对象</span></span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>] <span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 数据压缩</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>

<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。</p>
<p>点积np.dot(a,y)或者x.dot(y)，@符用作中缀运算符，进行矩阵乘法</p>
<p><strong>numpy.linalg模块</strong> ：标准的矩阵分解运算包括求逆和行列式之类，使用行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于NumPy版本）等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h3><p><strong>numpy.random模块</strong>:对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数</p>
<p>都是通过算法基于随机数生成器种子，在确定性的条件下生成的伪随机数。可以用NumPy的np.random.seed更改随机数生成种子</p>
<p>numpy.random的数据生成函数使用全局随机种子。使用numpy.random.RandomState 创建一个与其它隔离的随机数生成器,避免全局状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="示例：随机漫步"><a href="#示例：随机漫步" class="headerlink" title="示例：随机漫步"></a>示例：随机漫步</h3><p>简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用一个数组运算来实现</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line">walk.min()</span><br><span class="line">walk.max()</span><br></pre></td></tr></table></figure>

<p>统计首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。</p>
<p>np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。</p>
<p>可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：<code>(np.abs(walk) &gt;= 10).argmax()</code></p>
<ul>
<li>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</li>
</ul>
<h4 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟5000个随机漫步过程</span></span><br><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算30或－30的最小穿越时间</span></span><br><span class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>)  <span class="comment"># 按照行来查询，一行中只要有一个true，则为true</span></span><br><span class="line">hits30.sum()  <span class="comment"># 5000个随机过程中，有多少个达到30，sum布尔值时，True为1</span></span><br><span class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第5章-pandas入门"><a href="#第5章-pandas入门" class="headerlink" title="第5章 pandas入门"></a>第5章 pandas入门</h2><p>pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>

<h3 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h3><h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成</p>
<p>可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 可以通过Series 的values和index属性获取其数组表示形式和索引对象</span></span><br><span class="line">obj.values <span class="comment"># array([ 4,  7, -5,  3])</span></span><br><span class="line">obj.index  <span class="comment"># like range(4)  RangeIndex(start=0, stop=4, step=1)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 直接通过这个字典来创建Series</span></span><br><span class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line">obj3 = pd.Series(sdata)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</span><br><span class="line">obj4 = pd.Series(sdata, index=states)</span><br><span class="line"><span class="comment"># sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</span></span><br><span class="line">pd.isnull(obj4)  <span class="comment"># pandas的isnull和notnull函数可用于检测缺失数据</span></span><br><span class="line">pd.notnull(obj4)</span><br><span class="line">obj4.isnull()   <span class="comment"># Series也有类似的实例方法</span></span><br></pre></td></tr></table></figure>

<p>Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据，类似数据库的join的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line"><span class="comment"># Series对象本身及其索引都有一个name属性</span></span><br><span class="line">obj4.name = <span class="string">'population'</span></span><br><span class="line">obj4.index.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>

<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>一个<strong>表格型的数据结构</strong>，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，可以看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<p>pandas中许多高级数据处理功能的关键要素，<strong>层次化索引的表格型结构</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 按照指定顺序进行排列</span></span><br><span class="line">pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>]) </span><br><span class="line"><span class="comment"># 传入的列在数据中找不到，就会在结果中产生缺失值</span></span><br><span class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>,<span class="string">'five'</span>, <span class="string">'six'</span>])</span><br><span class="line"><span class="comment"># 通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series</span></span><br><span class="line">frame2[<span class="string">'state'</span>]</span><br><span class="line">frame2.year</span><br><span class="line"><span class="comment"># 行也可以通过位置或名称的方式进行获取，比如用loc属性</span></span><br><span class="line">frame2.loc[<span class="string">'three'</span>]</span><br><span class="line"><span class="comment"># 列可以通过赋值的方式进行修改</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line">frame2[<span class="string">'debt'</span>] = val</span><br><span class="line"><span class="comment"># 根据state是否为'Ohio'，添加一个新的布尔值的列</span></span><br><span class="line">frame2[<span class="string">'eastern'</span>] = frame2.state == <span class="string">'Ohio'</span></span><br><span class="line"><span class="comment"># 关键字del用于删除列</span></span><br><span class="line"><span class="keyword">del</span> frame2[<span class="string">'eastern'</span>] </span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">frame.head() <span class="comment"># 前五行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套字典</span></span><br><span class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,<span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">frame3 = pd.DataFrame(pop)</span><br><span class="line"><span class="comment"># 对DataFrame进行转置（交换行和列）</span></span><br><span class="line">frame3.T</span><br><span class="line"><span class="comment"># 由Series组成的字典</span></span><br><span class="line">pdata = &#123;<span class="string">'Ohio'</span>: frame3[<span class="string">'Ohio'</span>][:<span class="number">-1</span>],<span class="string">'Nevada'</span>: frame3[<span class="string">'Nevada'</span>][:<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1075/format/webp" alt="img"></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.index.name = <span class="string">'year'</span>; frame3.columns.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>

<h4 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h4><h4 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h4><p>在对Series或DataFrame重新索引时，也可以指定一个填充值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认删除行（index）</span></span><br><span class="line">data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="comment"># 通过传递axis=1或axis='columns'可以删除列的值</span></span><br><span class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 就地修改对象，不会返回新的对象</span></span><br><span class="line">obj.drop(<span class="string">'c'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h4><p>Series：利用标签的切片运算与普通的Python切片运算不同，其末端是包含的。</p>
<p>DataFrame：默认列标签的索引</p>
<h4 id="用loc和iloc进行选取"><a href="#用loc和iloc进行选取" class="headerlink" title="用loc和iloc进行选取"></a>用loc和iloc进行选取</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先行后列</span></span><br><span class="line">data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]] <span class="comment">#行是必须的</span></span><br><span class="line">data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">data.loc[:<span class="string">'Utah'</span>, <span class="string">'two'</span>]</span><br><span class="line">data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/929/format/webp" alt="img"></p>
<h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h4><p>loc和iloc</p>
<h4 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h4><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。</p>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播</p>
<h4 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h4><p>两个DataFrame相加时，没有重叠的位置就会产生NA值，可以使用add方法填充一个特殊值（比如0）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.add(df2, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/webp" alt="img"></p>
<ul>
<li>以字母r开头，它会翻转参数。</li>
</ul>
<h4 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h4><p>广播（broadcasting）</p>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">series = frame.iloc[<span class="number">0</span>]</span><br><span class="line">frame - series</span><br><span class="line"><span class="string">""" output</span></span><br><span class="line"><span class="string">          b    d    e</span></span><br><span class="line"><span class="string">Utah    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">Ohio    3.0  3.0  3.0</span></span><br><span class="line"><span class="string">Texas   6.0  6.0  6.0</span></span><br><span class="line"><span class="string">Oregon  9.0  9.0  9.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line">frame + series2</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">          b   d     e   f</span></span><br><span class="line"><span class="string">Utah    0.0 NaN   3.0 NaN</span></span><br><span class="line"><span class="string">Ohio    3.0 NaN   6.0 NaN</span></span><br><span class="line"><span class="string">Texas   6.0 NaN   9.0 NaN</span></span><br><span class="line"><span class="string">Oregon  9.0 NaN  12.0 NaN</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>可以使用算术运算方法匹配行且在列上广播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.sub(series3, axis=<span class="string">'index'</span>) <span class="comment"># 或者 axis=0</span></span><br></pre></td></tr></table></figure>

<h4 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h4><p>DataFrame的apply方法可以将函数应用到由各列或行所形成的一维数组上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line">frame.apply(f) <span class="comment"># 每列</span></span><br><span class="line">frame.apply(f, axis=<span class="string">'columns'</span>) <span class="comment"># 每行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line">frame.apply(f)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            b         d         e</span></span><br><span class="line"><span class="string">min -0.555730  0.281746 -1.296221</span></span><br><span class="line"><span class="string">max  1.246435  1.965781  1.393406</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>DataFrame的applymap方法可以使用元素级的Python函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</span><br><span class="line">frame.applymap(format)</span><br></pre></td></tr></table></figure>

<p>Series有一个用于应用元素级函数的map方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame[<span class="string">'e'</span>].map(format)</span><br></pre></td></tr></table></figure>

<h4 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h4><p>DataFrame和Series中的sort_index方法对行或列索引进行排序（按字典顺序，默认升序），返回一个已排序的新对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj.sort_index()</span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),index=[<span class="string">'three'</span>, <span class="string">'one'</span>], columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">frame.sort_index()  <span class="comment"># index</span></span><br><span class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>) <span class="comment"># columns</span></span><br></pre></td></tr></table></figure>

<p>若要按值对Series进行排序，可使用其sort_values方法,任何缺失值默认都会被放到Series的末尾。</p>
<p>DataFrame排序时，可以根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">frame.sort_values(by=<span class="string">'b'</span>)</span><br><span class="line">frame.sort_values(by=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>

<p><strong>Series和DataFrame的rank方法</strong></p>
<p>默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">obj.rank() <span class="comment"># 排名并列会平均</span></span><br><span class="line">obj.rank(method=<span class="string">'first'</span>) <span class="comment"># 排名并列会选择小的数值</span></span><br><span class="line">obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">'max'</span>) <span class="comment"># 排名并列选择大的数值</span></span><br><span class="line"></span><br><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;) </span><br><span class="line">frame.rank(axis=<span class="string">'columns'</span>) <span class="comment"># 即axis=1， 默认axis=0</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp" alt="img"></p>
<h4 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h4><p>pandas函数（如reindex）都要求标签唯一，但这不是强制性的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 检查标签是否唯一</span></span><br><span class="line">obj.index.is_unique</span><br><span class="line"><span class="comment"># 如果某个索引对应多个值，则返回一个Series</span></span><br><span class="line"><span class="comment"># 对DataFrame的行进行索引时，返回DataFrame</span></span><br></pre></td></tr></table></figure>

<h3 id="汇总和计算描述统计"><a href="#汇总和计算描述统计" class="headerlink" title="汇总和计算描述统计"></a>汇总和计算描述统计</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引），另一些方法则是累计型的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h4><h4 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</span><br><span class="line">uniques = obj.unique()</span><br><span class="line">obj.value_counts()</span><br><span class="line"><span class="comment"># isin用于判断矢量化集合的成员资格</span></span><br><span class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp" alt="img"></p>
<h2 id="第6章-数据加载、存储与文件格式"><a href="#第6章-数据加载、存储与文件格式" class="headerlink" title="第6章 数据加载、存储与文件格式"></a>第6章 数据加载、存储与文件格式</h2><h3 id="读写文本格式的数据"><a href="#读写文本格式的数据" class="headerlink" title="读写文本格式的数据"></a>读写文本格式的数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'examples/ex1.csv'</span>)</span><br><span class="line">pd.read_table(<span class="string">'examples/ex1.csv'</span>, sep=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 如果文件没有标题行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, header=<span class="literal">None</span>)</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>])</span><br><span class="line"><span class="comment"># 将某列设置为索引</span></span><br><span class="line">names = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>]</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=names, index_col=<span class="string">'message'</span>)</span><br><span class="line"><span class="comment"># 层次化索引</span></span><br><span class="line">parsed = pd.read_csv(<span class="string">'examples/csv_mindex.csv'</span>, index_col=[<span class="string">'key1'</span>, <span class="string">'key2'</span>])</span><br><span class="line"><span class="comment"># 正则表达式作为分隔</span></span><br><span class="line">result = pd.read_table(<span class="string">'examples/ex3.txt'</span>, sep=<span class="string">'\s+'</span>)</span><br><span class="line"><span class="comment"># 用skiprows跳过文件的指定行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex4.csv'</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># na_values可以用一个列表或集合的字符串表示缺失值</span></span><br><span class="line">result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>, na_values=[<span class="string">'NULL'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置pandas显示地更紧些</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"><span class="comment"># 只读取几行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex6.csv'</span>, nrows=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 要逐块读取文件</span></span><br><span class="line">chunker = pd.read_csv(<span class="string">'ch06/ex6.csv'</span>, chunksize=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>返回可迭代的TextParser对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">'key'</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.to_csv(<span class="string">'examples/out.csv'</span>)</span><br><span class="line">data.to_csv(sys.stdout, sep=<span class="string">'|'</span>) <span class="comment"># 写出到sys.stdout，仅仅打印出文本结果</span></span><br><span class="line"><span class="comment"># 默认缺失值在输出结果中会被表示为空字符串</span></span><br><span class="line">data.to_csv(sys.stdout, na_rep=<span class="string">'NULL'</span>)</span><br><span class="line"><span class="comment"># 默认写出行和列的标签</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 只写出一部分</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># Series也有一个to_csv方法</span></span><br><span class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">7</span>)</span><br><span class="line">ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line">ts.to_csv(<span class="string">'examples/tseries.csv'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="处理分隔符格式"><a href="#处理分隔符格式" class="headerlink" title="处理分隔符格式"></a>处理分隔符格式</h4><p>手动处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用Python内置的csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = open(<span class="string">'examples/ex7.csv'</span>)</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    print(line)</span><br><span class="line"><span class="comment"># 读取文件到一个多行的列表中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'examples/ex7.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = list(csv.reader(f))</span><br><span class="line"><span class="comment"># 将这些行分为标题行和数据行    </span></span><br><span class="line">header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典</span></span><br><span class="line">data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> zip(header, zip(*values))&#125;</span><br></pre></td></tr></table></figure>

<p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_dialect</span><span class="params">(csv.Dialect)</span>:</span></span><br><span class="line">    lineterminator = <span class="string">'\n'</span></span><br><span class="line">    delimiter = <span class="string">';'</span></span><br><span class="line">    quotechar = <span class="string">'"'</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1187/format/webp" alt="img"></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>通过json.loads即可将JSON字符串转换成Python形式</p>
<p>json.dumps则将Python对象转换成JSON格式</p>
<p>JSON对象转换为DataFrame：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = json.loads(obj)</span><br><span class="line">siblings = pd.DataFrame(result[<span class="string">'siblings'</span>], columns=[<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br></pre></td></tr></table></figure>

<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame</p>
<p>将数据从pandas输出到JSON，可以使用to_json方法</p>
<h4 id="XML和HTML：Web信息收集"><a href="#XML和HTML：Web信息收集" class="headerlink" title="XML和HTML：Web信息收集"></a>XML和HTML：Web信息收集</h4><p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。</p>
<h3 id="二进制数据格式"><a href="#二进制数据格式" class="headerlink" title="二进制数据格式"></a>二进制数据格式</h3><p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化</p>
<p>read_pickle和to_pickle</p>
<ul>
<li>pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的</li>
</ul>
<p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。</p>
<p>pandas或NumPy数据的其它存储格式有：</p>
<ul>
<li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li>
<li>Feather：一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li>
</ul>
<h4 id="HDF5格式"><a href="#HDF5格式" class="headerlink" title="HDF5格式"></a>HDF5格式</h4><p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。</p>
<p>HDF5可以高效地分块读写</p>
<p>可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line">store[<span class="string">'obj1'</span>] = frame</span><br><span class="line">store[<span class="string">'obj1_col'</span>] = frame[<span class="string">'a'</span>]</span><br><span class="line">store = pd.HDFStore(<span class="string">'mydata.h5'</span>)</span><br><span class="line"><span class="comment"># HDFStore支持两种存储模式，'fixed'和'table'。后者通常会更慢，但是支持使用特殊语法进行查询操作：</span></span><br><span class="line">store.put(<span class="string">'obj2'</span>, frame, format=<span class="string">'table'</span>)</span><br><span class="line">store.select(<span class="string">'obj2'</span>, where=[<span class="string">'index &gt;= 10 and index &lt;= 15'</span>])</span><br><span class="line"></span><br><span class="line">frame.to_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, format=<span class="string">'table'</span>)</span><br><span class="line">pd.read_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, where=[<span class="string">'index &lt; 5'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="读取Microsoft-Excel文件"><a href="#读取Microsoft-Excel文件" class="headerlink" title="读取Microsoft Excel文件"></a>读取Microsoft Excel文件</h4><p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line">xlsx = pd.ExcelFile(<span class="string">'examples/ex1.xlsx'</span>)</span><br><span class="line">pd.read_excel(xlsx, <span class="string">'Sheet1'</span>)</span><br><span class="line">frame = pd.read_excel(<span class="string">'examples/ex1.xlsx'</span>, <span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'examples/ex2.xlsx'</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">'Sheet1'</span>)</span><br><span class="line">writer.save()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">frame.to_excel(<span class="string">'examples/ex2.xlsx'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Web-APIs交互"><a href="#Web-APIs交互" class="headerlink" title="Web APIs交互"></a>Web APIs交互</h3><h3 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h3><p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）</p>
<p>。<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。</p>
<h2 id="第7章-数据清洗和准备"><a href="#第7章-数据清洗和准备" class="headerlink" title="第7章 数据清洗和准备"></a>第7章 数据清洗和准备</h2><h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据，称其为哨兵值，可以方便的检测出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string_data = pd.Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="string">'avocado'</span>])</span><br><span class="line">string_data.isnull()</span><br><span class="line">string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line">string_data.isnull()</span><br></pre></td></tr></table></figure>

<p>pandas采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="滤除缺失数据"><a href="#滤除缺失数据" class="headerlink" title="滤除缺失数据"></a>滤除缺失数据</h4><p>通过pandas.isnull或布尔索引的手工方法，或者dropna。对于一个Series，dropna返回一个仅含非空数据和索引值的Series</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>]) </span><br><span class="line">data.dropna()</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">data[data.notnull()]</span><br></pre></td></tr></table></figure>

<p>对于DataFrame对象，dropna默认丢弃任何含有缺失值的行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line">cleaned = data.dropna()</span><br><span class="line"><span class="comment"># 丢弃全为NA的那些行</span></span><br><span class="line">data.dropna(how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 丢弃列</span></span><br><span class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 滤除DataFrame行的问题涉及时间序列数据，至滤除符合条件的前两行</span></span><br><span class="line">df.dropna(thresh=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h4><p>fillna函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 实现对不同的列填充不同的值</span></span><br><span class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment"># 对现有对象进行就地修改</span></span><br><span class="line"> _ = df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#对reindexing有效的那些插值方法也可用于fillna    </span></span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 传入平均值</span></span><br><span class="line">data.fillna(data.mean())</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><h4 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'k1'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>] * <span class="number">3</span> + [<span class="string">'two'</span>],<span class="string">'k2'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="comment"># duplicated方法返回一个布尔型Series，表示各行是否和前面出现过的行重复</span></span><br><span class="line">data.duplicated()</span><br><span class="line"><span class="comment"># drop_duplicates方法，返回一个DataFrame，重复的数组会标为False</span></span><br><span class="line">data.drop_duplicates()</span><br><span class="line"><span class="comment"># 指定部分列进行重复项判断</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>])</span><br><span class="line"><span class="comment"># duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>, <span class="string">'k2'</span>], keep=<span class="string">'last'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="利用函数或映射进行数据转换"><a href="#利用函数或映射进行数据转换" class="headerlink" title="利用函数或映射进行数据转换"></a>利用函数或映射进行数据转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>,</span><br><span class="line"><span class="string">'Pastrami'</span>, <span class="string">'corned beef'</span>, <span class="string">'Bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>, <span class="string">'nova lox'</span>],<span class="string">'ounces'</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="comment"># 添加一列表示该肉类食物来源的动物类型</span></span><br><span class="line"><span class="comment"># 编写一个不同肉类到动物的映射</span></span><br><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">'bacon'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 先将字母转换为小写</span></span><br><span class="line">lowercased = data[<span class="string">'food'</span>].str.lower()</span><br><span class="line">data[<span class="string">'animal'</span>] = lowercased.map(meat_to_animal)</span><br><span class="line"><span class="comment"># 传入一个能够完成全部这些工作的函数：</span></span><br><span class="line">data[<span class="string">'food'</span>].map(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>

<h4 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a>替换值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1.</span>, <span class="number">-999.</span>, <span class="number">2.</span>, <span class="number">-999.</span>, <span class="number">-1000.</span>, <span class="number">3.</span>])</span><br><span class="line">data.replace(<span class="number">-999</span>, np.nan)</span><br><span class="line"><span class="comment"># 传入多个值</span></span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], np.nan)</span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 也可以传入字典</span></span><br><span class="line">data.replace(&#123;<span class="number">-999</span>: np.nan, <span class="number">-1000</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换</li>
</ul>
<h4 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h4><p>轴标签可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line">data.index.map(transform)</span><br><span class="line"><span class="comment"># 对DataFrame就地修改</span></span><br><span class="line">data.index = data.index.map(transform)</span><br><span class="line"><span class="comment"># 用rename方法创建数据集的转换版（而不是修改原始数据）</span></span><br><span class="line">data.rename(index=str.title, columns=str.upper)</span><br><span class="line"><span class="comment"># rename可以结合字典型对象实现对部分轴标签的更新</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;,columns=&#123;<span class="string">'three'</span>: <span class="string">'peekaboo'</span>&#125;)</span><br><span class="line"><span class="comment"># 就地修改</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h4><p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。</p>
<p>cut函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 年龄分组</span></span><br><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br><span class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line">cats = pd.cut(ages, bins)</span><br><span class="line"><span class="comment"># 返回的是一个特殊的Categorical对象</span></span><br><span class="line">cats.codes <span class="comment"># array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)</span></span><br><span class="line">cats.categories </span><br><span class="line"><span class="string">""" IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]]</span></span><br><span class="line"><span class="string">              closed='right',</span></span><br><span class="line"><span class="string">              dtype='interval[int64]')"""</span></span><br><span class="line"><span class="comment"># pd.value_counts(cats)是pandas.cut结果的面元计数</span></span><br><span class="line">pd.value_counts(cats)</span><br><span class="line"></span><br><span class="line">pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 可以通过传递一个列表或数组到labels，设置面元名称</span></span><br><span class="line">group_names = [<span class="string">'Youth'</span>, <span class="string">'YoungAdult'</span>, <span class="string">'MiddleAged'</span>, <span class="string">'Senior'</span>]</span><br><span class="line">pd.cut(ages, bins, labels=group_names)</span><br><span class="line"><span class="comment"># 向cut传入的是面元的数量</span></span><br><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line">pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>) <span class="comment"># 选项precision=2，限定小数只有两位</span></span><br></pre></td></tr></table></figure>

<p>qcut非常类似cut，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">cats = pd.qcut(data, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以传递自定义的分位数（0到1之间的数值，包含端点）</span></span><br><span class="line">pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>

<h4 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h4><p>过滤或变换异常值（outlier）在很大程度上就是运用数组运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line">data.describe()</span><br><span class="line"><span class="comment"># 找出某列中绝对值大小超过3的值</span></span><br><span class="line">col = data[<span class="number">2</span>] <span class="comment"># 第二列</span></span><br><span class="line">col[np.abs(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 选出全部含有“超过3或－3的值”的行</span></span><br><span class="line">data[(np.abs(data) &gt; <span class="number">3</span>).any(<span class="number">1</span>)]</span><br><span class="line">data[np.abs(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"><span class="comment"># 根据数据的值是正还是负，np.sign(data)可以生成1和-1：</span></span><br><span class="line">np.sign(data).head()</span><br></pre></td></tr></table></figure>

<h4 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h4><p>利用numpy.random.permutation函数可以实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line">df.take(sampler)</span><br><span class="line"><span class="comment"># 可以在Series和DataFrame上使用sample方法</span></span><br><span class="line">df.sample(n=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 要通过替换的方式产生样本（允许重复选择），可以传递replace=True到sample</span></span><br><span class="line">choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h4><p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line"><span class="comment"># 给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并</span></span><br><span class="line">dummies = pd.get_dummies(df[<span class="string">'key'</span>], prefix=<span class="string">'key'</span>)</span><br><span class="line">df_with_dummy = df[[<span class="string">'data1'</span>]].join(dummies)</span><br><span class="line"><span class="comment"># 如果DataFrame中的某行同属于多个分类，则事情就会有点复杂</span></span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>

<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val = <span class="string">'a,b,  guido'</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">','</span>)]</span><br><span class="line"><span class="string">'::'</span>.join(pieces) <span class="comment"># 等价于 first + '::' + second + '::' + third</span></span><br><span class="line"><span class="comment"># 子串定位</span></span><br><span class="line"><span class="string">'guido'</span> <span class="keyword">in</span> val</span><br><span class="line">val.index(<span class="string">','</span>) <span class="comment"># 找不到字符串，index将会引发一个异常</span></span><br><span class="line">val.find(<span class="string">':'</span>)  <span class="comment"># 找不到返回-1</span></span><br><span class="line">val.count(<span class="string">','</span>)</span><br><span class="line">val.replace(<span class="string">','</span>, <span class="string">'::'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-087fe67bf6db0701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d1f0d4ed3e895016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"foo    bar\t baz  \tqux"</span></span><br><span class="line">re.split(<span class="string">'\s+'</span>, text)</span><br><span class="line"><span class="comment"># 调用re.split('\s+',text)时，正则表达式会先被编译，然后再在text上调用其split方法。</span></span><br><span class="line"><span class="comment"># 如果打算对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建regex对象。这样将可以节省大量的CPU时间。</span></span><br><span class="line">regex = re.compile(<span class="string">'\s+'</span>)</span><br><span class="line">regex.split(text)</span><br><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># findall返回字符串中所有的匹配项，search返回第一个匹配项。match只匹配字符串的首部</span></span><br><span class="line">text = <span class="string">"""Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pattern = <span class="string">r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;'</span></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.compile(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">regex.findall(text)</span><br><span class="line">m = regex.search(text)</span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(5, 20), match='dave@google.com'&gt;</span></span><br><span class="line">text[m.start():m.end()]</span><br><span class="line">regex.match(text) <span class="comment"># 结果为None,只匹配出现在字符串开头的模式</span></span><br><span class="line">regex.sub(<span class="string">'REDACTED'</span>, text)</span><br><span class="line"><span class="comment"># 分段的模式</span></span><br><span class="line">pattern = <span class="string">r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)'</span></span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line">m.groups()</span><br><span class="line"><span class="comment"># ('wesm', 'bright', 'net')</span></span><br><span class="line">regex.findall(text) <span class="comment"># 对于带有分组功能的模式，findall返回一个元组列表</span></span><br><span class="line"><span class="comment"># sub能通过诸如\1、\2之类的特殊符号访问各匹配项中的分组</span></span><br><span class="line">regex.sub(<span class="string">r'Username: \1, Domain: \2, Suffix: \3'</span>, text)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-efbb80a793759fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="pandas的矢量化字符串函数"><a href="#pandas的矢量化字符串函数" class="headerlink" title="pandas的矢量化字符串函数"></a>pandas的矢量化字符串函数</h4><p>通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。</p>
<p>含有字符串的列有时还含有缺失数据,为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.str.contains(<span class="string">'gmail'</span>)</span><br><span class="line">data.str.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line">matches = data.str.match(pattern, flags=re.IGNORECASE)</span><br><span class="line">data.str[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870/format/webp" alt="img"></p>
<h2 id="第8章-数据规整：聚合、合并和重塑"><a href="#第8章-数据规整：聚合、合并和重塑" class="headerlink" title="第8章 数据规整：聚合、合并和重塑"></a>第8章 数据规整：聚合、合并和重塑</h2><h3 id="层次化索引"><a href="#层次化索引" class="headerlink" title="层次化索引"></a>层次化索引</h3><p>层次化索引（hierarchical indexing）是pandas的一项重要功能，在一个轴上拥有多个（两个以上）索引级别，以低维度形式处理高维度数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.Series(np.random.randn(<span class="number">9</span>),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 外层操作</span></span><br><span class="line">data[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment"># 内层操作</span></span><br><span class="line">data.loc[:, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过unstack方法将这段数据重新安排到一个DataFrame中</span></span><br><span class="line">data.unstack()</span><br><span class="line">data.unstack().stack()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对于一个DataFrame，每条轴都可以有分层索引：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],columns=[[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>],[<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]])</span><br><span class="line"><span class="comment"># 各层都可以有名字</span></span><br><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">frame[<span class="string">'Ohio'</span>]</span><br><span class="line">frame.loc[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="重排与分级排序"><a href="#重排与分级排序" class="headerlink" title="重排与分级排序"></a>重排与分级排序</h4><p>swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># sort_index则根据单个级别中的值对数据进行排序</span></span><br><span class="line">frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="根据级别汇总统计"><a href="#根据级别汇总统计" class="headerlink" title="根据级别汇总统计"></a>根据级别汇总统计</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据行或列上的级别来进行求和</span></span><br><span class="line">frame.sum(level=<span class="string">'key2'</span>)</span><br><span class="line">frame.sum(level=<span class="string">'color'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h4><p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>),<span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">frame2 = frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="comment"># 默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来</span></span><br><span class="line">frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>], drop=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面</span></span><br><span class="line">frame2.reset_index()</span><br></pre></td></tr></table></figure>
<h3 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h3><p>pandas对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<h4 id="数据库风格的DataFrame合并"><a href="#数据库风格的DataFrame合并" class="headerlink" title="数据库风格的DataFrame合并"></a>数据库风格的DataFrame合并</h4><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="comment"># 多对一的合并</span></span><br><span class="line"><span class="comment"># 默认情况下，merge会将重叠列的列名当做键</span></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line"><span class="comment"># 列名可以指定</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment">#如果两个对象的列名不同，也可以分别进行指定</span></span><br><span class="line">pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br><span class="line"><span class="comment"># 默认情况下，merge做的是“内连接”；结果中的键是交集</span></span><br><span class="line"><span class="comment"># 他方式还有"left"、"right"以及"outer"。外连接求取的是键的并集，组合了左连接和右连接的效果</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/739/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多对多的合并</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">5</span>)&#125;)</span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>, how=<span class="string">'left'</span>)</span><br><span class="line"><span class="comment"># 多对多连接产生的是行的笛卡尔积</span></span><br><span class="line"><span class="comment"># 由于左边的DataFrame有3个"b"行，右边的有2个，所以最终结果中就有6个"b"行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据多个键进行合并，传入一个由列名组成的列表</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>], <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],<span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],<span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line">pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p>合并运算对重复列名的处理：merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>)</span><br><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>, suffixes=(<span class="string">'_left'</span>, <span class="string">'_right'</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<h4 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h4><p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index=True或right_index=True（或两个都传）以说明索引应该被用作连接键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],<span class="string">'value'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'group_val'</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>对于层次化索引的数据，索引的合并默认是多键合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lefth = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],<span class="string">'key2'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'data'</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line">righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),index=[[<span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>,<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>],[<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],  columns=[<span class="string">'event1'</span>, <span class="string">'event2'</span>])</span><br><span class="line"><span class="comment"># 以列表的形式指明用作合并键的多个列</span></span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同时使用合并双方的索引</span></span><br><span class="line">pd.merge(left2, right2, how=<span class="string">'outer'</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># join默认使用的是左连接，保留左边表的行索引</span></span><br><span class="line">left2.join(right2, how=<span class="string">'outer'</span>)</span><br><span class="line"><span class="comment"># 支持在调用的DataFrame的列上，连接传递的DataFrame索引</span></span><br><span class="line">left1.join(right1, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">pd.merge(left1,right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h4><p>连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对于pandas对象（如Series和DataFrame），还需要考虑以下这些情况：</p>
<ul>
<li>如果对象在其它轴上的索引不同，应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li>
</ul>
<p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line"><span class="comment"># 默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）</span></span><br><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]])</span><br><span class="line"><span class="comment"># 在连接轴上创建一个层次化索引</span></span><br><span class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line"><span class="comment"># 如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值</span></span><br><span class="line">pd.concat(&#123;<span class="string">'level1'</span>: df1, <span class="string">'level2'</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可以用names参数命名创建的轴级别</span></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">'level1'</span>, <span class="string">'level2'</span>],names=[<span class="string">'upper'</span>, <span class="string">'lower'</span>])</span><br><span class="line"><span class="comment"># DataFrame的行索引不包含任何相关数据，直接合并index</span></span><br><span class="line">pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1167/format/webp" alt="img"></p>
<h4 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan], index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br><span class="line">b = pd.Series(np.arange(len(a), dtype=np.float64), index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="第11章-时间序列"><a href="#第11章-时间序列" class="headerlink" title="第11章 时间序列"></a>第11章 时间序列</h2><p>时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（timestamp），特定的时刻。</li>
<li>固定时期（period），如2007年1月或2010年全年。</li>
<li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li>
<li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li>
</ul>
<h3 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 以毫秒形式存储日期和时间</span></span><br><span class="line">now = datetime.now() <span class="comment"># datetime.datetime(2017, 9, 25, 14, 5, 52, 72973)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>) <span class="comment"># day and second</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h4><p><code>datetime.strptime</code>是通过已知格式进行日期解析的最佳方式，但是每次都要编写格式定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">str(stamp) <span class="comment"># '2011-01-03 00:00:00'</span></span><br><span class="line">stamp.strftime(<span class="string">'%Y-%m-%d'</span>) <span class="comment">#'2011-01-03'</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="string">'2011-01-03'</span></span><br><span class="line">datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">parse(<span class="string">'2011-01-03'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br><span class="line">parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</span><br><span class="line">parse(<span class="string">'6/12/2011'</span>, dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>一些常见的日期格式可以用dateutil这个第三方包中的parser.parse方法。</p>
<p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datestrs = [<span class="string">'2011-07-06 12:00:00'</span>, <span class="string">'2011-08-06 00:00:00'</span>]</span><br><span class="line">pd.to_datetime(datestrs) <span class="comment"># DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)</span></span><br></pre></td></tr></table></figure>

<p>NaT（Not a Time）是pandas中时间戳数据的null值。</p>
<ul>
<li><p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如”42”会被解析为2042年的今天）。</p>
<p>特定于当前环境（位于不同国家或使用不同语言的系统）的日期格式</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h3 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h3><p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳。</p>
<p>datetime对象用作index时，实际上被放在一个DatetimeIndex中，其中的各个标量值是pandas的Timestamp对象。</p>
<h4 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h4><p>根据标签索引选取数据时，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stamp = ts.index[<span class="number">2</span>] </span><br><span class="line">ts[stamp]</span><br><span class="line"><span class="comment"># 下面这种格式也可以</span></span><br><span class="line">ts[<span class="string">'1/10/2011'</span>]</span><br><span class="line">ts[<span class="string">'20110110'</span>]</span><br><span class="line"><span class="comment"># 对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片</span></span><br><span class="line">longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>))</span><br><span class="line">longer_ts[<span class="string">'2001'</span>]</span><br><span class="line">longer_ts[<span class="string">'2001-05'</span>]</span><br><span class="line"><span class="comment"># 使用datetime对象进行切片</span></span><br><span class="line">ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line"><span class="comment"># 也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）</span></span><br><span class="line">ts[<span class="string">'1/6/2011'</span>:<span class="string">'1/11/2011'</span>] <span class="comment"># 产生的是原时间序列的视图</span></span><br><span class="line">ts.truncate(after=<span class="string">'1/9/2011'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h4><p>多个观测数据落在同一个时间点上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>,<span class="string">'1/2/2000'</span>, <span class="string">'1/3/2000'</span>])</span><br><span class="line">dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line">dup_ts.index.is_unique</span><br><span class="line"><span class="comment"># 对具有非唯一时间戳的数据进行聚合</span></span><br><span class="line">grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line">grouped.mean()</span><br><span class="line">grouped.count()</span><br></pre></td></tr></table></figure>

<h3 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h3><p>pandas中的原生时间序列没有固定的频率,一般被认为是不规则的。但pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resampler = ts.resample(<span class="string">'D'</span>)</span><br><span class="line"><span class="comment"># 字符串“D”是每天的意思</span></span><br></pre></td></tr></table></figure>

<h4 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h4><p><code>pandas.date_range</code>可用于根据指定的频率生成指定长度的DatetimeIndex.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-04-01'</span>, <span class="string">'2012-06-01'</span>)</span><br><span class="line">pd.date_range(start=<span class="string">'2012-04-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line">pd.date_range(end=<span class="string">'2012-06-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 生成一个由每月最后一个工作日组成的日期索引</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-12-01'</span>, freq=<span class="string">'BM'</span>) <span class="comment">#"BM"频率business end of month</span></span><br></pre></td></tr></table></figure>

<p>date_range默认会保留起始和结束时间戳的时间信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 每个日期都有12:56:31,可以关掉</span></span><br><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h4><p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line">hour = Hour()</span><br><span class="line">four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以使用别名"H"或"4H"</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-01-03 23:59'</span>, freq=<span class="string">'4h'</span>)</span><br><span class="line"><span class="comment"># 偏移量对象都可通过加法进行连接</span></span><br><span class="line">Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>) <span class="comment"># &lt;150 * Minutes&gt;</span></span><br><span class="line"><span class="comment"># 传入频率字符串</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1h30min'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="WOM日期"><a href="#WOM日期" class="headerlink" title="WOM日期"></a>WOM日期</h4><p>WOM（Week Of Month）是一种非常实用的频率类，获得诸如“每月第3个星期五”之类的日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'2012-01-01'</span>, <span class="string">'2012-09-01'</span>, freq=<span class="string">'WOM-3FRI'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="移动（超前和滞后）数据"><a href="#移动（超前和滞后）数据" class="headerlink" title="移动（超前和滞后）数据"></a>移动（超前和滞后）数据</h4><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有shift方法用于执行单纯的前移或后移操作，<strong>保持索引不变</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">4</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">4</span>, freq=<span class="string">'M'</span>))</span><br><span class="line"><span class="comment"># 数据位移，会在时间序列的前面或后面产生缺失数据</span></span><br><span class="line">ts.shift(<span class="number">2</span>)</span><br><span class="line">ts.shift(<span class="number">-2</span>)</span><br><span class="line"><span class="comment"># 实现对时间戳进行位移而不是对数据进行简单位移</span></span><br><span class="line">ts.shift(<span class="number">2</span>, freq=<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h4><p>pandas的日期偏移量还可以用在datetime或Timestamp对象上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line">now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line">now + <span class="number">3</span> * Day() <span class="comment"># Timestamp('2011-11-20 00:00:00')</span></span><br><span class="line"><span class="comment"># 使用锚点偏移量</span></span><br><span class="line">now + MonthEnd() <span class="comment"># Timestamp('2011-12-31 00:00:00')</span></span><br><span class="line"><span class="comment"># 通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”</span></span><br><span class="line">offset = MonthEnd()</span><br><span class="line">offset.rollforward(now) <span class="comment"># Timestamp('2011-11-30 00:00:00')</span></span><br><span class="line">offset.rollback(now) <span class="comment"># Timestamp('2011-10-31 00:00:00')</span></span><br></pre></td></tr></table></figure>
<h3 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h3><h4 id="时区本地化和转换"><a href="#时区本地化和转换" class="headerlink" title="时区本地化和转换"></a>时区本地化和转换</h4><p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。pandas包装了pytz的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">pytz.common_timezones[<span class="number">-5</span>:]<span class="comment"># ['US/Eastern', 'US/Hawaii', 'US/Mountain', 'US/Pacific', 'UTC']</span></span><br><span class="line">tz = pytz.timezone(<span class="string">'America/New_York'</span>) <span class="comment"># &lt;DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，pandas中的时间序列是单纯（naive）的时区,其索引的tz字段为None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">print(ts.index.tz) <span class="comment"># None</span></span><br><span class="line"><span class="comment"># 可以指定时区</span></span><br><span class="line">pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'D'</span>, tz=<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 通过tz_localize方法从单纯转换到本地化</span></span><br><span class="line">ts_utc = ts.tz_localize(<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区</span></span><br><span class="line">ts_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br><span class="line"><span class="comment"># 独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware）</span></span><br><span class="line">stamp = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>)</span><br><span class="line">stamp_utc = stamp.tz_localize(<span class="string">'utc'</span>)</span><br><span class="line">stamp_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br></pre></td></tr></table></figure>

<p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/7/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'B'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">'Europe/London'</span>)</span><br><span class="line">ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">'Europe/Moscow'</span>)</span><br><span class="line">result = ts1 + ts2</span><br></pre></td></tr></table></figure>

<h3 id="时期及其算术运算"><a href="#时期及其算术运算" class="headerlink" title="时期及其算术运算"></a>时期及其算术运算</h3><p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及频率符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = pd.Period(<span class="number">2007</span>, freq=<span class="string">'A-DEC'</span>) <span class="comment">#表示的是从2007年1月1日到2007年12月31日之间的整段时间</span></span><br><span class="line"><span class="comment"># 对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果</span></span><br><span class="line">p + <span class="number">5</span>  <span class="comment"># Period('2012', 'A-DEC')</span></span><br><span class="line"><span class="comment"># period_range函数可用于创建规则的时期范围</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-06-30'</span>, freq=<span class="string">'M'</span>) <span class="comment"># 返回PeriodIndex对象</span></span><br><span class="line"><span class="comment"># 字符串数组，可以使用PeriodIndex类：</span></span><br><span class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</span><br><span class="line">index = pd.PeriodIndex(values, freq=<span class="string">'Q-DEC'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h4><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-DEC'</span>)<span class="comment"># Period('2007', 'A-DEC')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)<span class="comment"># Period('2007-01', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'end'</span>)<span class="comment">#  Period('2007-12', 'M')</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-JUN'</span>)</span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'start'</span>)  <span class="comment"># Period('2006-07', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2007-06', 'M')</span></span><br><span class="line"><span class="comment"># 完整的PeriodIndex或TimeSeries的频率转换方式也是如此</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq=<span class="string">'A-DEC'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h4><p>时期”2012Q4”根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）</span></span><br><span class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>) <span class="comment"># Period('2012Q4', 'Q-JAN')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>) <span class="comment"># Period('2011-11-01', 'D')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2012-01-31', 'D')</span></span><br><span class="line"><span class="comment"># 获取该季度倒数第二个工作日下午4点的时间戳</span></span><br><span class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span> <span class="comment"># Period('2012-01-30 16:00', 'T')</span></span><br><span class="line">p4pm.to_timestamp() <span class="comment"># Timestamp('2012-01-30 16:00:00')</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="将Timestamp转换为Period（及其反向过程）"><a href="#将Timestamp转换为Period（及其反向过程）" class="headerlink" title="将Timestamp转换为Period（及其反向过程）"></a>将Timestamp转换为Period（及其反向过程）</h4><p>to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引，要转换回时间戳，使用to_timestamp》</p>
<h4 id="通过数组创建PeriodIndex"><a href="#通过数组创建PeriodIndex" class="headerlink" title="通过数组创建PeriodIndex"></a>通过数组创建PeriodIndex</h4>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>Chrome书签同步</title>
    <url>/2020/08/27/Chrome%E4%B9%A6%E7%AD%BE%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>最近一直在用自己的笔记本工作，有些书签没有同步到办公室电脑上，今天刚好到办公室了，设置好VPN，点击同步，竟然没有同步，后续删除账号再重新登录也没能解决。</p>
<a id="more"></a>

<p><strong>手动大法</strong>: 将笔记本电脑上的bookmarks（一般在C:\Users\username\AppData\Local\Google\Chrome\User Data\Default）拷贝到台式机相应的文件夹下。</p>
<p><strong>如何恢复书签</strong>： C:\Users\username\AppData\Local\Google\Chrome\User Data\Default 该目录下一般会有几天前的备份文件bookmarks.bak，将其重命名为bookmarks即可。</p>
<p>PS：最后删除账号，重新添加搞定了。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之表情，删除线和任务列表</title>
    <url>/2020/08/29/Markdown%E4%B9%8B%E8%A1%A8%E6%83%85%EF%BC%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>###表情</p>
<p><strong>aliases编码：语法：</strong> <code>:&lt;emoji&gt;:</code></p>
<p>🔽 😓😄</p>
<a id="more"></a>

<p>可查表：</p>
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>
<p><a href="https://www.cnblogs.com/minghaiJ/p/10685965.html" target="_blank" rel="noopener">https://www.cnblogs.com/minghaiJ/p/10685965.html</a></p>
<p><strong>hexdecimal编码：语法：</strong> <code>&amp;#xCODE;</code> </p>
<p>可以从 <a href="https://link.zhihu.com/?target=https%3A//apps.timwhitlock.info/emoji/tables/unicode%23block-4-enclosed-characters">Emoji Unicode Tables</a> 中查到表情的Unicode编码，去掉开头U+即为code。(typora不支持ORZ)</p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p>
<p>###任务线</p>
<p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<del>删除文本</del>的样式。</p>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 逛街</span><br><span class="line">- [ ] 看电影</span><br><span class="line">- [ ] 约泡</span><br></pre></td></tr></table></figure>

<ul>
<li><input disabled="" type="checkbox"> 吃饭</li>
<li><input disabled="" type="checkbox"> 逛街</li>
<li><input disabled="" type="checkbox"> 看电影</li>
<li><input disabled="" type="checkbox"> 约泡</li>
</ul>
<p>参考：<a href="https://www.jianshu.com/p/092de536d948" target="_blank" rel="noopener">https://www.jianshu.com/p/092de536d948</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>《Scikit-Learn与TensorFlow机器学习实用指南》-LAPTOP-CSVRUNHI</title>
    <url>/2020/08/25/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B-LAPTOP-CSVRUNHI/</url>
    <content><![CDATA[<p><a href="https://www.cntofu.com/book/27/docs/2.%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">https://www.cntofu.com/book/27/docs/2.一个完整的机器学习项目.md</a></p>
<p><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">https://github.com/ageron/handson-ml2</a></p>
<p><a href="https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88.md" target="_blank" rel="noopener">https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/</a></p>
<p><a href="https://www.jianshu.com/p/3470a6efbe8d" target="_blank" rel="noopener">https://www.jianshu.com/p/3470a6efbe8d</a></p>
<a id="more"></a>

<h2 id="《Scikit-Learn与TensorFlow机器学习实用指南》"><a href="#《Scikit-Learn与TensorFlow机器学习实用指南》" class="headerlink" title="《Scikit-Learn与TensorFlow机器学习实用指南》"></a>《Scikit-Learn与TensorFlow机器学习实用指南》</h2><h3 id="第01章-机器学习概览"><a href="#第01章-机器学习概览" class="headerlink" title="第01章 机器学习概览"></a>第01章 机器学习概览</h3><ol>
<li><p>os.makedirs(IMAGES_PATH, exist_ok=True)</p>
</li>
<li><p>pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True)</p>
<p>left_index和right_index：指定是否以索引为参考进行合并</p>
<p>​</p>
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol>
<li>如何定义机器学习？</li>
</ol>
<blockquote>
<p>机器学习是通过编程让计算机从数据中进行学习的科学（和艺术）。</p>
<p><strong>更广义的概念：</strong></p>
<p>机器学习是让计算机具有学习的能力，无需进行明确编程。 —— 亚瑟·萨缪尔，1959</p>
<p><strong>工程性的概念：</strong></p>
<p>计算机程序利用经验 E 学习任务 T，性能是 P，如果针对任务 T 的性能 P 随着经验 E 不断增长，则称为机器学习。 —— 汤姆·米切尔，1997</p>
</blockquote>
<ol start="2">
<li>机器学习可以解决的四类问题？</li>
</ol>
<blockquote>
<p>分类，回归，聚类，降维</p>
<p>机器学习可以根据训练时监督的量和类型进行分类。主要有四类：监督学习、非监督学习、半监督学习和强化学习。</p>
</blockquote>
<ol start="3">
<li>什么是带标签的训练集？</li>
</ol>
<blockquote>
<p>在监督学习中，用来训练算法的训练数据包含了答案，称为标签。</p>
</blockquote>
<ol start="4">
<li>最常见的两个监督任务是什么？</li>
</ol>
<blockquote>
<ol>
<li>分类：例如垃圾邮件过滤器：用许多带有归类（垃圾邮件或普通邮件）的邮件样本进行训练，过滤器必须还能对新邮件进行分类。</li>
<li>回归：预测目标数值，例如给出一些特征（里程数、车龄、品牌等等）称作预测值，来预测一辆汽车的价格。。要训练这个系统，需要给出大量汽车样本，包括它们的预测值和标签（即，它们的价格）。</li>
</ol>
</blockquote>
<ol start="5">
<li>指出四个常见的非监督任务？</li>
</ol>
<blockquote>
<ol>
<li><strong>聚类算法</strong> ，检测相似访客的分组。假设有一份关于博客访客的大量数据，不告诉算法某个访客属于哪一类：它会自己找出关系，无需帮助。例如，算法可能注意到 40% 的访客是喜欢漫画书的男性，通常是晚上访问，20% 是科幻爱好者，他们是在周末访问等等。如果使用<strong>层次聚类分析</strong> ，它可能还会细分每个分组为更小的组。这可以帮助你为每个分组定位博文。</li>
<li><strong>可视化算法</strong> ：给算法大量复杂的且不加标签的数据，算法输出数据的2D或3D图像。算法会试图保留数据的结构（即尝试保留输入的独立聚类，避免在图像中重叠），这样就可以明白数据是如何组织起来的，也许还能发现隐藏的规律。</li>
<li><strong>降维</strong> ：降维的目的是简化数据、但是不能失去大部分信息。做法之一是合并若干相关的特征。例如，汽车的里程数与车龄高度相关，降维算法就会将它们合并成一个，表示汽车的磨损。这叫做<strong>特征提取</strong> 。</li>
<li><strong>异常检测（anomaly detection）</strong> ：例如，检测异常的信用卡转账以防欺诈，检测制造缺陷，或者在训练之前自动从训练数据集去除异常值。异常检测的系统使用正常值训练的，当它碰到一个新实例，它可以判断这个新实例是像正常值还是异常值。</li>
</ol>
</blockquote>
<ol start="6">
<li>要让一个机器人能在各种未知地形行走，你会采用什么机器学习算法？</li>
</ol>
<blockquote>
<p>强化学习：</p>
</blockquote>
<ol start="7">
<li>要对你的顾客进行分组，你会采用哪类算法？</li>
</ol>
<blockquote>
<p>非监督学习</p>
</blockquote>
<ol start="8">
<li>垃圾邮件检测是监督学习问题，还是非监督学习问题？</li>
</ol>
<blockquote>
<p>监督学习：因为有标签</p>
</blockquote>
<ol start="9">
<li>什么是在线学习系统？</li>
</ol>
<blockquote>
<p>从导入的数据流进行持续学习</p>
<p>在在线学习中，是用数据实例持续地进行训练，可以一次一个或一次几个实例（称为小批量）。每个学习步骤都很快且廉价，所以系统可以动态地学习收到的最新数据</p>
<p><img src="https://github.com/apachecn/hands-on-ml-zh/raw/master/images/chapter_1/1-13.png" alt="img"></p>
</blockquote>
<ol start="10">
<li>什么是核外学习？</li>
</ol>
<blockquote>
<p>在线学习算法也适用于在超大数据集（一台计算机不足以用于存储它）上训练系统（这称作核外学习，<em>out-of-core</em> learning）。算法每次只加载部分数据，用这些数据进行训练，然后重复这个过程，直到使用完所有数据</p>
</blockquote>
<ol start="11">
<li>什么学习算法是用相似度做预测？</li>
</ol>
<blockquote>
<p>基于实例学习：系统先用记忆学习案例，然后使用相似度测量推广到新的例子</p>
<p>例如，垃圾邮件检测器，不仅能标记和已知的垃圾邮件相同的邮件，也要能标记类似垃圾邮件的邮件。需要测量两封邮件的相似性。一个（简单的）相似度测量方法是统计两封邮件包含的相同单词的数量。如果一封邮件含有许多垃圾邮件中的词，就会被标记为垃圾邮件。</p>
</blockquote>
<ol start="12">
<li>模型参数和学习算法的超参数的区别是什么？</li>
</ol>
<blockquote>
<p>学习算法搜寻模型参数值，使代价函数最小</p>
<p>超参数（hyperparameter）是一个学习算法的参数（而不是模型的），控制正则化的度。</p>
</blockquote>
<ol start="13">
<li>基于模型学习的算法搜寻的是什么？最成功的策略是什么？基于模型学习如何做预测？</li>
</ol>
<blockquote>
<p>搜寻使得代价函数（测量线性模型的预测值和训练样本之间的距离差）最小的模型参数</p>
<p>线性回归算法</p>
<p>研究数据-选择模型-用训练数据进行训练（学习算法搜寻模型参数值，使得代价函数最小）-使用模型对新案例进行预测（这称作推断）</p>
</blockquote>
<ol start="14">
<li>机器学习的四个主要挑战是什么？</li>
</ol>
<blockquote>
<p>训练数据量不足</p>
<p>没有代表性的训练数据</p>
<p>低质量数据</p>
<p>不相关的特征</p>
<p>过拟合</p>
<p>欠拟合</p>
</blockquote>
<ol start="15">
<li>如果模型在训练集上表现好，但推广到新实例表现差，问题是什么？给出三个可能的解决方案。</li>
</ol>
<blockquote>
<p>过拟合：利用超参数正则化</p>
<p>不相关特征：</p>
<ul>
<li>特征选择：在所有存在的特征中选取最有用的特征进行训练。</li>
<li>特征提取：组合存在的特征，生成一个更有用的特征（如前面看到的，可以使用降维算法）。</li>
<li>收集新数据创建新特征。</li>
</ul>
<p>低质量数据：如果训练集中的错误、异常值和噪声（错误测量引入的）太多，系统检测出潜在规律的难度就会变大，性能就会降低。</p>
<ul>
<li>如果一些实例是明显的异常值，最好删掉它们或尝试手工修改错误；</li>
<li>如果一些实例缺少特征（比如，你的 5% 的顾客没有说明年龄），你必须决定是否忽略这个属性、忽略这些实例、填入缺失值（比如，年龄中位数），或者训练一个含有这个特征的模型和一个不含有这个特征的模型，等等。</li>
</ul>
</blockquote>
<ol start="16">
<li>什么是测试集，为什么要使用它？</li>
</ol>
<blockquote>
<p>测试集：用来训练模型的数据集</p>
</blockquote>
<ol start="17">
<li>验证集的目的是什么？</li>
</ol>
<blockquote>
<p>验证集：数据中分出来，对模型进行测试的数据集。</p>
<p>评估模型推广到新样本的效果（即对新样本的性能），可以将模型部署到生产环境，观察它的性能。这么做可以，但如果模型的性能很差，就会引起用户抱怨。更好的选项是将数据分成训练集和测试集。用训练集进行训练，用测试集进行测试。对新样本的错误率称作<strong>推广错误（或样本外错误）</strong> ，通过模型对测试集的评估，可以预估这个错误。这个值可以我们模型对新样本的性能。</p>
</blockquote>
<ol start="18">
<li>如果用测试集调节超参数，会发生什么？</li>
</ol>
<blockquote>
<p>过拟合</p>
<p>在测试集上多次测量了推广误差率，调整了模型和超参数，以使模型最适合这个集合。这意味着模型对新数据的性能不会高。</p>
</blockquote>
<ol start="19">
<li>什么是交叉验证，为什么它比验证集好？</li>
</ol>
<blockquote>
<p>交叉验证：训练集分成互补的子集，每个模型用不同的子集训练，再用剩下的子集验证。一旦确定模型类型和超参数，最终的模型使用这些超参数和全部的训练集进行训练，用测试集得到推广误差率。</p>
<p>而使用验证集：用训练集和多个超参数训练多个模型，选择在验证集上有最佳性能的模型和超参数。当对模型满意时，用测试集再做最后一次测试，以得到推广误差率的预估，会“浪费”过多训练数据在验证集上。</p>
</blockquote>
</li>
</ol>
<h3 id="第02章-一个完整的机器学习项目"><a href="#第02章-一个完整的机器学习项目" class="headerlink" title="第02章 一个完整的机器学习项目"></a>第02章 一个完整的机器学习项目</h3><p>[Python API：crc32函数 计算CRC校验值](<a href="https://b" target="_blank" rel="noopener">https://b</a></p>
<p><a href="https://blog.csdn.net/liuyu60305002/article/details/6307152" target="_blank" rel="noopener">模2运算</a></p>
<p><a href="https://blog.csdn.net/sparkliang/article/details/5671510" target="_blank" rel="noopener">CRC32算法详细推导</a></p>
<blockquote>
<p>crc32用于计算 <em>data</em> 的 CRC (A cyclic redundancy check 32，循环冗余校验) 值。计算的结果是一个 32 位的整数。本质是<strong>模2除法模2运算包括模2加、模2减、模2乘、模2除四种二进制运算，不考虑进位和借位）</strong>， 的余数，采用的除数不同，CRC的类型也就不一样。通常，CRC的除数用生成多项式来表示。</p>
<p>此算法没有加密强度，不应用于身份验证和数字签名。仅<strong>为验证数据的正确性</strong> ，不适合作为通用散列算法。</p>
<h4 id="特点：检错能力极强，开销小等"><a href="#特点：检错能力极强，开销小等" class="headerlink" title="特点：检错能力极强，开销小等"></a>特点：检错能力极强，开销小等</h4><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>CRC 算法是以 GF(2) 多项式算术为数学基础的， GF(2) 多项式中只有一个变量 x ，其系数也只有 0 和 1 ，比如：</p>
<p>​    1 <em>x^6 + 0</em>x^5 + 1<em>x^4 + 0</em>x^3 + 0<em>x^2 +1</em>x^1 + 1*x^0</p>
<p>​       = x^6 + x^4 + x + 1</p>
<p>加减运算不考虑进位和退位。说白了就是下面的运算规则：</p>
<p>​    0 + 0 = 0    0 - 0 = 0</p>
<p>​    0 + 1 = 1    0 - 1 = 1</p>
<p>​    1 + 0 = 1    1 - 0 = 1</p>
<p>​    1 + 1 = 0    1 - 1 = 0<br>看看这个规则，其实就是一个<strong>异或运算</strong> 。</p>
<p>每个生成多项式的系数只能是 0 或 1 ，因此可以把它转化为二进制形式表示， 比如 g(x)=x^4 + x + 1 ，那么 g(x) 对应的二进制形式就是 10011 ， 于是把 GF(2) 多项式的除法转换成了二进制形式，和普通除法没有区别，只是加减运算没有进位和退位。</p>
<p>比如基于上述规则计算 11010/1001 ，那么商是 11 ，余数就是 1。</p>
<h4 id="CRC-校验的基本过程"><a href="#CRC-校验的基本过程" class="headerlink" title="CRC 校验的基本过程"></a>CRC 校验的基本过程</h4><p>采用 CRC 校验时，发送方和接收方用同一个生成多项式 g(x) ， g(x) 是一个 GF(2) 多项式，并且 g(x) 的首位和最后一位的系数必须为 1 。</p>
<p>CRC 的处理方法是：发送方用发送数据的二进制多项式 t(x) 除以 g(x) ，得到余数 y(x) 作为 CRC 校验码。校验时，以计算的校正结果是否为 0 为据，判断数据帧是否出错。设生成多项式是 r 阶的（最高位是 x^r ）具体步骤如下面的描述。</p>
<p>发送方：</p>
<p>1 ）在发送的 m 位数据的二进制多项式 t(x) 后添加 r 个 0 ，扩张到 m+ r 位，以容纳 r 位的校验码，追加 0 后的二进制多项式为  T(x) ；</p>
<p>2 ）用 T(x) 除以生成多项式 g(x) ，得到 r 位的余数 y(x) ，它就是 CRC 校验码；</p>
<p>3 ）把 y(x) 追加到 t(x) 后面，此时的数据 s(x) 就是包含了 CRC 校验码的待发送字符串；由于 s(x) = t(x) y(x) ，因此 s(x) 肯定能被 g(x) 除尽。</p>
<p>接收方：</p>
<p>1 ）接收数据 n(x) ，这个 n(x) 就是包含了 CRC 校验码的 m+r 位数据；</p>
<p>2 ）计算 n(x) 除以 g(x) ，如果余数为 0 则表示传输过程没有错误，否则表示有错误。从 n(x) 去掉尾部的 r 位数据，得到的就是原始数据。</p>
<p>生成多项式不是随意选择的，以下是一些标准的 CRC 算法的生成多项式：</p>
<table>
<thead>
<tr>
<th>标准</th>
<th>生成多项式</th>
<th>16 进制表示</th>
</tr>
</thead>
<tbody><tr>
<td>CRC12</td>
<td>x^12 + x^11 + x^3 + x^2 + x + 1</td>
<td>0x80F</td>
</tr>
<tr>
<td>CRC16</td>
<td>x^16 + x^15 + x^2 + 1</td>
<td>0x8005</td>
</tr>
<tr>
<td>CRC16-CCITT</td>
<td>x^16 + x^12 + x^5 + 1</td>
<td>0x1021</td>
</tr>
<tr>
<td>CRC32</td>
<td>x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1</td>
<td>0x04C11DB7</td>
</tr>
</tbody></table>
<p>在python 3.0 之后: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <strong>crc32(data) &amp; 0xffffffff</strong>。</p>
</blockquote>
<p><strong>问题：</strong> </p>
<p>使用本章的房产数据集：</p>
<ol>
<li>尝试一个支持向量机回归器（<code>sklearn.svm.SVR</code>），使用多个超参数，比如<code>kernel=&quot;linear&quot;</code>（多个超参数<code>C</code>值）。现在不用担心这些超参数是什么含义。最佳的<code>SVR</code>预测表现如何？</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line">&gt;svm_reg = SVR(kernel=<span class="string">"linear"</span>)</span><br><span class="line">&gt;svm_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">&gt;housing_predictions = svm_reg.predict(housing_prepared)</span><br><span class="line">&gt;svm_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">&gt;svm_rmse = np.sqrt(svm_mse)</span><br><span class="line">&gt;svm_rmse <span class="comment"># output: 111094.6308539982</span></span><br></pre></td></tr></table></figure>

<p>结果不好。</p>
</blockquote>
<ol start="2">
<li>尝试用<code>RandomizedSearchCV</code>替换<code>GridSearchCV</code>。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line">&gt;<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">&gt;param_distribs = &#123;</span><br><span class="line">       <span class="string">'n_estimators'</span>: randint(low=<span class="number">1</span>, high=<span class="number">200</span>),</span><br><span class="line">       <span class="string">'max_features'</span>: randint(low=<span class="number">1</span>, high=<span class="number">8</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;forest_reg = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search = RandomizedSearchCV(forest_reg, param_distributions=param_distribs,</span><br><span class="line">                               n_iter=<span class="number">10</span>, cv=<span class="number">5</span>, scoring=<span class="string">'neg_mean_squared_error'</span>, random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li>尝试在准备流水线中添加一个只选择最重要属性的转换器。</li>
</ol>
<blockquote>
<p>​</p>
</blockquote>
<ol start="4">
<li>尝试创建一个单独的可以完成数据准备和最终预测的流水线。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;full_pipeline_with_predictor = Pipeline([</span><br><span class="line">       (<span class="string">"preparation"</span>, full_pipeline),</span><br><span class="line">       (<span class="string">"linear"</span>, LinearRegression())</span><br><span class="line">   ])</span><br><span class="line"></span><br><span class="line">&gt;full_pipeline_with_predictor.fit(housing, housing_labels)</span><br><span class="line">&gt;full_pipeline_with_predictor.predict(some_data)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="5">
<li>使用<code>GridSearchCV</code>自动探索一些准备过程中的候选项。</li>
</ol>
<h3 id="第03章-分类"><a href="#第03章-分类" class="headerlink" title="第03章 分类"></a>第03章 分类</h3><p>​</p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Jupyter Notebook中使用Python虚拟环境？</title>
    <url>/2020/08/25/%E5%A6%82%E4%BD%95%E5%9C%A8Jupyter%20Notebook%E4%B8%AD%E4%BD%BF%E7%94%A8Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%9F-LAPTOP-CSVRUNHI/</url>
    <content><![CDATA[<p>电脑中多版本python并存，直接安装过python，使用过anaconda全家桶，同时创建过虚拟环境（虽然我也不知道两个都是python3.7为啥要用虚拟环境），这就导致了一个问题。</p>
<a id="more"></a>

<h2 id="虚拟环境下运行spyder"><a href="#虚拟环境下运行spyder" class="headerlink" title="虚拟环境下运行spyder"></a>虚拟环境下运行spyder</h2><p>在打开spyder时，默认使用base，如何使用虚拟环境呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入环境后</span></span><br><span class="line">spyder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经打开spyder了</span></span><br><span class="line">spyder --new-instance</span><br></pre></td></tr></table></figure>

<h2 id="Jupyter-notebook使用虚拟环境"><a href="#Jupyter-notebook使用虚拟环境" class="headerlink" title="Jupyter notebook使用虚拟环境"></a>Jupyter notebook使用虚拟环境</h2><p>即便通过anaconda创造了新的虚拟环境，但是在jupyter 中并没有体现出来。</p>
<blockquote>
<p>尝试过<code>conda activate env</code> 进入虚拟环境，再执行jupyter notebook，结果还是使用默认python（D:\Program Files (x86)\Anaconda3\py37\python.exe’），此时会出现一些包import失败的问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何查看使用的是哪个版本的python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure>

<h3 id="解决办法1："><a href="#解决办法1：" class="headerlink" title="解决办法1："></a>解决办法1：</h3><p>直接在sys.path这个列表append虚拟环境下的python路径和python库路径。</p>
<p>但是这种解决方案没有永久性，退出之后重新打开该文件运行时，则又会import失败，输出sys.path，发现之前加入的路径也不存在了。</p>
<h3 id="解决办法2："><a href="#解决办法2：" class="headerlink" title="解决办法2："></a>解决办法2：</h3><p><strong>用anaconda内生插件解决问题</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install nb_conda</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已有的kernels</span></span><br><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>

<p>再次启动jupyter notebook，就能看到<strong>所有虚拟环境</strong>都显示出来了。</p>
<p><strong>用jupyter插件解决问题</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line">conda install ipykernel</span><br><span class="line">python -m ipykernel install --name --display-name</span><br></pre></td></tr></table></figure>

<p>网上还有方法是安装ipykernel，不知道为什么，我可以看到kernel显示了虚拟环境，但是切换之后，没有效果，sys.exectubale仍然输出默认python的路径。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>anaconda powershell prompt 和 anaconda prompt的区别：前者多了一些linux命令，如pwd等，类似windows下cmd和windows powershell的区别。</li>
<li>虽然可以在prompt中通过cd切换文件夹，再打开jupyter notebook，或者在jupyter notebook命令后指定文件夹路径，但略显繁琐。<ul>
<li>在windows powershell下也可以运行jupyter notebook，所以可以在windows下打开文件夹，shift+鼠标右键，打开windows powershell，输入jupyter notebook命令</li>
<li>打开目标文件夹，选中上方文件位置栏，输入jupyter notebook即可</li>
<li>另外，如果想在windows powershell中激活虚拟环境，可执行：<code>conda init</code></li>
</ul>
</li>
</ol>
<h2 id="jupyter-notebook快捷键"><a href="#jupyter-notebook快捷键" class="headerlink" title="jupyter notebook快捷键"></a>jupyter notebook快捷键</h2><p>Jupyter Notebook 有两种键盘输入模式。</p>
<ol>
<li>编辑模式（enter进入），可以向单元中键入代码或文本；此时单元框线为绿色。</li>
<li>命令模式（Esc开启），键盘输入运行程序命令；此时单元框线为灰蓝色。</li>
</ol>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>tab</td>
<td>代码补全或缩进</td>
<td>Ctrl+Up</td>
<td>跳到单元开头</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>shift+tab</td>
<td>提示</td>
<td>Ctrl+End</td>
<td>跳到单元末尾</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>ctrl+]</td>
<td>缩进</td>
<td>Ctrl+Down</td>
<td>跳到单元末尾</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>ctrl+[</td>
<td>解除缩进</td>
<td>Ctrl+Left</td>
<td>跳到左边一个字首</td>
<td>Ctrl+Shift+-</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+A</td>
<td>全选</td>
<td>Ctrl+Right</td>
<td>跳到右边一个字首</td>
<td>Ctrl+Shift+Subtract</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+Z</td>
<td>复原</td>
<td>Ctrl+Backspace</td>
<td>删除前面一个字</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
</tr>
<tr>
<td>ctrl+shift+z</td>
<td>再做</td>
<td>Ctrl+Delete</td>
<td>删除后面一个字</td>
<td>Shift</td>
<td>忽略</td>
</tr>
<tr>
<td>ctrl+y</td>
<td>再做</td>
<td>Esc</td>
<td>进入命令模式</td>
<td>Up</td>
<td>光标上移或转入上一单元</td>
</tr>
<tr>
<td>ctrl+Home</td>
<td>跳到单元开头</td>
<td>Ctrl+M</td>
<td>进入命令模式</td>
<td>Down</td>
<td>光标下移或转入下一单元</td>
</tr>
</tbody></table>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>enter</td>
<td>转入编辑模式</td>
<td>C</td>
<td>复制选中的单元</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>Y</td>
<td>单元转入代码状态</td>
<td>V</td>
<td>粘贴到下方单元</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>M</td>
<td>单元转入markdown状态</td>
<td>Z</td>
<td>恢复删除的最后一个单元</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>R</td>
<td>单元转入raw状态</td>
<td>DD</td>
<td>删除选中的单元</td>
<td>shift+K</td>
<td>扩大选中上方单元</td>
</tr>
<tr>
<td>1</td>
<td>设定 1 级标题</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
<td>shift+J</td>
<td>扩大选中下方单元</td>
</tr>
<tr>
<td>2</td>
<td>设定 12级标题</td>
<td>S</td>
<td>文件存盘</td>
<td>shift+O</td>
<td>转换输出滚动</td>
</tr>
<tr>
<td>A</td>
<td>在上方插入新单元</td>
<td>L</td>
<td>转换行号</td>
<td>shift</td>
<td>忽略</td>
</tr>
<tr>
<td>B</td>
<td>在下方插入新单元</td>
<td>O</td>
<td>转换输出</td>
<td>K</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>X</td>
<td>剪切选中的单元</td>
<td>Q</td>
<td>关闭页面</td>
<td>J</td>
<td>选中下方单元</td>
</tr>
<tr>
<td>shift+V</td>
<td>粘贴到上方单元</td>
<td>H</td>
<td>显示快捷键帮助</td>
<td>Up</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>shift+M</td>
<td>合并选中的单元</td>
<td>space</td>
<td>向下滚动</td>
<td>Down</td>
<td>选中下方单元</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/w55100/article/details/88925697" target="_blank" rel="noopener">简书：使用anaconda虚拟环境运行Jupyter Notebook详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50456606" target="_blank" rel="noopener">Jupyter notebok 环境配置，与kernel切换（切换虚拟环境）</a></p>
<p><a href="https://blog.csdn.net/guolaoban11/article/details/103469952?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">jupyter notebook 打开任意文件夹，最简捷！！</a></p>
<p><a href="https://blog.csdn.net/lzbmc/article/details/102955750" target="_blank" rel="noopener">Jupyter Notebook在指定文件夹（位置）打开</a></p>
<p><a href="https://blog.csdn.net/lawme/article/details/51034543" target="_blank" rel="noopener">Jupyter Notebook 的快捷键</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown数学符号和公式</title>
    <url>/2020/08/29/Markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F%20193445/</url>
    <content><![CDATA[<p>Markdown中数学符号和公式的书写规则和<code>latex</code>非常像。</p>
<p>行内公式或数学符号使用<code>$</code>符号包裹Tex命令即可。</p>
<p>单独的公式段落可以用<code>$$</code>包裹，或者点击“段落” $\rightarrow$ “公式块”，或者使用快捷键Shift+Ctrl+M</p>
<a id="more"></a>

<p>常用的数学符号：</p>
<p>###希腊字母</p>
<p><strong>小写</strong> \alpha \beta \chi \delta \epsilon \eta \gamma \kappa \lambda \mu \nu \omega \tau \theta \xi \zeta </p>
<p>$\alpha \beta \chi \delta \epsilon \eta \gamma \kappa \lambda \mu \nu \omega \tau \theta \xi \zeta $</p>
<p><strong>大写</strong> 将第一个字母大写即可： $\Alpha \Beta \Chi \Delta \Epsilon $</p>
<h3 id="操作符-关系符"><a href="#操作符-关系符" class="headerlink" title="操作符 关系符"></a>操作符 关系符</h3><p>常用的有 ：</p>
<p>\cdot  \pm \leq \geq \gg \ll \times \div \oplus \otimes \equiv \approx \because \therefore</p>
<p>$\cdot  \pm \leq \geq \gg \ll \times \div \oplus \otimes \equiv \approx \because \therefore$</p>
<h3 id="数学着重号"><a href="#数学着重号" class="headerlink" title="数学着重号"></a>数学着重号</h3><p>\ddot{a} \bar{a} \dot{a} \hat{a} \vec{a} \check{a}</p>
<p>$\ddot{a} \bar{a} \dot{a} \hat{a} \vec{a} \check{a}$</p>
<h3 id="各式箭头"><a href="#各式箭头" class="headerlink" title="各式箭头"></a>各式箭头</h3><p>\leftarrow \rightarrow \uparrow \downarrow</p>
<p>$\leftarrow \rightarrow \uparrow \downarrow$</p>
<p>\Leftarrow \Rightarrow \Uparrow \Downarrow</p>
<p>$\Leftarrow \Rightarrow \Uparrow \Downarrow$</p>
<p>\longleftarrow \longrightarrow </p>
<p>$\longleftarrow \longrightarrow $</p>
<p>\leftrightarrow  \updownarrow</p>
<p>$\leftrightarrow  \updownarrow$</p>
<h3 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h3><p>\infty  \forall \nabla \partial \varnothing \hbar \exists</p>
<p>$\infty  \forall \nabla \partial \varnothing \hbar \exists$</p>
<p>\sum  \int  \prod \oint  \iint</p>
<p>$\sum  \int  \prod \oint  \iint$</p>
<h3 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h3><p>\frac{a}{b} $\frac{a}{b}$</p>
<p>\sqrt[n]{a} $\sqrt[n]{a} $</p>
<p>\overline{abc} $\overline{abc}$</p>
<p>\widehat{abc} $\widehat{abc}$</p>
<p>\overrightarrow{abc} $\overrightarrow{abc}$</p>
<p>\left{ a b c}\right</p>
<p>a = \left { \begin{array}{c} x^2 \ 2x \0 \end{array} \right } $a = \left { \begin{array}{c} x^2 \ 2x \0 \end{array} \right.$</p>
<p>\left ( \begin{array}{cc} a &amp; b \ c &amp; d\end{array} \right) $\left ( \begin{array}{cc} a &amp; b \ c &amp; d\end{array} \right)$</p>
<hr>
<p>参考：</p>
<p><a href="https://blog.csdn.net/wait_for_eva/article/details/84307306" target="_blank" rel="noopener">typora-数学符号</a> </p>
<p><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455" target="_blank" rel="noopener">使用Typora添加数学公式</a></p>
<p><a href="https://www.cnblogs.com/waleswood/p/6401232.html" target="_blank" rel="noopener">希腊字母、拉丁字母、Markdown、拼写与读音中英对照表</a></p>
<p><a href="https://blog.csdn.net/katherine_hsr/article/details/79179622" target="_blank" rel="noopener">Markdown数学符号&amp;公式</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文件恢复</title>
    <url>/2020/08/29/Markdown%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>忘了点保存，打开一看文件是空的。</p>
<ol>
<li>打开Typora $\rightarrow $文件$\rightarrow $$偏好设置</li>
<li>向下滚动到 “保存 &amp; 恢复” 区域</li>
<li>点击 “恢复未保存的草稿”</li>
</ol>
<p>方法参考：<a href="https://blog.csdn.net/makesomethings/article/details/90181198" target="_blank" rel="noopener">https://blog.csdn.net/makesomethings/article/details/90181198</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
