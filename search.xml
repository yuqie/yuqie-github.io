<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Chrome书签同步</title>
    <url>/2020/08/27/Chrome%E4%B9%A6%E7%AD%BE%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>最近一直在用自己的笔记本工作，有些书签没有同步到办公室电脑上，今天刚好到办公室了，设置好VPN，点击同步，竟然没有同步，后续删除账号再重新登录也没能解决。</p>
<a id="more"></a>
<p><strong>手动大法</strong>: 将笔记本电脑上的bookmarks（一般在C:\Users\username\AppData\Local\Google\Chrome\User Data\Default）拷贝到台式机相应的文件夹下。</p>
<p><strong>如何恢复书签</strong>： C:\Users\username\AppData\Local\Google\Chrome\User Data\Default 该目录下一般会有几天前的备份文件bookmarks.bak，将其重命名为bookmarks即可。</p>
<p>PS：最后删除账号，重新添加搞定了。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之表格</title>
    <url>/2020/07/25/Markdown%E4%B9%8B%E8%A1%A8%E6%A0%BC/</url>
    <content><![CDATA[<h2 id="1-Markdown自带表格编辑语法"><a href="#1-Markdown自带表格编辑语法" class="headerlink" title="1. Markdown自带表格编辑语法"></a>1. Markdown自带表格编辑语法</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"> |水果        | 价格    |  数量  |</span><br><span class="line"> |:--------   | -----:   | :----: |</span><br><span class="line">|香蕉        | $1      |   5    |</span><br><span class="line"> |苹果        | $1      |   6    |</span><br><span class="line"> |草莓        | $1      |   7    |</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>效果：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">水果</th>
<th style="text-align:right">价格</th>
<th style="text-align:center">数量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">香蕉</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:left">苹果</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:left">草莓</td>
<td style="text-align:right">$1</td>
<td style="text-align:center">7</td>
</tr>
</tbody>
</table>
</div>
<h2 id="2-HTML表格"><a href="#2-HTML表格" class="headerlink" title="2. HTML表格"></a>2. HTML表格</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生成绩表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>学号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>期中<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>期末<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>001<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>88<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>002<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>96<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>97<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<th>和<td>标签都可以显示表格单元格。不同的是<th>在单元格中加粗显示。

**<th>：定义表格内的表头单元格。此th元素内部的文本通常会呈现为粗体。**



效果：

<table>
<caption>学生成绩表</caption>
<tr>

<th>学号</th>
<th>期中</th>
<th>期末</th>

<p>&lt;/tr&gt;</p>
<tr>

<td>001</td>
<td>88</td>
<td>90</td>

<p>&lt;/tr&gt; </p>
<tr>

<td>002</td>
<td>96</td>
<td>97</td>

<p>&lt;/tr&gt;<br>&lt;/table&gt;</p>
<h2 id="3-Excel表格"><a href="#3-Excel表格" class="headerlink" title="3. Excel表格"></a>3. Excel表格</h2><p>markdown支持html语法，所以可以先使用Excel生成需要的表格，单击另存为，选择导出格式为html，此时可选择所需表格区间。保存后打开生成的html文件，将其中<code>&lt;table&gt;&lt;/table&gt;</code> 间的数据复制到markdown中即可。</p>
<p><strong>此方式可以创建复杂的表格，比如合并单元格等。</strong></p>
<h2 id="4-exceltk工具"><a href="#4-exceltk工具" class="headerlink" title="4. exceltk工具"></a>4. exceltk工具</h2><p><a href="[http://fanfeilong.github.io/](http://fanfeilong.github.io/">范飞龙</a>)开发的<a href="https://github.com/fanfeilong/exceltk" target="_blank" rel="noopener">exceltk工具</a>，通过简单的cmd命令即可把excel表格中的内容转换为Markdown所能识别的格式，直接把转换后的md格式内容复制到简书即可输出期望的表格样式。</p>
<pre><code>exceltk用例
整个表格： exceltk.exe -t md -xls xxx.xls  
          exceltk.exe -t md -xls xxx.xlsx
指定sheet：
          exceltk.exe -t md -xls xx.xls -sheet sheetname   
          exceltk.exe -t md -xls xx.xlsx -sheet sheetnameexceltk
</code></pre><h2 id="5-在线Markdown表格生成"><a href="#5-在线Markdown表格生成" class="headerlink" title="5. 在线Markdown表格生成"></a>5. 在线Markdown表格生成</h2><p>​      <a href="https://tableconvert.com/" target="_blank" rel="noopener">tableconvert</a>可以在线制作表格，并将其转为Markdown，CSV，Excel，XML，HTML等格式。</p>
<hr>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之隐藏内容</title>
    <url>/2020/07/25/Markdown%E4%B9%8B%E9%9A%90%E8%97%8F%E5%86%85%E5%AE%B9/</url>
    <content><![CDATA[<h2 id="1-HTML标签隐藏"><a href="#1-HTML标签隐藏" class="headerlink" title="1. HTML标签隐藏"></a>1. HTML标签隐藏</h2><p>Markdown内嵌html语法，所以可以用隐藏的html标签。</p>
<a id="more"></a>
<p><strong>注意：前面需空一行</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">'display: none'</span>&gt;</span></span><br><span class="line">注释</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试（在浏览器中看不到即为成功）：</p>
<div style='display: none'>
注释
</div>

<h2 id="2-HTML注释隐藏"><a href="#2-HTML注释隐藏" class="headerlink" title="2. HTML注释隐藏"></a>2. HTML注释隐藏</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注释，不会在浏览器中显示。--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">多段</span></span><br><span class="line"><span class="comment">注释，</span></span><br><span class="line"><span class="comment">不会在浏览器中显示。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试（在浏览器中看不到即为成功）：</p>
<!--注释，不会在浏览器中显示。-->
<!--
多段
注释，
不会在浏览器中显示。
-->
<h2 id="3-hack-方法隐藏"><a href="#3-hack-方法隐藏" class="headerlink" title="3. hack 方法隐藏"></a>3. hack 方法隐藏</h2><p>hack方法利用markdown的解析原理来实现注释。一般有的markdown解析器不支持上面的注释方法，这个时候就可以用hack方法。</p>
<p>hack方法比上面2种方法稳定，但是语义化太差。<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[comment]: <span class="tag">&lt;&gt;</span> (注释，不会在浏览器中显示。)</span><br><span class="line">[//]: <span class="tag">&lt;&gt;</span> (注释，不会在浏览器中显示。)</span><br><span class="line">[//]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><br>其中，这种方法最稳定，适用性最强：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[//]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><br>还可以：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">[^_^]: # (注释，不会在浏览器中显示。)</span><br></pre></td></tr></table></figure><br>测试（在浏览器中看不到即为成功）：</p>
<blockquote id="fn__^">
<sup>_^</sup>. # (注释，不会在浏览器中显示。)<a href="#reffn__^" title="Jump back to footnote [_^] in the text."> &#8617;</a>
</blockquote>
<blockquote id="fn__^">
<sup>_^</sup>. # (注释，不会在浏览器中显示。)<a href="#reffn__^" title="Jump back to footnote [_^] in the text."> &#8617;</a>
</blockquote>
<h2 id="4-HTML标签折叠"><a href="#4-HTML标签折叠" class="headerlink" title="4. HTML标签折叠"></a>4. HTML标签折叠</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">summary</span>&gt;</span><span class="tag">&lt;<span class="name">mark</span>&gt;</span><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">darkred</span>&gt;</span>摘要<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;/<span class="name">mark</span>&gt;</span><span class="tag">&lt;/<span class="name">summary</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span> -title<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">pre</span>&gt;</span><span class="tag">&lt;<span class="name">code</span>&gt;</span>  </span><br><span class="line">   隐藏代码块</span><br><span class="line">  <span class="tag">&lt;/<span class="name">code</span>&gt;</span><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>summary：折叠语法展示的摘要</p>
<p>details：折叠语法标签</p>
<p>pre：以原有格式显示元素内的文字是已经格式化的文本。</p>
<p>blockcode：表示程序的代码块。</p>
<p>code：指定代码范例。</p>
<p><strong>隐藏内容也可以是markdown格式。</strong></p>
<p><strong><em>效果</em></strong>：</p>
<details>
<summary><mark><font color=darkred>markdown隐藏内容</font></mark></summary>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;&lt;mark&gt;&lt;font color&#x3D;darkred&gt;摘要&lt;&#x2F;font&gt;&lt;&#x2F;mark&gt;&lt;&#x2F;summary&gt;</span><br><span class="line"></span><br><span class="line">隐藏内容</span><br><span class="line">&lt;&#x2F;details&gt;</span><br></pre></td></tr></table></figure>

</details>

<hr>
<p>来源：<a href="https://www.imooc.com/article/23400" target="_blank" rel="noopener">慕课网CandyBullet</a></p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之字体颜色以及背景色</title>
    <url>/2020/07/26/Markdown%E4%B9%8B%E5%AD%97%E4%BD%93%E9%A2%9C%E8%89%B2%E4%BB%A5%E5%8F%8A%E8%83%8C%E6%99%AF%E8%89%B2/</url>
    <content><![CDATA[<h2 id="字体，大小和颜色"><a href="#字体，大小和颜色" class="headerlink" title="字体，大小和颜色"></a>字体，大小和颜色</h2><a id="more"></a>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span>&gt;</span></span>我是黑体字<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"微软雅黑"</span>&gt;</span></span>我是微软雅黑<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"STCAIYUN"</span>&gt;</span></span>我是华文彩云<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">red</span>&gt;</span></span>我是红色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">#008000</span>&gt;</span></span>我是绿色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">Blue</span>&gt;</span></span>我是蓝色<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>我是尺寸<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">font</span> <span class="attr">face</span>=<span class="string">"黑体"</span> <span class="attr">color</span>=<span class="string">green</span> <span class="attr">size</span>=<span class="string">5</span>&gt;</span></span>我是黑体，绿色，尺寸为5<span class="xml"><span class="tag">&lt;/<span class="name">font</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果如下： </p>
<font face="黑体">我是黑体字</font>
<font face="微软雅黑">我是微软雅黑</font>
<font face="STCAIYUN">我是华文彩云</font>
<font color=red>我是红色</font>
<font color=#008000>我是绿色</font>
<font color=Blue>我是蓝色</font>
<font size=5>我是尺寸</font>
<font face="黑体" color=green size=5>我是黑体，绿色，尺寸为5</font>

<h2 id="文字背景色"><a href="#文字背景色" class="headerlink" title="文字背景色"></a>文字背景色</h2><p>由于 Markdown中不支持 style 标签和 style 属性，所以这里只能是通过 table, tr, td 等表格标签的 bgcolor 属性来实现背景色，将一整行看作一个表格，更改单元格的背景色（bgcolor）</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">td</span> <span class="attr">bgcolor</span>=<span class="string">blue</span>&gt;</span></span>颜色测试<span class="xml"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<table><tr><td bgcolor=blue>颜色测试</td></tr></table>

<h2 id="图片居中"><a href="#图片居中" class="headerlink" title="图片居中"></a>图片居中</h2><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">align</span>=<span class="string">right</span>&gt;</span></span><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"image/timg.jfif"</span> <span class="attr">width</span>=<span class="string">"50%"</span> <span class="attr">height</span>=<span class="string">"50%"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<div align=right><img src="image/timg.jfif" width="50%" height="50%"></div>

<hr>
<p>参考：<a href="https://blog.csdn.net/heimu24/article/details/81189700" target="_blank" rel="noopener">https://blog.csdn.net/heimu24/article/details/81189700</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown文件恢复</title>
    <url>/2020/08/29/Markdown%E6%96%87%E4%BB%B6%E6%81%A2%E5%A4%8D/</url>
    <content><![CDATA[<p>忘了点保存，打开一看文件是空的。</p>
<ol>
<li>打开Typora $\rightarrow $ 文件$\rightarrow $ 偏好设置</li>
<li>向下滚动到 “保存 &amp; 恢复” 区域</li>
<li>点击 “恢复未保存的草稿”</li>
</ol>
<p>方法参考：<a href="https://blog.csdn.net/makesomethings/article/details/90181198" target="_blank" rel="noopener">https://blog.csdn.net/makesomethings/article/details/90181198</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown之表情，删除线和任务列表</title>
    <url>/2020/08/29/Markdown%E4%B9%8B%E8%A1%A8%E6%83%85%EF%BC%8C%E5%88%A0%E9%99%A4%E7%BA%BF%E5%92%8C%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p><strong>aliases编码：语法：</strong> <code>:&lt;emoji&gt;:</code></p>
<p>🔽 😓😄</p>
<a id="more"></a>
<p>可查表：</p>
<p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/" target="_blank" rel="noopener">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p>
<p><a href="https://www.cnblogs.com/minghaiJ/p/10685965.html" target="_blank" rel="noopener">https://www.cnblogs.com/minghaiJ/p/10685965.html</a></p>
<p><strong>hexdecimal编码：语法：</strong> <code>&amp;#xCODE;</code> </p>
<p>可以从 <a href="https://link.zhihu.com/?target=https%3A//apps.timwhitlock.info/emoji/tables/unicode%23block-4-enclosed-characters">Emoji Unicode Tables</a> 中查到表情的Unicode编码，去掉开头U+即为code。(typora不支持ORZ)</p>
<h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>用HTML的语法<code>&lt;u&gt;Underline&lt;/u&gt;</code>将产生下划线<u>Underline</u>.</p>
<h3 id="任务线"><a href="#任务线" class="headerlink" title="任务线"></a>任务线</h3><p>GFM添加了删除文本的语法，这是标准的Markdown语法木有的。使用<code>~~</code>包裹的文本将会具有删除的样式，例如<code>~删除文本~</code>将产生<del>删除文本</del>的样式。</p>
<h3 id="任务列表"><a href="#任务列表" class="headerlink" title="任务列表"></a>任务列表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [ ] 吃饭</span><br><span class="line">- [ ] 逛街</span><br><span class="line">- [ ] 看电影</span><br><span class="line">- [ ] 约泡</span><br></pre></td></tr></table></figure>
<ul>
<li>[ ] 吃饭</li>
<li>[ ] 逛街</li>
<li>[ ] 看电影</li>
<li>[ ] 约泡</li>
</ul>
<h3 id="最大化快捷键"><a href="#最大化快捷键" class="headerlink" title="最大化快捷键"></a>最大化快捷键</h3><p>进去退出最大化：F11</p>
<p>参考：<a href="https://www.jianshu.com/p/092de536d948" target="_blank" rel="noopener">https://www.jianshu.com/p/092de536d948</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python之csv</title>
    <url>/2020/07/25/python%E4%B9%8Bcsv/</url>
    <content><![CDATA[<h2 id="1-什么是csv？"><a href="#1-什么是csv？" class="headerlink" title="1. 什么是csv？"></a>1. 什么是csv？</h2><p><strong>Comma Separated Values</strong> (CSV), also called called <strong>Character Separated Values</strong> or <strong>Comma Delimited files</strong>, is a file format for data storage which looks like a text file, which contains a list of data separated by commas or other characters.</p>
<a id="more"></a>
<details>
<summary><mark><font color=darkred>csv的格式特点</font></mark></summary>

- One line for each record
- Comma separated fields
- Space-characters adjacent to commas are ignored
- Fields with in-built commas are separated by double quote characters
- Fields with double quote characters must be surrounded by double quotes. Each inbuilt double quote must be represented by a pair of consecutive quotes
- Fields that contain inbuilt line-breaks must be surrounded by double quotes

</details>

<h2 id="2-为什么使用csv文件？"><a href="#2-为什么使用csv文件？" class="headerlink" title="2. 为什么使用csv文件？"></a>2. 为什么使用csv文件？</h2><p>CSV结构简单，是纯文本文件，和txt的区别仅在于后缀名不同。用来做数据存储，容量比XML小（其数据由key-value组成），功能比TXT强大，另外Excel也直接支持CSV文件的查看和生成。</p>
<h3 id="Excel-打开-CSV-文件时遇到的问题。"><a href="#Excel-打开-CSV-文件时遇到的问题。" class="headerlink" title="Excel 打开  CSV 文件时遇到的问题。"></a>Excel 打开  CSV 文件时遇到的问题。</h3><p>直接用 Excel 打开 UTF-8 编码的 CSV 文件会导致汉字部分出现乱码，原因是 Excel 以 ANSI 格式打开，不会做编码识别。打开 UTF-8 编码的 CSV 文件的方法：</p>
<h4 id="1-从数据导入文本"><a href="#1-从数据导入文本" class="headerlink" title="1. 从数据导入文本"></a>1. 从数据导入文本</h4><ul>
<li>打开 Excel </li>
<li>执行“数据”-&gt;“自文本”</li>
</ul>
<ul>
<li>选择 CSV 文件，出现文本导入向导</li>
<li>选择“分隔符号”，下一步</li>
<li>勾选“逗号”，去掉“ Tab 键”，下一步，完成</li>
<li>在“导入数据”对话框里，直接点确定</li>
</ul>
<h4 id="2-转存为ANSI格式"><a href="#2-转存为ANSI格式" class="headerlink" title="2. 转存为ANSI格式"></a>2. 转存为ANSI格式</h4><p>用文本编辑器打开CSV文件，另存为ANSI格式，再用Excel打开。</p>
<h2 id="3-python自带模块csv"><a href="#3-python自带模块csv" class="headerlink" title="3. python自带模块csv"></a>3. python自带模块csv</h2><p><a href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv" target="_blank" rel="noopener"><code>csv</code></a> 模块实现了 CSV 格式表单数据的读写。其提供了诸如“以兼容 Excel 的方式输出数据文件”或“读取 Excel 程序输出的数据文件”的功能，</p>
<p><code>csv</code>定义了以下函数：</p>
<blockquote>
<p><code>csv.reader</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, **fmtparams)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamreader = csv.reader(csvfile, delimiter=<span class="string">' '</span>, quotechar=<span class="string">'|'</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line">        print(<span class="string">', '</span>.join(row))</span><br></pre></td></tr></table></figure>
<p><code>csv.writer</code>(<em>csvfile</em>, <em>dialect=’excel’</em>, **fmtparams)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'eggs.csv'</span>, <span class="string">'w'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamwriter = csv.writer(csvfile, delimiter=<span class="string">' '</span>,</span><br><span class="line">                            quotechar=<span class="string">'|'</span>, quoting=csv.QUOTE_MINIMAL)</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>] * <span class="number">5</span> + [<span class="string">'Baked Beans'</span>])</span><br><span class="line">    spamwriter.writerow([<span class="string">'Spam'</span>, <span class="string">'Lovely Spam'</span>, <span class="string">'Wonderful Spam'</span>])</span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>csv</code>定义了以下类：</p>
<blockquote>
<p>class csv.DictReader(<em>f</em>, <em>fieldnames=None</em>, <em>restkey=None</em>, <em>restval=None</em>, <em>dialect=’excel’</em>, <em>args, *</em>kwds) </p>
<p>将csv数据读取为字典</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Name</th>
<th style="text-align:right">Age</th>
<th style="text-align:center">Class</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">A</td>
<td style="text-align:right">20</td>
<td style="text-align:center">two</td>
</tr>
<tr>
<td style="text-align:left">B</td>
<td style="text-align:right">21</td>
<td style="text-align:center">one</td>
</tr>
<tr>
<td style="text-align:left">C</td>
<td style="text-align:right">22</td>
<td style="text-align:center">one</td>
</tr>
<tr>
<td style="text-align:left">D</td>
<td style="text-align:right">23</td>
<td style="text-align:center">three</td>
</tr>
<tr>
<td style="text-align:left">E</td>
<td style="text-align:right">24</td>
<td style="text-align:center">one</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">"csv.csv"</span>,<span class="string">'r'</span>,encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line"> reader = csv.reader(f)</span><br><span class="line"> fieldnames = next(reader)<span class="comment">#获取数据的第一列，作为后续要转为字典的键名 生成器，next方法获取</span></span><br><span class="line"> <span class="comment"># print(fieldnames)</span></span><br><span class="line"> csv_reader = csv.DictReader(f,fieldnames=fieldnames) <span class="comment">#self._fieldnames = fieldnames # list of keys for the dict 以list的形式存放键名</span></span><br><span class="line"> <span class="keyword">for</span> row <span class="keyword">in</span> csv_reader:</span><br><span class="line">  d=&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> k,v <span class="keyword">in</span> row.items():</span><br><span class="line">   d[k]=v</span><br><span class="line">  print(d)</span><br></pre></td></tr></table></figure>
<p>class csv.DictWriter(<em>f</em>, <em>fieldnames=None</em>, <em>extrasaction=’raise’</em>, <em>dialect=’excel’</em>, <em>args, *</em>kwds)</p>
<p>将字典写入csv文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">file_path = <span class="string">r"E:\new.csv"</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">"w"</span>, newline=<span class="string">""</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    fieldnames = [<span class="string">"书名"</span>, <span class="string">"作者"</span>, <span class="string">"出版时间"</span>, <span class="string">"价格"</span>, <span class="string">"评分"</span>, <span class="string">"评价人数"</span>]</span><br><span class="line">    f_csv = csv.DictWriter(f, fieldnames)</span><br><span class="line">    f_csv.writeheader()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(time_list)):</span><br><span class="line">        f_csv.writerow(</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="string">"书名"</span>: book_name_list[i],</span><br><span class="line">                <span class="string">"作者"</span>: author_list[i],</span><br><span class="line">                <span class="string">"出版时间"</span>: time_list[i],</span><br><span class="line">                <span class="string">"价格"</span>: price_list[i],</span><br><span class="line">                <span class="string">"评分"</span>: score_list[i],</span><br><span class="line">                <span class="string">"评价人数"</span>: evaluator_list[i]</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>
</blockquote>
<p>参考资源：</p>
<p><a href="https://docs.python.org/zh-cn/3/library/csv.html#module-csv" target="_blank" rel="noopener">Python中文文档-module csv</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>csv</tag>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown数学符号和公式</title>
    <url>/2020/08/29/Markdown%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7%E5%92%8C%E5%85%AC%E5%BC%8F%20193445/</url>
    <content><![CDATA[<p>Markdown中数学符号和公式的书写规则和<code>latex</code>非常像。</p>
<p>行内公式或数学符号使用<code>$</code>符号包裹Tex命令即可。</p>
<p>单独的公式段落可以用$$$$包裹，或者点击“段落” $\rightarrow$ “公式块”，或者使用快捷键Shift+Ctrl+M</p>
<a id="more"></a>
<p>常用的数学符号：</p>
<h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p><strong>小写</strong> \alpha \beta \chi \delta \epsilon \eta \gamma \kappa \lambda \mu \nu \omega \tau \theta \xi \zeta </p>
<p>$\alpha \beta \chi \delta \epsilon \eta \gamma \kappa \lambda \mu \nu \omega \tau \theta \xi \zeta $</p>
<p><strong>大写</strong> 将第一个字母大写即可： $\Alpha \Beta \Chi \Delta \Epsilon $</p>
<h3 id="操作符-关系符"><a href="#操作符-关系符" class="headerlink" title="操作符 关系符"></a>操作符 关系符</h3><p>常用的有 ：</p>
<p>\cdot  \pm \leq \geq \gg \ll \times \div \oplus \otimes \equiv \approx \because \therefore</p>
<p>$\cdot  \pm \leq \geq \gg \ll \times \div \oplus \otimes \equiv \approx \because \therefore$</p>
<h3 id="数学着重号"><a href="#数学着重号" class="headerlink" title="数学着重号"></a>数学着重号</h3><p>\ddot{a} \bar{a} \dot{a} \hat{a} \vec{a} \check{a}</p>
<p>$\ddot{a} \bar{a} \dot{a} \hat{a} \vec{a} \check{a}$</p>
<h3 id="各式箭头"><a href="#各式箭头" class="headerlink" title="各式箭头"></a>各式箭头</h3><p>\leftarrow \rightarrow \uparrow \downarrow</p>
<p>$\leftarrow \rightarrow \uparrow \downarrow$</p>
<p>\Leftarrow \Rightarrow \Uparrow \Downarrow</p>
<p>$\Leftarrow \Rightarrow \Uparrow \Downarrow$</p>
<p>\longleftarrow \longrightarrow </p>
<p>$\longleftarrow \longrightarrow $</p>
<p>\leftrightarrow  \updownarrow</p>
<p>$\leftrightarrow  \updownarrow$</p>
<h3 id="其他符号"><a href="#其他符号" class="headerlink" title="其他符号"></a>其他符号</h3><p>\infty  \forall \nabla \partial \varnothing \hbar \exists</p>
<p>$\infty  \forall \nabla \partial \varnothing \hbar \exists$</p>
<p>\sum  \int  \prod \oint  \iint</p>
<p>$\sum  \int  \prod \oint  \iint$</p>
<h3 id="数学结构"><a href="#数学结构" class="headerlink" title="数学结构"></a>数学结构</h3><p>\frac{a}{b} $\frac{a}{b}$</p>
<p>\sqrt[n]{a} $\sqrt[n]{a} $</p>
<p>\overline{abc} $\overline{abc}$</p>
<p>\widehat{abc} $\widehat{abc}$</p>
<p>\overrightarrow{abc} $\overrightarrow{abc}$</p>
<p>\left\{ a b c\}\right</p>
<p>a = \left \{ \begin{array}{c} x^2 \\ 2x \\0 \end{array} \right. \} $a = \left \{ \begin{array}{c} x^2 \\ 2x \\0 \end{array} \right.$</p>
<p>\left ( \begin{array}{cc} a &amp; b \\ c &amp; d\end{array} \right) $\left ( \begin{array}{cc} a &amp; b \\ c &amp; d\end{array} \right)$</p>
<hr>
<p>参考：</p>
<p><a href="https://blog.csdn.net/wait_for_eva/article/details/84307306" target="_blank" rel="noopener">typora-数学符号</a> </p>
<p><a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455" target="_blank" rel="noopener">使用Typora添加数学公式</a></p>
<p><a href="https://www.cnblogs.com/waleswood/p/6401232.html" target="_blank" rel="noopener">希腊字母、拉丁字母、Markdown、拼写与读音中英对照表</a></p>
<p><a href="https://blog.csdn.net/katherine_hsr/article/details/79179622" target="_blank" rel="noopener">Markdown数学符号&amp;公式</a></p>
]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>python之字符串和列表之间的转换</title>
    <url>/2020/07/28/python%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8C%E5%88%97%E8%A1%A8%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<h2 id="str-to-list"><a href="#str-to-list" class="headerlink" title="str to list"></a>str to list</h2><a id="more"></a>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">"12345"</span></span><br><span class="line">list1 = list(str1)</span><br><span class="line">print(list1)  <span class="comment"># ['1', '2', '3', '4', '5']</span></span><br><span class="line"></span><br><span class="line">str2 = <span class="string">"123 sjhid dhi"</span></span><br><span class="line">list2 = str2.split() <span class="comment">#or list2 = str2.split(" ")</span></span><br><span class="line">print(list2)   <span class="comment"># ['123', 'sjhid', 'dhi']</span></span><br><span class="line"> </span><br><span class="line">str3 = <span class="string">"www.google.com"</span></span><br><span class="line">list3 = str3.split(<span class="string">"."</span>)</span><br><span class="line">print(list3)   <span class="comment"># ['www', 'google', 'com']</span></span><br></pre></td></tr></table></figure>
<h2 id="list-to-str"><a href="#list-to-str" class="headerlink" title="list to str"></a>list to str</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str4 = <span class="string">""</span>.join(list3)</span><br><span class="line">print(str4)    <span class="comment"># wwwgooglecom</span></span><br><span class="line">str5 = <span class="string">"."</span>.join(list3)  <span class="comment"># www.google.com</span></span><br><span class="line">print(str5)</span><br><span class="line">str6 = <span class="string">" "</span>.join(list3)   <span class="comment"># www google com</span></span><br><span class="line"><span class="keyword">print</span> (str6)</span><br></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/roytao2/article/details/53433373" target="_blank" rel="noopener">https://blog.csdn.net/roytao2/article/details/53433373</a></p>
<p><a href="https://www.jb51.net/article/107092.htm" target="_blank" rel="noopener">https://www.jb51.net/article/107092.htm</a></p>
<div style='display: none'>

尝试爬取博客页面

</div>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>python字符串过滤仅保留数字</title>
    <url>/2020/07/25/python%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%87%E6%BB%A4%E4%BB%85%E4%BF%9D%E7%95%99%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h2 id="1-内置-filter-函数"><a href="#1-内置-filter-函数" class="headerlink" title="1. 内置 filter() 函数"></a>1. 内置 filter() 函数</h2><p><code>filter(function, iterable)</code>函数用于过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表，<font face="黑体" color=green > <strong>注意:</strong> Pyhton2.7 返回列表，Python3.x 返回迭代器对象</font>。</p>
<a id="more"></a>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 过滤出列表中的所有奇数：</span></span><br><span class="line">newlist = filter(is_odd, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>])</span><br><span class="line"><span class="comment"># 过滤出1~100中平方根是整数的数：</span></span><br><span class="line">newlist = filter(is_sqr, range(<span class="number">1</span>, <span class="number">101</span>))</span><br><span class="line"><span class="comment"># 字符串过滤仅保留数字和字母</span></span><br><span class="line">string = <span class="string">'abc5fg67.!aa99'</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isdigit,string))) <span class="comment">#只保留数字</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isalpha,string))) <span class="comment">#只保留字母</span></span><br><span class="line">string_new = <span class="string">''</span>.join(list(filter(str.isalnum,string))) <span class="comment">#保留数字和字母</span></span><br><span class="line"><span class="comment"># 如果想保留数字0-9和小数点’.’ 则需要自定义函数</span></span><br><span class="line"><span class="string">''</span>.join(list(filter(<span class="keyword">lambda</span> ch: ch <span class="keyword">in</span> <span class="string">'1234567890.'</span>, string)))</span><br></pre></td></tr></table></figure>
<h2 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h2><p>python自带<code>re</code> 模块，使 Python 语言拥有全部的正则表达式功能。</p>
<p>从字符串中提取数字，一般形式如：—-.—，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">string=<span class="string">"A1.45，b5，6.45，8.82"</span></span><br><span class="line"><span class="keyword">print</span> re.findall(<span class="string">r"\d+.?\d*"</span>,string)</span><br><span class="line"><span class="comment"># \d+匹配1次或者多次数字</span></span><br><span class="line"><span class="comment"># \.?匹配小数点，可能有或者没有</span></span><br><span class="line"><span class="comment"># \d* 匹配小数点之后的数字，零到任意。</span></span><br></pre></td></tr></table></figure>
<hr>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><ol>
<li><p><a href="https://blog.csdn.net/huoyuanshen/article/details/83106608" target="_blank" rel="noopener">https://blog.csdn.net/huoyuanshen/article/details/83106608</a></p>
</li>
<li><p><a href="https://www.runoob.com/python/python-func-filter.html" target="_blank" rel="noopener">https://www.runoob.com/python/python-func-filter.html</a></p>
<p>​</p>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>内置函数</tag>
        <tag>正则表达式</tag>
        <tag>re</tag>
        <tag>filter()</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫之实战问题</title>
    <url>/2020/08/03/python%E7%88%AC%E8%99%AB%E4%B9%8B%E5%AE%9E%E6%88%98%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-selenium调用Chrome打开淘宝时需要登录"><a href="#1-selenium调用Chrome打开淘宝时需要登录" class="headerlink" title="1. selenium调用Chrome打开淘宝时需要登录"></a>1. selenium调用Chrome打开淘宝时需要登录</h2><a id="more"></a>
<p>由于需要登录用户信息，导致爬虫程序被打断，可以再使用selenium去模拟人的登录，输入账号和密码以及滑动，但是觉得很麻烦还会有各种各样的bug，所以决定用类似于cookie的方法即利用保存在电脑上的chrome用户信息来登录淘宝。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()        <span class="comment">#初始化</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)         <span class="comment">#设置浏览器无头模式</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--disable-gpu'</span>)      <span class="comment">#避免一些报错</span></span><br><span class="line">chrome_options.add_argument(<span class="string">'--no-sandbox'</span>)       <span class="comment">#避免出错</span></span><br><span class="line">chrome_options.add_argument(<span class="string">r'user-data-dir=C:\Users\username\AppData\Local\Google\Chrome\User Data'</span>)</span><br><span class="line">browser = webdriver.Chrome(options=chrome_options)</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong> 为chrome浏览器设置参数,如果使用用户信息，不会调起新的chrome，所以需要将Chrome所有窗口关闭，否则因为占用会出错。</li>
</ul>
<p>另外还可以直接传入cookies。或者，或者使用requests.post() 传入账号，密码。</p>
<h2 id="2-淘宝搜索button，使用click点击无反应"><a href="#2-淘宝搜索button，使用click点击无反应" class="headerlink" title="2. 淘宝搜索button，使用click点击无反应"></a>2. 淘宝搜索button，使用click点击无反应</h2><p>有些需要enter</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">driver.get(url)</span><br><span class="line">input = driver.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">input.clear()  <span class="comment"># 清空搜索框数据</span></span><br><span class="line">input.send_keys(<span class="string">'ipad'</span>)  <span class="comment"># 输入检索词</span></span><br><span class="line">input.send_keys(Keys.ENTER)</span><br></pre></td></tr></table></figure>
<h2 id="3-淘宝搜索结果的下一页点击失败"><a href="#3-淘宝搜索结果的下一页点击失败" class="headerlink" title="3.淘宝搜索结果的下一页点击失败"></a>3.淘宝搜索结果的下一页点击失败</h2><p>解决方法：在页码框输入页码，然后点击确定</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">input = wait.until(EC.presence_of_element_located((By.XPATH, <span class="string">'//*[@id="mainsrp-pager"]/div/div/div/div[2]/input'</span>))) <span class="comment"># 输入框</span></span><br><span class="line">submit = wait.until(EC.element_to_be_clickable((By.XPATH, <span class="string">'//*[@id="mainsrp-pager"]/div/div/div/div[2]/span[3]'</span>))) <span class="comment"># 确定按钮</span></span><br><span class="line">input.clear()</span><br><span class="line">input.send_keys(str(page))</span><br><span class="line">submit.click()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>实战</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习</title>
    <url>/2020/07/24/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%9F%BA%E6%9C%AC%E5%BA%93%E5%92%8C%E8%A7%A3%E6%9E%90%E5%BA%93/</url>
    <content><![CDATA[<h2 id="1-前期准备"><a href="#1-前期准备" class="headerlink" title="1.前期准备"></a>1.前期准备</h2><h3 id="1-anaconda安装"><a href="#1-anaconda安装" class="headerlink" title="1. anaconda安装"></a>1. anaconda安装</h3><ol>
<li><p>配置环境，将python写入环境变量。</p>
<a id="more"></a>
</li>
</ol>
<h3 id="2-IDE：-pycharm安装"><a href="#2-IDE：-pycharm安装" class="headerlink" title="2. IDE： pycharm安装"></a>2. IDE： pycharm安装</h3><ol>
<li>使用虚拟环境（virtual environment）</li>
<li>settings 安装python包，可以直接从anaconda中把安装包直接拷到Lib-site_package下，如果网速限制，可以替换镜像源。</li>
</ol>
<h2 id="2-urllib"><a href="#2-urllib" class="headerlink" title="2. urllib"></a>2. urllib</h2><p><code>urllib</code> 是Python 内置的 HTTP 请求库，包含如4 个模块：<code>request</code>, <code>error</code>, <code>parse</code>, <code>robotparser</code></p>
<h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><p>该模块可以发送请求并得到响应。</p>
<ol>
<li><p><code>urlopen</code></p>
<p>其结果返回一个 HTTPResposne 类型的对象，主要包含 <code>read、getheader、getheaders</code>等方法，以及 <code>msg、version、status、reason</code>等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">data = response.read().decode()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p><code>response.status</code> 1**：信息状态，2**：成功状态，请求成功为200 ，3**：重定向，4**：客户端错误，400代表解析失败，404 代表网页未找到。</p>
<p><code>response.getheaders()</code> 得到headers</p>
</blockquote>
<ol>
<li><p><code>Request</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">req = request.Request(url=url, data=data, headers=headers, method=<span class="string">'POST'</span>)  </span><br><span class="line">response = request.urlopen(req)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>build_opener</code> 和 <code>Handler</code> 可以实现代理，密码登录等复杂请求，例子可<a href="https://python3webspider.cuiqingcai.com/3.1-shi-yong-urllib#2-request" target="_blank" rel="noopener">参考</a></p>
</li>
</ol>
<h3 id="error"><a href="#error" class="headerlink" title="error"></a>error</h3><p>该模块定义了由 request 模块产生的异常。</p>
<ol>
<li><p><code>URLError</code> 有一个属性<code>reason</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:  </span><br><span class="line">    response = request.urlopen(<span class="number">404</span>_url)  </span><br><span class="line"><span class="keyword">except</span> error.URLError <span class="keyword">as</span> e:  </span><br><span class="line">    print(e.reason)  <span class="comment">#  Not Found （对应403）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>HTTPError</code> 专门处理HTTP请求的错误，具有<code>code</code>, <code>reason</code>, <code>headers</code> 三个属性</p>
</li>
</ol>
<h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>该模块定义了处理 URL 的标准接口，例如实现 URL 各部分的抽取、合并以及链接转换。</p>
<ol>
<li><p><code>quote</code> 将内容转化为 URL 编码的格式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">"小说"</span></span><br><span class="line">key_ASCII = quote(key)</span><br><span class="line">print(key_ASCII)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>unquote</code> 将 URL 格式内容解码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">key = <span class="string">"%E5%B0%8F%E8%AF%B4"</span></span><br><span class="line">print(unqoute(key))</span><br></pre></td></tr></table></figure>
<p><strong><code>request</code> 中也有qoute</strong></p>
</li>
</ol>
<h3 id="robotparser"><a href="#robotparser" class="headerlink" title="robotparser"></a>robotparser</h3><p>该模块可以实现网站 Robots 协议的分析。</p>
<p>requests是用于爬取网页源码的一个库。</p>
<h2 id="3-requests"><a href="#3-requests" class="headerlink" title="3. requests"></a>3. requests</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><p><code>get</code> 方法以 GET 方式请求网页，返回得到一个 Response 对象，有<code>status_code，text，cookies</code> 等属性。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response=requests.get(url) </span><br><span class="line">data=response.text</span><br><span class="line">file_path = <span class="string">r"E:\pycharm\test.html"</span>  <span class="comment"># 'r'是防止字符转义,否则\需要变成/</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f: </span><br><span class="line">    f.write(data)</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>因为Windows操作系统默认字符编码为GBK，而Python默认Unicode.utf-8，如果不写“encoding=‘utf-8’ ”就会报错。</p>
<p>对于二进制数据，可以使用<code>content</code> 属性，可以直接写入文件，直接获得图片，音频，视屏。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">r = requests.get(<span class="string">"https://github.com/favicon.ico"</span>)</span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'favicon.ico'</span>, <span class="string">'wb'</span>) <span class="keyword">as</span> f: <span class="comment"># wb 以二进制方式写入</span></span><br><span class="line">    f.write(r.content)</span><br></pre></td></tr></table></figure>
<p>有些网站禁止抓取，如B站，可以使用headers包含 User-Agent 字段信息，也就是浏览器标识信息。<a href="https://www.jianshu.com/p/da6a44d0791e" target="_blank" rel="noopener" title="User-agent大全">User-agent大全</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># urllib.error.HTTPError: HTTP Error 403: Forbidden</span></span><br><span class="line">response = urllib.request.urlopen(url)</span><br><span class="line">data = response.read().decode() </span><br><span class="line"><span class="comment"># 没有问题</span></span><br><span class="line">response=requests.get(url) </span><br><span class="line">data=response.text</span><br></pre></td></tr></table></figure>
<p>在设置 Headers 使用Cookie来维持登录状态：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">headers = &#123;</span><br><span class="line">    <span class="string">'Cookie'</span>: <span class="string">'cookie_content'</span>,</span><br><span class="line">    <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.116 Safari/537.36'</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，<code>request</code>还有<code>put, post, delete, options</code> 等方法实现 POST、PUT、DELETE、OPTIONS 等请求。</p>
<h3 id="session会话维持"><a href="#session会话维持" class="headerlink" title="session会话维持"></a>session会话维持</h3><p>通过用 get 方法登录某个网站，用 get 方法第二次去请求个人信息页面，并不能成功。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">requests.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = requests.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text) <span class="comment"># cookies 是空字典</span></span><br></pre></td></tr></table></figure>
<p>如何设置一次cookies，维持对话，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s = requests.Session()</span><br><span class="line">s.get(<span class="string">'http://httpbin.org/cookies/set/number/123456789'</span>)</span><br><span class="line">r = s.get(<span class="string">'http://httpbin.org/cookies'</span>)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<h2 id="4-使用Selenium调用浏览器"><a href="#4-使用Selenium调用浏览器" class="headerlink" title="4. 使用Selenium调用浏览器"></a>4. 使用Selenium调用浏览器</h2><p><a href="[http://www.selenium.org.cn/](http://www.selenium.org.cn/">Selenium</a>)是web自动化测试工具集，包括IDE、Grid、RC（selenium 1.0）、WebDriver（selenium 2.0）等。</p>
<p> <a href="[https://blog.csdn.net/huilan_same/article/details/52615123](https://blog.csdn.net/huilan_same/article/details/52615123">selenium自动化资源整理</a>)</p>
<h3 id="1-调用Chrome浏览器"><a href="#1-调用Chrome浏览器" class="headerlink" title="1. 调用Chrome浏览器"></a>1. 调用Chrome浏览器</h3><ol>
<li><p>查看本地Chrome版本</p>
</li>
<li><p>下载<a href="http://npm.taobao.org/mirrors/chromedriver" target="_blank" rel="noopener">Chromedriver</a></p>
</li>
<li><p>将chromedriver.exe放到python path下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium.webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line"></span><br><span class="line">driver = selenium.webdriver.Chrome()</span><br><span class="line">driver.get(url)</span><br><span class="line">data = driver.page_source</span><br><span class="line"></span><br><span class="line">file_path = <span class="string">r"E:\pycharm-爬虫\bilibili\首页_selenium.html"</span></span><br><span class="line"><span class="keyword">with</span> open(file_path, <span class="string">'w'</span>, encoding=<span class="string">"utf-8"</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(data)</span><br><span class="line"></span><br><span class="line">driver.close()</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-调用FireFox浏览器"><a href="#2-调用FireFox浏览器" class="headerlink" title="2. 调用FireFox浏览器"></a>2. 调用FireFox浏览器</h3><ol>
<li>下载<a href="https://github.com/mozilla/geckodriver/releases" target="_blank" rel="noopener">geckodriver</a>，并将其放入PATH中。</li>
<li>driver = selenium.webdriver.Firefox()</li>
</ol>
<h2 id="5-bs4-BeautifulSoup解析HTML"><a href="#5-bs4-BeautifulSoup解析HTML" class="headerlink" title="5. bs4.BeautifulSoup解析HTML"></a>5. bs4.BeautifulSoup解析HTML</h2><p>bs4即<a href="http://www.crummy.com/software/BeautifulSoup/" target="_blank" rel="noopener">BeautifulSoup4</a> ，是一个可以从HTML或XML文件中提取数据的Python库。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line">data = <span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span></span><br><span class="line">soup = BeautifulSoup(data, <span class="string">"html.parser"</span>) <span class="comment"># data为html格式的数据</span></span><br></pre></td></tr></table></figure>
<p>Beautiful Soup将复杂HTML文档转换成一个复杂的树形结构,每个节点都是Python对象,所有对象可以归纳为4种: <code>Tag</code>, <code>NavigableString</code> , <code>BeautifulSoup</code> , <code>Comment</code> 。</p>
<h3 id="Tag"><a href="#Tag" class="headerlink" title="Tag"></a>Tag</h3><p><code>tag</code> 的属性有<code>name</code> 和 <code>attributes</code>，方法<code>get()</code> , 如果不确定某个属性是否存在时,用 <code>tag.get(&#39;attr&#39;)</code> 方法去获取它,跟获取Python字典的key一样&gt;</p>
<p>一个<code>tag</code> 可能有很多属性，属性的操作与<strong>字典</strong>相同，可以被添加，删除或修改。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tag = soup.b <span class="comment"># tag b</span></span><br><span class="line">tag.name  <span class="comment"># 'b'</span></span><br><span class="line">tag.name = <span class="string">"blockquote"</span> <span class="comment"># tag &lt;blockquote class="boldest"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">tag[<span class="string">'class'</span>] <span class="comment"># boldest</span></span><br><span class="line">tag.attrs <span class="comment"># &#123;'class': 'boldest'&#125;</span></span><br><span class="line">tag[<span class="string">'class'</span>] = <span class="string">'verybold'</span> <span class="comment"># 修改 &lt;blockquote class="verybold" &gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line">tag[<span class="string">'id'</span>] = <span class="number">1</span>   <span class="comment"># 添加 &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'class'</span>] <span class="comment"># &lt;blockquote id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></span><br><span class="line"><span class="keyword">del</span> tag[<span class="string">'id'</span>]    <span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>HTML5</code> 中定义了一系列可以包含多个值的属性，<code>class</code> (一个tag可以有多个CSS的class). <code>rel</code>  <code>rev</code> ， <code>accept-charset</code> ， <code>headers</code> ， <code>accesskey</code> 等。</p>
<p>多值属性的返回值为list， 非多值属性的返回值为字符串：</p>
<p><strong>注意：XML格式的tag不包含多值属性。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多值属性class</span></span><br><span class="line">css_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">css_soup.p[<span class="string">'class'</span>]</span><br><span class="line"><span class="comment"># ["body", "strikeout"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 非多值属性id</span></span><br><span class="line">id_soup = BeautifulSoup(<span class="string">'&lt;p id="my id"&gt;&lt;/p&gt;'</span>)</span><br><span class="line">id_soup.p[<span class="string">'id'</span>]</span><br><span class="line"><span class="comment"># 'my id'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多值属性修改时</span></span><br><span class="line">rel_soup = BeautifulSoup(<span class="string">'&lt;p&gt;Back to the &lt;a rel="index"&gt;homepage&lt;/a&gt;&lt;/p&gt;'</span>)</span><br><span class="line">rel_soup.a[<span class="string">'rel'</span>] = [<span class="string">'index'</span>, <span class="string">'contents'</span>]</span><br><span class="line">print(rel_soup.p)</span><br><span class="line"><span class="comment"># &lt;p&gt;Back to the &lt;a rel="index contents"&gt;homepage&lt;/a&gt;&lt;/p&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="NavigableString"><a href="#NavigableString" class="headerlink" title="NavigableString"></a>NavigableString</h3><p>字符串常被包含在<code>tag</code> 内。Beautiful Soup用<code>NavigableString</code>类来包装tag中的字符串: <code>tag.string</code></p>
<p>tag中包含的字符串不能编辑,但是可以用 <code>replace_with()</code> 方法替换成其它的字符串</p>
<h3 id="BeautifulSoup"><a href="#BeautifulSoup" class="headerlink" title="BeautifulSoup"></a>BeautifulSoup</h3><p><code>BeautifulSoup</code> 对象表示的是一个文档的全部内容.大部分时候,可以把它当作 <code>Tag</code> 对象，它支持 遍历文档树 和 搜索文档树 中描述的大部分的方法。</p>
<h3 id="Comment"><a href="#Comment" class="headerlink" title="Comment"></a>Comment</h3><p>处理HTML和XML中的注释部分，<code>Comment</code> 对象是一个特殊类型的 <code>NavigableString</code> 对象，但是当它出现在HTML文档中时, <code>Comment</code> 对象会使用特殊的格式输出。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">markup = <span class="string">"&lt;b&gt;&lt;!--Hey, buddy. Want to buy a used parser?--&gt;&lt;/b&gt;"</span></span><br><span class="line">soup = BeautifulSoup(markup)</span><br><span class="line">comment = soup.b.string</span><br><span class="line">type(comment)</span><br><span class="line"><span class="comment"># &lt;class 'bs4.element.Comment'&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="遍历文档树"><a href="#遍历文档树" class="headerlink" title="遍历文档树"></a>遍历文档树</h3><p>一个<code>tag</code> 可能包含多个字符串或其他<code>tag</code> ，这些都是该<code>tag</code> 的子节点。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 点取属性的方式只能获得当前名字的第一个tag</span></span><br><span class="line">soup.head</span><br><span class="line">soup.body.b</span><br><span class="line"><span class="comment"># 想要得到所有的&lt;a&gt;标签</span></span><br><span class="line">soup.find_all(<span class="string">'a'</span>) <span class="comment"># 返回list</span></span><br></pre></td></tr></table></figure>
<h4 id="子节点"><a href="#子节点" class="headerlink" title="子节点"></a>子节点</h4><h5 id="contents-和-children"><a href="#contents-和-children" class="headerlink" title=".contents 和 .children"></a>.contents 和 .children</h5><p><code>tag</code> 的 <code>.contents</code> 属性可以将<code>tag</code> 的子节点以列表的方式输出:</p>
<p>通过<code>tag</code> 的 <code>.children</code> 生成器,可以对<code>tag</code> 的子节点进行循环:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">head_tag = soup.head  <span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></span><br><span class="line">title_tag = head_tag.contents[<span class="number">0</span>]  <span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">title_tag.contents    <span class="comment"># [u'The Dormouse's story']</span></span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> title_tag.children:</span><br><span class="line">    print(child)      <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure>
<h5 id="descendants"><a href="#descendants" class="headerlink" title=".descendants"></a>.descendants</h5><p><code>.contents</code> 和 <code>.children</code> 属性仅包含tag的直接子节点.例如,<head>标签只有一个直接子节点<code>&lt;title&gt;</code> 但<code>&lt;title&gt;</code> 标签也包含一个子节点:字符串 “The Dormouse’s story”，这种情况下字符串 “The Dormouse’s story”也属于<code>&lt;head&gt;</code> 标签的子孙节点. <code>.descendants</code> 属性可以对所有tag的子孙节点进行递归循环。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> head_tag.descendants:</span><br><span class="line">    print(child)</span><br><span class="line">    <span class="comment"># &lt;title&gt;The Dormouse's story&lt;/title&gt;</span></span><br><span class="line">    <span class="comment"># The Dormouse's story</span></span><br></pre></td></tr></table></figure>
<h5 id="string"><a href="#string" class="headerlink" title=".string"></a>.string</h5><p>如果<code>tag</code> 只有一个 <code>NavigableString</code> 类型子节点,那么这个<code>tag</code> 可以使用 <code>.string</code> 得到子节点</p>
<p>否则，<code>.string</code> 的输出结果是 <code>None</code></p>
<p>输出的字符串中可能包含了很多空格或空行,使用 <code>.stripped_strings</code> 可以去除多余空白内容</p>
<h6 id="bs4-element-get-text"><a href="#bs4-element-get-text" class="headerlink" title="bs4.element.get_text()"></a>bs4.element.get_text()</h6><p> Get all child strings, concatenated using the given separator (默认是空格)</p>
<h4 id="父节点"><a href="#父节点" class="headerlink" title="父节点"></a>父节点</h4><h5 id="parent"><a href="#parent" class="headerlink" title=".parent"></a>.parent</h5><h5 id="parents"><a href="#parents" class="headerlink" title=".parents"></a>.parents</h5><p>通过元素的 <code>.parents</code> 属性可以递归得到元素的所有父辈节点</p>
<h5 id="兄弟节点"><a href="#兄弟节点" class="headerlink" title="兄弟节点"></a>兄弟节点</h5><p>同一个元素的子节点</p>
<h5 id="next-sibling-和-previous-sibling"><a href="#next-sibling-和-previous-sibling" class="headerlink" title=".next_sibling 和 .previous_sibling"></a>.next_sibling 和 .previous_sibling</h5><p>在文档树中,使用 <code>.next_sibling</code> 和 <code>.previous_sibling</code> 属性来查询兄弟节点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sibling_soup = BeautifulSoup(<span class="string">"&lt;a&gt;&lt;b&gt;text1&lt;/b&gt;&lt;c&gt;text2&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;"</span>)</span><br><span class="line">sibling_soup.b.next_sibling  <span class="comment"># &lt;c&gt;text2&lt;/c&gt;</span></span><br><span class="line">sibling_soup.c.previous_sibling <span class="comment"># &lt;b&gt;text1&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="next-siblings-和-previous-siblings"><a href="#next-siblings-和-previous-siblings" class="headerlink" title=".next_siblings 和 .previous_siblings"></a>.next_siblings 和 .previous_siblings</h5><p>对当前节点的兄弟节点迭代输出</p>
<h3 id="搜索文档树"><a href="#搜索文档树" class="headerlink" title="搜索文档树"></a>搜索文档树</h3><p><code>Beautiful Soup</code> 中定义的搜索方法，比如 <code>find()</code> 和 <code>find_all()</code></p>
<h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>find_all()</p>
<p>可以是字符串，正则表达式，列表，True，方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">soup.find_all(<span class="string">'b'</span>) <span class="comment"># b 标签</span></span><br><span class="line">soup.find_all(re.compile(<span class="string">"^b"</span>)) <span class="comment"># 以b开头的标签</span></span><br><span class="line">soup.find_all([<span class="string">"a"</span>, <span class="string">"b"</span>]) <span class="comment"># 含有a或b的标签</span></span><br><span class="line">soup.find_all(<span class="literal">True</span>) <span class="comment"># True 可以匹配任何值,找到所有的tag,但是不会返回字符串节点</span></span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">has_class_but_no_id</span><span class="params">(tag)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> tag.has_attr(<span class="string">'class'</span>) <span class="keyword">and</span> <span class="keyword">not</span> tag.has_attr(<span class="string">'id'</span>) <span class="comment"># 有class，无id</span></span><br><span class="line">soup.find_all(has_class_but_no_id)</span><br></pre></td></tr></table></figure>
<h4 id="find-all"><a href="#find-all" class="headerlink" title="find_all())"></a>find_all())</h4><p><code>find_all(name, attrs, recursive , text , **kwargs)</code></p>
<ol>
<li><p>如果一个指定名字的参数不是搜索内置的参数名,搜索时会把该参数当作指定名字<code>tag</code> 的属性来搜索<code>soup.find_all(id=&#39;link2&#39;)</code> </p>
</li>
<li><p>有些tag属性在搜索不能使用,比如HTML5中的 data-* 属性,但是可以通过 <code>find_all()</code> 方法的 <code>attrs</code> 参数定义一个字典参数来搜索包含特殊属性的tag: <code>data_soup.find_all(attrs={&quot;data-foo&quot;: &quot;value&quot;})</code></p>
</li>
<li><p>按照CSS类名搜索<code>tag</code> , 但标识CSS类名的关键字 <code>class</code> 在Python中是保留字,使用 <code>class</code> 做参数会导致语法错误.从<code>Beautiful Soup</code> 的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的<code>tag</code> : <code>soup.find_all(&quot;a&quot;, class_=&quot;sister&quot;)</code></p>
</li>
<li><p>通过 <code>text</code> 参数可以搜搜文档中的字符串内容</p>
</li>
<li><p><code>find_all()</code> 方法返回全部的搜索结构,如果文档树很大那么搜索会很慢.如果不需要全部结果,可以使用 <code>limit</code> 参数限制返回结果的数量.效果与SQL中的limit关键字类似,当搜索到的结果数量达到 <code>limit</code> 的限制时,就停止搜索返回结果.  <code>soup.find_all(&quot;a&quot;, limit=2)</code></p>
</li>
<li><p>recursive 默认为True，检索当前tag的所有子孙节点，<code>soup.html.find_all(&quot;title&quot;, recursive=False)</code> 搜索<code>tag</code> 的直接子节点</p>
</li>
<li><p>```python</p>
<h1 id="这两行代码等价"><a href="#这两行代码等价" class="headerlink" title="这两行代码等价"></a>这两行代码等价</h1><p>soup.find_all(“a”)<br>soup(“a”)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### find()</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line"># 这两行代码几乎等价</span><br><span class="line">soup.find_all(&#39;title&#39;, limit&#x3D;1) # 返回列表</span><br><span class="line">soup.find(&#39;title&#39;) # 返回结果 等价于 soup.title</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="selector-CSS选择器-的用法"><a href="#selector-CSS选择器-的用法" class="headerlink" title="selector (CSS选择器) 的用法"></a>selector (CSS选择器) 的用法</h4><p>Beautiful Soup支持大部分的CSS（CSS，全称叫作 Cascading Style Sheets，即层叠样式表）选择器， 在 Tag 或 BeautifulSoup 对象的 .select() 方法中传入字符串参数, 即可使用CSS选择器的语法找到tag。</p>
<h5 id="CSS样式"><a href="#CSS样式" class="headerlink" title="CSS样式"></a>CSS样式</h5><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#head_wrapper</span><span class="selector-class">.s-ps-islite</span> <span class="selector-class">.s-p-top</span> &#123;   </span><br><span class="line">    <span class="attribute">position</span>: absolute;  </span><br><span class="line">    <span class="attribute">bottom</span>: <span class="number">40px</span>;  </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;  </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">181px</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>表示 id =head_wrapper 且（没有空格表是&amp;）class 为 s-ps-islite的节点，然后再选中其内部（有空格表示内部）的 class 为 s-p-top 的节点。字典定义了这个元素的布局方式</p>
<p>谷歌浏览器→右键→检查→鼠标放到网页书名上，在检查窗口右键→copy→copy selector，结果如下(&gt; 找到某个tag标签下的子标签)：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#subject_list</span> &gt; <span class="selector-tag">ul</span> &gt; <span class="selector-tag">li</span><span class="selector-pseudo">:nth-child(1)</span> &gt; <span class="selector-tag">div</span><span class="selector-class">.info</span> &gt; <span class="selector-tag">h2</span> &gt; <span class="selector-tag">a</span></span><br></pre></td></tr></table></figure>
<h5 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h5><ul>
<li>CSS 选择器用来定位节点，根据 <strong>id、class、标签名筛选</strong>是其中最常用的3种表示方式。</li>
<li>CSS 选择器还支持嵌套选择，各个选择器之间<strong>空格分隔</strong>代表<strong>嵌套关系</strong>，如果<strong>不加空格</strong>，代表<strong>并列</strong>关系。</li>
<li><code>ul &gt; li</code>表示选择父节点为 ul 节点的所有 li 节点</li>
<li><code>li:nth-child(n)</code> 表示选择属于其父节点的第n个子节点的所有 li 节点</li>
<li>CSS选择器及其他语法规则参见<a href="https://python3webspider.cuiqingcai.com/2.2web-wang-ye-ji-chu#2-2-4-xuan-ze-qi" target="_blank" rel="noopener">该表格</a></li>
</ul>
<h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>通过get_text()可以通过下面代码得到每一页面的书名：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">book_name_list = []</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">21</span>): <span class="comment"># 每页20本书</span></span><br><span class="line">        book_name = soup.select(<span class="string">"#subject_list &gt; ul &gt; li:nth-child("</span> + str(j) + <span class="string">") &gt; div.info &gt; h2 &gt; a"</span>)  </span><br><span class="line">        <span class="comment"># 第29页只有19本书</span></span><br><span class="line">        <span class="keyword">for</span> book_name <span class="keyword">in</span> book_name:</span><br><span class="line">            book_name_list.append(book_name.get_text().replace(<span class="string">" "</span>,<span class="string">""</span>).replace(<span class="string">"\r"</span>, <span class="string">""</span>).replace(<span class="string">"\n"</span>, <span class="string">""</span>))</span><br></pre></td></tr></table></figure>
<h3 id="修改文档树"><a href="#修改文档树" class="headerlink" title="修改文档树"></a>修改文档树</h3><h3 id="解析部分文档"><a href="#解析部分文档" class="headerlink" title="解析部分文档"></a>解析部分文档</h3><p>如果仅仅因为想要查找文档中的<a>标签而将整片文档进行解析,实在是浪费内存和时间.最快的方法是从一开始就把<a>标签以外的东西都忽略掉. <code>SoupStrainer</code> 类可以定义文档的某段内容,这样搜索文档时就不必先解析整篇文档,只会解析在 <code>SoupStrainer</code> 中定义过的文档. 创建一个 <code>SoupStrainer</code> 对象并作为 <code>parse_only</code> 参数给 <code>BeautifulSoup</code> 的构造方法即可.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> SoupStrainer</span><br><span class="line">only_a_tags = SoupStrainer(<span class="string">"a"</span>)</span><br></pre></td></tr></table></figure>
<h2 id="6-解析库pyquery"><a href="#6-解析库pyquery" class="headerlink" title="6. 解析库pyquery"></a>6. 解析库pyquery</h2><p>用法和JQuery类似</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="字符串初始化"><a href="#字符串初始化" class="headerlink" title="字符串初始化"></a>字符串初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">html = <span class="string">" &lt;html blabla"</span></span><br><span class="line">pq(html)</span><br></pre></td></tr></table></figure>
<h4 id="URL初始化"><a href="#URL初始化" class="headerlink" title="URL初始化"></a>URL初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pyquery <span class="keyword">import</span> PyQuery <span class="keyword">as</span> pq</span><br><span class="line">doc = pq(url=<span class="string">'http://cuiqingcai.com'</span>)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure>
<p>PyQuery 对象会首先请求这个 URL，然后用得到的 HTML 内容完成初始化，这其实就相当于用网页的源代码以字符串的形式传递给 PyQuery 类来初始化。</p>
<p>相当于：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">doc = pq(requests.get(<span class="string">'http://cuiqingcai.com'</span>).text)</span><br><span class="line">print(doc(<span class="string">'title'</span>))</span><br></pre></td></tr></table></figure>
<h4 id="文件初始化"><a href="#文件初始化" class="headerlink" title="文件初始化"></a>文件初始化</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pq(filename=<span class="string">'dem.html'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="CSS选择器-1"><a href="#CSS选择器-1" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc=pq(html)</span><br><span class="line">print(doc(<span class="string">"#content .info name"</span>))</span><br></pre></td></tr></table></figure>
<h3 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h3><h4 id="子节点-1"><a href="#子节点-1" class="headerlink" title="子节点"></a>子节点</h4><h5 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h5><p>查找所有子孙节点</p>
<p>会找到所有符合条件的节点，和BeautifulSoup中的find()不同，类似于BS中的find_all()</p>
<h5 id="children"><a href="#children" class="headerlink" title="children()"></a>children()</h5><p>只查找子节点 ， 支持CSS选择器</p>
<h4 id="父节点-1"><a href="#父节点-1" class="headerlink" title="父节点"></a>父节点</h4><h5 id="parent-1"><a href="#parent-1" class="headerlink" title="parent()"></a>parent()</h5><p>直接父节点</p>
<h5 id="parents-1"><a href="#parents-1" class="headerlink" title="parents()"></a>parents()</h5><p>祖贤父节点</p>
<h4 id="兄弟节点-1"><a href="#兄弟节点-1" class="headerlink" title="兄弟节点"></a>兄弟节点</h4><h5 id="sublings"><a href="#sublings" class="headerlink" title="sublings()"></a>sublings()</h5><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>PyQuery的选择结果不会像BeautifulSoup一样返回list，而是直接返回多个或单个节点</p>
<p>返回单个节点可以直接用str()u转化为字符串，</p>
<p>返回多个节点需要遍历，斯奥用items()方法，返回生成器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = doc(<span class="string">'li'</span>).items()</span><br><span class="line">print(type(lis)) <span class="comment"># class 'generator'</span></span><br><span class="line"><span class="keyword">for</span> li <span class="keyword">in</span> lis:</span><br><span class="line">    print(li, type(li))</span><br></pre></td></tr></table></figure>
<h3 id="获取信息"><a href="#获取信息" class="headerlink" title="获取信息"></a>获取信息</h3><h4 id="获取属性attr"><a href="#获取属性attr" class="headerlink" title="获取属性attr()"></a>获取属性attr()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = doc(<span class="string">'a'</span>)</span><br><span class="line">a.attr(<span class="string">'href'</span>)  <span class="comment"># 只会返回第一个满足条件的标签（节点）的href属性</span></span><br></pre></td></tr></table></figure>
<p>如果获取所有节点的属性，需要调用items()遍历。</p>
<h4 id="获取文本"><a href="#获取文本" class="headerlink" title="获取文本"></a>获取文本</h4><p>text()方法返回<strong>所有</strong>节点下纯文字内容，即不需要遍历。</p>
<p>html()方法返回HTML文本，多个节点时，需要<strong>遍历</strong>。</p>
<h3 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h3><h4 id="addClass-和-removeClass"><a href="#addClass-和-removeClass" class="headerlink" title="addClass 和 removeClass"></a>addClass 和 removeClass</h4><p>添加，删除class这个属性</p>
<h4 id="attr、text、html"><a href="#attr、text、html" class="headerlink" title="attr、text、html"></a>attr、text、html</h4><p>attr操作其他属性，<code>li.attr(&#39;name&#39;, &#39;link&#39;)</code> 将name属性的值修改为link，如果不存在，则创建改属性。</p>
<p>如果 attr 方法只传入第一个参数的属性名，则是获取这个属性值；如果传入第二个参数，可以用来修改属性值。text 和 html 方法如果不传参数，则是获取节点内纯文本和 HTML 文本；如果传入参数，则进行赋值。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p><strong>为提取信息带来便利</strong></p>
<h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>CSS选择器支持各种各样的伪类选择器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">doc = pq(html)</span><br><span class="line">li = doc(<span class="string">'li:first-child'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:last-child'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:nth-child(2)'</span>)</span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:gt(2)'</span>) <span class="comment"># 三个以后的li节点</span></span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:nth-child(2n)'</span>) <span class="comment"># 偶数位置的li节点</span></span><br><span class="line">print(li)</span><br><span class="line">li = doc(<span class="string">'li:contains(second)'</span>) <span class="comment">#包含second的li节点</span></span><br><span class="line">print(li)</span><br></pre></td></tr></table></figure>
<h2 id="7-使用代理IP"><a href="#7-使用代理IP" class="headerlink" title="7. 使用代理IP"></a>7. 使用代理IP</h2><p>很多网站对于爬虫做了一定限制，IP容易进小黑屋，所以需要采用代理IP。</p>
<h3 id="代理的种类"><a href="#代理的种类" class="headerlink" title="代理的种类"></a>代理的种类</h3><ul>
<li><p><strong>透明代理 (Transparent Proxy)</strong>: 不但改动了数据包，还会告诉服务器客户端的真实IP，约等于没用。</p>
<ul>
<li>REMOTE_ADDR = Proxy IP</li>
<li>HTTP_VIA = Proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = Your IP</li>
</ul>
</li>
<li><p><strong>普通匿名代理 (Anonymous Proxy)</strong>：会在数据包上做一些改动，服务器上发现这是个代理服务器，但是一般不清楚真实IP地址（有一定几率能追查到）。</p>
<ul>
<li>REMOTE_ADDR = proxy IP</li>
<li>HTTP_VIA = proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = proxy IP</li>
</ul>
</li>
<li><p><strong>混淆代理(Distorting Proxies)</strong>：会在数据包上做一些改动，服务器上发现这是个代理服务器，但会得到一个假的IP地址.</p>
<ul>
<li>REMOTE_ADDR = proxy IP</li>
<li>HTTP_VIA = proxy IP</li>
<li>HTTP_X_FORWARDED_FOR = Random IP address</li>
</ul>
</li>
<li><p><strong>高匿代理(Elite proxy或High Anonymity Proxy)</strong>：会将数据包原封不动的转发，在服务端看来就好像真的是一个普通客户端在访问，而记录的IP则是代理服务器的IP。</p>
<ul>
<li>REMOTE_ADDR = Proxy IP</li>
<li>HTTP_VIA = not determined</li>
<li>HTTP_X_FORWARDED_FOR = not determined</li>
</ul>
<p><strong>参考</strong>：<a href="https://blog.csdn.net/a19860903/article/details/47146715" target="_blank" rel="noopener">https://blog.csdn.net/a19860903/article/details/47146715</a></p>
</li>
</ul>
<h3 id="代理IP网站"><a href="#代理IP网站" class="headerlink" title="代理IP网站"></a>代理IP网站</h3><ol>
<li><a href="https://www.kuaidaili.com/ops/proxylist/1/" target="_blank" rel="noopener">快代理</a></li>
<li><a href="http://www.66ip.cn/index.html" target="_blank" rel="noopener">66代理</a></li>
</ol>
<h3 id="建立代理IP池"><a href="#建立代理IP池" class="headerlink" title="建立代理IP池"></a>建立代理IP池</h3><p>以<a href="https://www.kuaidaili.com/ops/proxylist/1/" target="_blank" rel="noopener">快代理</a>为例：</p>
<details>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_proxy</span><span class="params">(headers)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取代理IP列表</span></span><br><span class="line"><span class="string">    :return: ip_list [&#123;"https": ip&#125;,…]</span></span><br><span class="line"><span class="string">     """</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    ip_list = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">2</span>):</span><br><span class="line">        <span class="comment"># 快代理</span></span><br><span class="line">        base_url = <span class="string">"https://www.kuaidaili.com/ops/proxylist/"</span> + str(i)</span><br><span class="line">        html = requests.get(base_url, headers=headers).text</span><br><span class="line"> </span><br><span class="line">        pattern = <span class="string">'\d+\.\d+\.\d+\.\d+'</span></span><br><span class="line">        re_list = re.findall(pattern, html)</span><br><span class="line">        <span class="keyword">for</span> ip_port <span class="keyword">in</span> re_list:</span><br><span class="line">            ip_list.append(&#123;<span class="string">"https"</span>: ip_port&#125;)</span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br><span class="line"><span class="comment"># 快代理 上有些IP类型仅为http，有些为http，https</span></span><br></pre></td></tr></table></figure>

</details>

<h3 id="测试代理IP"><a href="#测试代理IP" class="headerlink" title="测试代理IP"></a>测试代理IP</h3><p>通过request直接请求一个网址，看是否通过或者看状态码是否为200(<strong><code>request.status_code == 200</code></strong>)</p>
<p><details></p>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_proxy</span><span class="params">(ip_list, headers, test_url)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    测试代理IP</span></span><br><span class="line"><span class="string">    :param ip_list:</span></span><br><span class="line"><span class="string">    :return: ip_list [&#123;"https": ip&#125;,…]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            response = requests.get(test_url, headers=headers, proxies=proxy, timeout=<span class="number">5</span>)  </span><br><span class="line">        <span class="keyword">except</span> requests.exceptions.ConnectTimeout:</span><br><span class="line">            ip_list.pop(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> ip_list</span><br></pre></td></tr></table></figure>
<p><details><br><strong>但是上述代码的问题是设置了代理IP，请求网站通过，也不代表IP有效，因为有可能不是用了设置的代理IP而是用了自己公网下的IP（可以用ifconfig查询所在局域网下的IP，及私网IP）</strong><a href="https://blog.csdn.net/Chenftli/article/details/86701563" target="_blank" rel="noopener">参考</a></p>
<p><details></p>
<summary><mark>查看隐藏代码</mark></summary>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_proxy_3</span><span class="params">(ip_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    测试是理IP</span></span><br><span class="line"><span class="string">    :param ip_list:</span></span><br><span class="line"><span class="string">    :return ip_valid_list: [&#123;https: ip&#125;,…]</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    ip_valid_list = []</span><br><span class="line">    test_url =  <span class="string">"http://httpbin.org/get"</span> <span class="comment"># 改网站可测试目前请求的IP</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> proxy <span class="keyword">in</span> ip_list:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = requests.get(test_url, proxies=proxy, headers=headers, timeout=<span class="number">8</span>)</span><br><span class="line">            data = response.text.strip()</span><br><span class="line">            proxyIP = json.loads(data)[<span class="string">'origin'</span>]</span><br><span class="line">            <span class="keyword">if</span> proxyIP != proxy[<span class="string">"https"</span>]:</span><br><span class="line">                ip_list.pop(i)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="comment">#print("proxy invalid")</span></span><br><span class="line">            ip_list.pop(i)</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> ip_valid_list</span><br></pre></td></tr></table></figure>
<details>

<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><p><details></p>
<summary><mark>隐藏</mark></summary>

<p>Max retries exceeded with url</p>
<ol>
<li><p>requests.exceptions.<strong>ProxyError</strong>: HTTPConnectionPool(host=’**<em>‘, port=443): Max retries exceeded with url: \</em>** (Caused by ProxyError(‘Cannot connect to proxy.’, NewConnectionError(‘<urllib3.connection.HTTPConnection object at 0x0000015363189190>: </p>
<blockquote>
<p>IP代理使用的协议不正常，http和https不能写错。</p>
</blockquote>
</li>
<li><p>requests.exceptions.<strong>ConnectionError</strong>: HTTPSConnectionPool(host=<em>**, , port=443): Max retries exceeded with url: \</em>** (Caused by NewConnectionError(‘<urllib3.connection.VerifiedHTTPSConnection object at 0x7fb51433af98>:</p>
<blockquote>
<p>http的连接数超过最大限制，默认的情况下连接是Keep-alive的，所以导致服务器保持了太多连接而不能再新建连接。</p>
</blockquote>
</li>
<li><p>HTTPSConnectionPool(host=’***‘, port=443): Max retries exceeded with url: ***(Caused by SSLError(SSLError(1, u’[SSL: CERTIFICATE_VERIFY_FAILED] certificate verify failed (_ssl.c:579)’),))</p>
<blockquote>
<p>Requests 可以为 HTTPS 请求验证 SSL 证书，就像 web 浏览器一样。SSL 验证默认是开启的，如果证书验证失败，Requests 会抛出 SSLError。</p>
<ul>
<li><p>不用ssl证书验证，将verify 设置为 False，<strong>page=requests.get(url，verify=False)</strong></p>
</li>
<li><p>requests默认是keep-alive的，可能没有释放，加参数 headers={‘Connection’:’close’}</p>
</li>
<li><p>增加连接重试次数：<code>requests.adapters.DEFAULT_RETRIES = 5</code> </p>
</li>
<li><p>关闭多余的连接：requests使用了urllib3库，默认的http connection是keep-alive的，requests设置False关闭。<code>s = requests.session()       s.keep_alive = False</code> </p>
<p>参考：<a href="https://blog.csdn.net/wdh315172/article/details/80491668" target="_blank" rel="noopener">https://blog.csdn.net/wdh315172/article/details/80491668</a></p>
</li>
</ul>
</blockquote>
<details>

</li>
</ol>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ul>
<li><a href="https://github.com/Hopetree/Jobs-search" target="_blank" rel="noopener">招聘网站爬虫</a></li>
<li><a href="https://github.com/Hopetree/E-commerce-crawlers" target="_blank" rel="noopener">电商网站爬虫</a></li>
<li><a href="https://github.com/Hopetree/Spiders100" target="_blank" rel="noopener">Spiders100</a></li>
<li><a href="https://github.com/Hopetree/MyTools" target="_blank" rel="noopener">一些界面化的爬虫小工具</a></li>
</ul>
<hr>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><ol>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/" target="_blank" rel="noopener">BeautifulSoup4官方中文文档</a></li>
<li><a href="[https://www.jianshu.com/p/2b783f7914c6](https://www.jianshu.com/p/2b783f7914c6">bs4模块使用指南</a>)</li>
<li><a href="https://python3webspider.cuiqingcai.com/" target="_blank" rel="noopener">Python3网络爬虫开发实战</a>​</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>requests</tag>
        <tag>BeautifulSoup</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习之Ajax,Selenium,Splash</title>
    <url>/2020/07/29/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8BAjax/</url>
    <content><![CDATA[<h2 id="异步数据加载"><a href="#异步数据加载" class="headerlink" title="异步数据加载"></a>异步数据加载</h2><p>向网站进行一次请求，一次只传部分数据。如：有些网页不需要点击下一页，其内容也可以源源不断地加载。</p>
<h2 id="Ajax数据爬取"><a href="#Ajax数据爬取" class="headerlink" title="Ajax数据爬取"></a>Ajax数据爬取</h2><a id="more"></a>
<h3 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h3><p>Ajax，全称为 Asynchronous JavaScript and XML，即异步的 JavaScript 和 XML。它不是一门编程语言，而是利用 JavaScript （JavaScript 可以实现页面的各种交互功能）在保证页面不被刷新、页面链接不改变的情况下与服务器交换数据并更新部分网页的技术。</p>
<p>一般出现在页面底部有“加载更多”，这其实就是 JavaScript 向服务器发送了一个 Ajax 请求，然后获取新的微博数据，将其解析，并将其渲染在网页中。</p>
<h3 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h3><p>简单分为以下 3 步：</p>
<ul>
<li><p>发送请求：Ajax 有其特殊的请求类型，叫作 xhr（XMLHttpRequest）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xmlhttp;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    <span class="comment">//code for IE7+, Firefox, Chrome, Opera, Safari</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> XMLHttpRequest();&#125; <span class="keyword">else</span> &#123;<span class="comment">//code for IE6, IE5</span></span><br><span class="line">    xmlhttp=<span class="keyword">new</span> ActiveXObject(<span class="string">"Microsoft.XMLHTTP"</span>);</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">if</span> (xmlhttp.readyState==<span class="number">4</span> &amp;&amp; xmlhttp.status==<span class="number">200</span>) &#123;<span class="built_in">document</span>.getElementById(<span class="string">"myDiv"</span>).innerHTML=xmlhttp.responseText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">xmlhttp.open(<span class="string">"POST"</span>,<span class="string">"/ajax/"</span>,<span class="literal">true</span>);</span><br><span class="line">xmlhttp.send();</span><br></pre></td></tr></table></figure>
<p>新建了 XMLHttpRequest 对象，然后调用 onreadystatechange 属性设置了监听，然后调用 open() 和 send() 方法向某个链接（也就是服务器）发送了请求。</p>
<p>前面用 Python 实现请求发送之后，可以得到响应结果，但这里请求的发送变成 JavaScript 来完成。由于设置了监听，所以当服务器返回响应时，onreadystatechange 对应的方法便会被触发，然后在这个方法里面解析响应内容即可。</p>
</li>
<li><p>解析内容</p>
<p>得到响应之后，onreadystatechange 属性对应的方法便会被触发，此时利用 xmlhttp 的 responseText 属性便可取到响应内容。这类似于 Python 中利用 requests 向服务器发起请求，然后得到响应的过程。那么返回内容可能是 HTML，可能是 JSON，接下来只需要在方法中用 JavaScript 进一步处理即可。比如，如果是 JSON 的话，可以进行解析和转化。</p>
</li>
<li><p>渲染网页</p>
<p>JavaScript 有改变网页内容的能力，解析完响应内容之后，就可以调用 JavaScript 来针对解析完的内容对网页进行下一步处理了。比如，通过 document.getElementById().innerHTML 这样的操作，便可以对某个元素内的源代码进行更改，这样网页显示的内容就改变了，这样的操作也被称作 DOM 操作，即对 Document 网页文档进行操作，如更改、删除等。</p>
<p><code>document.getElementById(&quot;myDiv&quot;).innerHTML=xmlhttp.responseText</code> 便将 ID 为 myDiv 的节点内部的 HTML 代码更改为服务器返回的内容，这样 myDiv 元素内部便会呈现出服务器返回的新数据，网页的部分内容看上去就更新了。</p>
</li>
</ul>
<h2 id="动态渲染页面抓取"><a href="#动态渲染页面抓取" class="headerlink" title="动态渲染页面抓取"></a>动态渲染页面抓取</h2><p>JavaScript 动态渲染的页面不止 Ajax 这一种，并且淘宝这种页面，它即使是 Ajax 获取的数据，但是其 Ajax 接口含有很多加密参数，我们难以直接找出其规律，也很难直接分析 Ajax 来抓取。</p>
<p>为了解决这些问题，我们可以<strong>直接使用模拟浏览器运行的方式来实现</strong> ，这样就可以做到在浏览器中看到是什么样，抓取的源码就是什么样，也就是可见即可爬。这样我们就不用再去管网页内部的 JavaScript 用了什么算法渲染页面，不用管网页后台的 Ajax 接口到底有哪些参数。</p>
<h3 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h3><p><a href="[http://www.selenium.org.cn/](http://www.selenium.org.cn/">Selenium</a>)是web自动化测试工具集，包括IDE、Grid、RC（selenium 1.0）、WebDriver（selenium 2.0）等。利用它可以驱动浏览器执行特定的动作，如点击、下拉等操作，同时还可以获取浏览器当前呈现的页面的源代码，做到可见即可爬。对于一些 JavaScript 动态渲染的页面来说，此种抓取方式非常有效。</p>
<p> <a href="[https://blog.csdn.net/huilan_same/article/details/52615123](https://blog.csdn.net/huilan_same/article/details/52615123">selenium自动化资源整理</a>)</p>
<p>[][<a href="https://selenium-python.readthedocs.io/][Selenium使用文档](https://selenium-python.readthedocs.io/" target="_blank" rel="noopener">https://selenium-python.readthedocs.io/][Selenium使用文档](https://selenium-python.readthedocs.io/</a>)</p>
<h4 id="声明浏览器对象"><a href="#声明浏览器对象" class="headerlink" title="声明浏览器对象"></a>声明浏览器对象</h4><p>Selenium 支持非常多的浏览器，如 Chrome、Firefox、Edge 等，还有 Android、BlackBerry 等手机端的浏览器。另外，也支持无界面浏览器 PhantomJS。初始化方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> selenium.webdriver</span><br><span class="line"></span><br><span class="line">driver = selenium.webdriver.Chrome()</span><br><span class="line">browser = webdriver.Firefox()</span><br><span class="line">browser = webdriver.Edge()</span><br><span class="line">browser = webdriver.Safari()</span><br><span class="line"><span class="comment"># 浏览器对象的初始化并将其赋值为 browser 对象，接下来，可以调用 browser 对象，让其执行各个动作以模拟浏览器操作。</span></span><br><span class="line"><span class="comment"># 要下载浏览器相应的驱动，并将其放入PATH中。例如，FireFox需要下载geckodriver</span></span><br></pre></td></tr></table></figure>
<h4 id="PhantomJS"><a href="#PhantomJS" class="headerlink" title="PhantomJS"></a>PhantomJS</h4><p>PhantomJS是一个无界面浏览器。抓取时，不会弹出窗口.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">browser = webdriver.PhantomJS()</span><br></pre></td></tr></table></figure>
<p>另外，它还支持命令行配置。比如，可以设置缓存和禁用图片加载的功能，进一步提高爬取效率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SERVICE_ARGS &#x3D; [&#39;--load-images&#x3D;false&#39;, &#39;--disk-cache&#x3D;true&#39;]</span><br><span class="line">browser &#x3D; webdriver.PhantomJS(service_args&#x3D;SERVICE_ARGS)</span><br></pre></td></tr></table></figure>
<ul>
<li>需要 “此电脑&gt;属性&gt;高级系统设置&gt;高级&gt;环境变量&gt;系统变量&gt;Path”里添加phantomjs.exe的解压路径</li>
<li>需要将指定参数executable_path=r’D:\software_apk\phantomjs-2.1.1-windows\bin\phantomjs.exe’否则会报错</li>
</ul>
<h4 id="Chrome-Headless-模式"><a href="#Chrome-Headless-模式" class="headerlink" title="Chrome Headless 模式"></a>Chrome Headless 模式</h4><p>从 Chrome 59 版本开始，已经开始支持 Headless 模式，也就是无界面模式，这样爬取的时候就不会弹出浏览器了。如果要使用此模式，请把 Chrome 升级到 59 版本及以上。启用 Headless 模式的方式如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">chrome_options = webdriver.ChromeOptions()</span><br><span class="line">chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">browser = webdriver.Chrome(chrome_options=chrome_options)</span><br></pre></td></tr></table></figure>
<h4 id="访问页面"><a href="#访问页面" class="headerlink" title="访问页面"></a>访问页面</h4><p>用 get() 方法来请求网页，参数传入链接 URL 即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://www.bilibili.com/"</span></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(url)</span><br><span class="line">print(browser.page_source)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>
<h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>Selenium 可以驱动浏览器完成各种操作，比如填充表单、模拟点击等。</p>
<p> Selenium 提供了一系列查找节点的方法，我们可以用这些方法来获取想要的节点，以便下一步执行一些动作或者提取信息。</p>
<h5 id="单个节点：-查找的目标在网页中只有一个"><a href="#单个节点：-查找的目标在网页中只有一个" class="headerlink" title="单个节点： 查找的目标在网页中只有一个"></a>单个节点： 查找的目标在网页中只有一个</h5><p>find_element_by_name() 是根据 name 值获取，find_element_by_id() 是根据 id 获取。另外，还有根据 XPath、CSS 选择器等获取的方式。</p>
<p>例如，从淘宝页面中提取搜索框这个节点：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input_first = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input_second = browser.find_element_by_css_selector(<span class="string">'#q'</span>)</span><br><span class="line">input_third = browser.find_element_by_xpath(<span class="string">'//*[@id="q"]'</span>)</span><br><span class="line">input_forth = browser.find_element(By.ID, <span class="string">'q'</span>)</span><br><span class="line">print(input_first, input_second, input_third, input_forth)</span><br><span class="line">browser.close()</span><br></pre></td></tr></table></figure>
<h5 id="多个节点"><a href="#多个节点" class="headerlink" title="多个节点"></a>多个节点</h5><p>如果有多个节点，再用 find_element() 方法查找，就只能得到第一个节点了。如果要查找所有满足条件的节点，需要用 find_elements() 这样的方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lis = browser.find_elements_by_css_selector(<span class="string">'.service-bd li'</span>)</span><br></pre></td></tr></table></figure>
<p>结果为列表，每个节点都是WebElement类型。</p>
<p>其他获取多个节点的方法：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">find_element_by_id</span><br><span class="line">find_element_by_name</span><br><span class="line">find_element_by_xpath</span><br><span class="line">find_element_by_link_text</span><br><span class="line">find_element_by_partial_link_text</span><br><span class="line">find_element_by_tag_name</span><br><span class="line">find_element_by_class_name</span><br><span class="line">find_element_by_css_selector</span><br><span class="line">find_elements(By.CSS_SELECTOR, <span class="string">'.service-bd li'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="节点交互"><a href="#节点交互" class="headerlink" title="节点交互"></a>节点交互</h4><p>Selenium 可以驱动浏览器来执行一些操作。比较常见的用法有：输入文字时用 send_keys 方法，清空文字时用 clear 方法，点击按钮时用 click 方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">input = browser.find_element_by_id(<span class="string">'q'</span>)</span><br><span class="line">input.send_keys(<span class="string">'iPhone'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">input.clear()</span><br><span class="line">input.send_keys(<span class="string">'iPad'</span>)</span><br><span class="line">button = browser.find_element_by_class_name(<span class="string">'btn-search'</span>)</span><br><span class="line">button.click()</span><br></pre></td></tr></table></figure>
<h4 id="动作链"><a href="#动作链" class="headerlink" title="动作链"></a>动作链</h4><p>有一些操作，它们<strong>没有特定的执行对象</strong> ，比如鼠标拖曳、键盘按键等，这些动作用另一种方式来执行，那就是<strong>动作链</strong> 。</p>
<p>比如，实现一个节点的拖曳操作，将某个节点从一处拖曳到另外一处：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver <span class="keyword">import</span> ActionChains</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line">source = browser.find_element_by_css_selector(<span class="string">'#draggable'</span>)</span><br><span class="line">target = browser.find_element_by_css_selector(<span class="string">'#droppable'</span>)</span><br><span class="line">actions = ActionChains(browser)</span><br><span class="line">actions.drag_and_drop(source, target)</span><br><span class="line">actions.perform()</span><br></pre></td></tr></table></figure>
<h4 id="执行-JavaScript"><a href="#执行-JavaScript" class="headerlink" title="执行 JavaScript"></a>执行 JavaScript</h4><p>Selenium API 并没有提供<strong>下拉进度条</strong> 等操作，但可以直接模拟运行 JavaScript，此时使用 execute_script() 方法即可实现，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.scrollTo(0, document.body.scrollHeight)'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'alert("To Bottom")'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="获取节点信息"><a href="#获取节点信息" class="headerlink" title="获取节点信息"></a>获取节点信息</h4><ul>
<li>通过 <code>page_source</code> 属性可以获取网页的源代码，也可以通过Selenium 提供的选择节点的方法，直接提取节点信息。</li>
</ul>
<ul>
<li>先通过查找节点，获取WebElement类型，再通过get_attribute() 方法，.text属性，.id属性，.location属性，.tag_name属性，.size属性，获取属性、文本、 ID、位置、标签名、大小</li>
</ul>
<h4 id="切换-Frame"><a href="#切换-Frame" class="headerlink" title="切换 Frame"></a>切换 Frame</h4><p>网页中有一种节点叫作 <strong>iframe</strong>，也就是<strong>子 Frame</strong>，相当于页面的<strong>子页面</strong>，它的结构和外部网页的结构完全一致。Selenium 打开页面后，它默认是在父级 Frame 里面操作，而此时如果页面中还有子 Frame，它是不能获取到子 Frame 里面的节点的。这时就需要使用 <code>switch_to.frame()</code> 方法来切换 Frame。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">url = <span class="string">'http://www.runoob.com/try/try.php?filename=jqueryui-api-droppable'</span></span><br><span class="line">browser.get(url)</span><br><span class="line">browser.switch_to.frame(<span class="string">'iframeResult'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line"><span class="keyword">except</span> NoSuchElementException:</span><br><span class="line">    print(<span class="string">'NO LOGO'</span>)</span><br><span class="line">browser.switch_to.parent_frame()</span><br><span class="line">logo = browser.find_element_by_class_name(<span class="string">'logo'</span>)</span><br><span class="line">print(logo)</span><br><span class="line">print(logo.text)</span><br></pre></td></tr></table></figure>
<h4 id="延时等待"><a href="#延时等待" class="headerlink" title="延时等待"></a>延时等待</h4><p>get() 方法会在网页框架加载结束后结束执行，此时如果获取 page_source，可能并不是浏览器完全加载完成的页面，所以，这里需要延时等待一定时间，确保节点已经加载出来。</p>
<h5 id="隐式等待"><a href="#隐式等待" class="headerlink" title="隐式等待"></a>隐式等待</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.implicitly_wait(<span class="number">10</span>)</span><br><span class="line">browser.get(<span class="string">'https://www.zhihu.com/explore'</span>)</span><br><span class="line">input = browser.find_element_by_class_name(<span class="string">'zu-top-add-question'</span>)</span><br><span class="line">print(input)</span><br></pre></td></tr></table></figure>
<p>当使用隐式等待 (<code>implicitly_wait()</code>) 执行测试时，如果 Selenium 没有在 DOM 中找到节点，将继续等待，超出设定时间后，则抛出找不到节点的异常。换句话说，当查找节点而节点并没有立即出现的时候，隐式等待将等待一段时间再查找 DOM，默认的时间是 0。</p>
<h5 id="显式等待"><a href="#显式等待" class="headerlink" title="显式等待"></a>显式等待</h5><p>显式等待方法，指定要查找的节点，然后<strong>指定一个最长等待时间</strong>。如果在规定时间内加载出来了这个节点，就返回查找的节点；如果到了规定时间依然没有加载出该节点，则抛出超时异常。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support.ui <span class="keyword">import</span> WebDriverWait</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.support <span class="keyword">import</span> expected_conditions <span class="keyword">as</span> EC</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com/'</span>)</span><br><span class="line">wait = WebDriverWait(browser, <span class="number">10</span>)</span><br><span class="line">input = wait.until(EC.presence_of_element_located((By.ID, <span class="string">'q'</span>)))</span><br><span class="line">button = wait.until(EC.element_to_be_clickable((By.CSS_SELECTOR, <span class="string">'.btn-search'</span>)))</span><br><span class="line">print(input, button)</span><br></pre></td></tr></table></figure>
<p>引入 WebDriverWait 对象，指定最长等待时间，调用其 until() 方法，传入要等待条件 expected_conditions。比如，传入 presence_of_element_located ，其参数是节点的定位元组( ID 为 q 的节点搜索框)。10 秒内如果 ID 为 q 的节点（即搜索框）成功加载出来，就返回该节点；否则，抛出异常。</p>
<p>按钮可以使用 element_to_be_clickable，( CSS 选择器为.btn-search 的按钮)，如果 10 秒内成功加载出来，即可点击，就返回该按钮节点；否则，抛出异常。</p>
<h6 id="其他等待条件"><a href="#其他等待条件" class="headerlink" title="其他等待条件"></a>其他等待条件</h6><p><a href="https://python3webspider.cuiqingcai.com/7.1selenium-de-shi-yong#xian-shi-deng-dai" target="_blank" rel="noopener">https://python3webspider.cuiqingcai.com/7.1selenium-de-shi-yong#xian-shi-deng-dai</a></p>
<h4 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h4><p>back() 和 forward() 方法 </p>
<h4 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h4><p>get_cookies() 方法获取所有的 Cookies，add_cookies() 添加删除， delete_all_cookies() 方法删除所有的 Cookies。</p>
<h4 id="选项卡管理"><a href="#选项卡管理" class="headerlink" title="选项卡管理"></a>选项卡管理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">browser = webdriver.Chrome()</span><br><span class="line">browser.get(<span class="string">'https://www.baidu.com'</span>)</span><br><span class="line">browser.execute_script(<span class="string">'window.open()'</span>)</span><br><span class="line">print(browser.window_handles)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">1</span>])</span><br><span class="line">browser.get(<span class="string">'https://www.taobao.com'</span>)</span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">browser.switch_to_window(browser.window_handles[<span class="number">0</span>])</span><br><span class="line">browser.get(<span class="string">'https://python.org'</span>)</span><br></pre></td></tr></table></figure>
<p>调用 execute_script() 方法，传入 window.open() 这个 JavaScript 语句新开启一个选项卡。</p>
<p>调用 window_handles 属性获取当前开启的所有选项卡，调用 switch_to_window() 方法切换到该选项卡。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>使用 try except 语句来捕获各种异常，都在selenium.common.exceptions下。</p>
<p>TimeoutException</p>
<p>NoSuchElementException</p>
<h3 id="Splash"><a href="#Splash" class="headerlink" title="Splash"></a>Splash</h3><p><a href="https://splash.readthedocs.io/en/stable/index.html" target="_blank" rel="noopener">Splash</a> 是一个 JavaScript 渲染服务，是一个带有 HTTP API 的轻量级浏览器，同时它对接了 Python 中的 Twisted 和 QT 库。</p>
<p>可以实现如下功能：</p>
<ul>
<li>异步方式处理多个网页渲染过程</li>
<li>获取渲染后的页面的源代码或截图</li>
<li>通过关闭图片渲染或者使用 Adblock 规则来加快页面渲染速度</li>
<li>可执行特定的 JavaScript 脚本</li>
<li>可通过 Lua 脚本来控制页面渲染过程</li>
<li>获取渲染的详细过程并通过 HAR（HTTP Archive）格式呈现</li>
</ul>
<p><a href="https://www.jianshu.com/p/feeb15f2e49b" target="_blank" rel="noopener">win10家庭版docker安装</a></p>
<ul>
<li>遇到问题，安装过程中将git bash卸载了。</li>
</ul>
<p><a href="https://www.cnblogs.com/samwu/p/10360943.html" target="_blank" rel="noopener">win10家庭版安装docker</a></p>
<ul>
<li>遇到问题，docker desk 无法启动，out of memory。。。</li>
</ul>
<p><a href="https://blog.csdn.net/pp_lan/article/details/90692510" target="_blank" rel="noopener">https://blog.csdn.net/pp_lan/article/details/90692510</a></p>
<h4 id="Splash-Lua-脚本"><a href="#Splash-Lua-脚本" class="headerlink" title="Splash Lua 脚本"></a>Splash Lua 脚本</h4><p>Splash 可以通过 Lua 脚本执行一系列渲染操作，这样我们就可以用 Splash 来模拟类似 Chrome、PhantomJS 的操作了。</p>
<h5 id="入口及返回值"><a href="#入口及返回值" class="headerlink" title="入口及返回值"></a>入口及返回值</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"http://www.baidu.com"</span>)</span><br><span class="line">  splash:wait(<span class="number">0.5</span>)</span><br><span class="line">  <span class="keyword">local</span> title = splash:evaljs(<span class="string">"document.title"</span>)</span><br><span class="line">  <span class="keyword">return</span> &#123;title=title&#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Splash 会默认调用main 方法。</li>
<li>返回值可以是字典形式，也可以是字符串形式，最后都会转化为 Splash HTTP Response。</li>
</ul>
<h5 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="keyword">local</span> example_urls = &#123;<span class="string">"www.baidu.com"</span>, <span class="string">"www.taobao.com"</span>, <span class="string">"www.zhihu.com"</span>&#125;</span><br><span class="line">  <span class="keyword">local</span> urls = args.urls <span class="keyword">or</span> example_urls</span><br><span class="line">  <span class="keyword">local</span> results = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> index, url <span class="keyword">in</span> <span class="built_in">ipairs</span>(urls) <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">local</span> ok, reason = splash:go(<span class="string">"http://"</span> .. url)</span><br><span class="line">    <span class="keyword">if</span> ok <span class="keyword">then</span></span><br><span class="line">      splash:wait(<span class="number">2</span>)</span><br><span class="line">      results[url] = splash:png()</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">return</span> results</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>运行后的返回结果是 3 个站点的截图</p>
<ul>
<li>字符串拼接操作符<code>..</code>，而不是python中的<code>+</code></li>
<li>go 方法会返回加载页面的结果状态，如果页面出现 4xx 或 5xx 状态码，ok 变量就为空，就不会返回加载后的图片。</li>
</ul>
<h4 id="Splash-对象属性"><a href="#Splash-对象属性" class="headerlink" title="Splash 对象属性"></a>Splash 对象属性</h4><p>splash类似于 Selenium 中的 WebDriver 对象。</p>
<h5 id="args"><a href="#args" class="headerlink" title="args"></a>args</h5><h5 id="js-enabled"><a href="#js-enabled" class="headerlink" title="js_enabled"></a>js_enabled</h5><p>这个属性是 Splash 的 JavaScript 执行开关，可以将其配置为 true 或 false 来控制是否执行 JavaScript 代码，默认为 true。</p>
<h5 id="resource-timeout"><a href="#resource-timeout" class="headerlink" title="resource_timeout"></a>resource_timeout</h5><p>设置加载的超时时间，单位是秒。如果设置为 0 或 nil（类似 Python 中的 None），代表不检测超时。</p>
<h5 id="images-enabled"><a href="#images-enabled" class="headerlink" title="images_enabled"></a>images_enabled</h5><p>设置图片是否加载，默认情况下是加载的。禁用该属性后，可以节省网络流量并提高网页加载速度。</p>
<ul>
<li>禁用图片加载可能会影响 JavaScript 渲染。因为禁用图片之后，它的外层 DOM 节点的高度会受影响，进而影响 DOM 节点的位置。因此，如果 JavaScript 对图片节点有操作的话，其执行就会受到影响。</li>
<li>Splash 使用了缓存。如果一开始加载出来了网页图片，然后禁用了图片加载，再重新加载页面，之前加载好的图片可能还会显示出来，这时直接重启 Splash 即可。</li>
</ul>
<h5 id="plugins-enabled"><a href="#plugins-enabled" class="headerlink" title="plugins_enabled"></a>plugins_enabled</h5><p>控制浏览器插件（如 Flash 插件）是否开启。默认情况下，此属性是 false。</p>
<h5 id="scroll-position"><a href="#scroll-position" class="headerlink" title="scroll_position"></a>scroll_position</h5><p>控制页面上下或左右滚动</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash.scroll_position = &#123;y=<span class="number">400</span>&#125;</span><br><span class="line">splash.scroll_position = &#123;x=<span class="number">100</span>, y=<span class="number">200</span>&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Splash-对象方法"><a href="#Splash-对象方法" class="headerlink" title="Splash 对象方法"></a>Splash 对象方法</h4><h5 id="go"><a href="#go" class="headerlink" title="go"></a>go</h5><p>该方法用来请求某个链接，而且它可以模拟 GET 和 POST 请求，同时支持传入请求头、表单等数据，其用法如下：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:go&#123;url, baseurl=<span class="literal">nil</span>, headers=<span class="literal">nil</span>, http_method=<span class="string">"GET"</span>, body=<span class="literal">nil</span>, formdata=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>
<p>返回值为ok和reason，如果 ok 为空，代表网页加载出现了错误，此时 reason 变量中包含了错误的原因，否则证明页面加载成功。</p>
<h5 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h5><p>控制页面等待时间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:wait&#123;time, cancel_on_redirect=false, cancel_on_error=true&#125;</span><br></pre></td></tr></table></figure>
<h5 id="jsfunc"><a href="#jsfunc" class="headerlink" title="jsfunc"></a>jsfunc</h5><p>直接调用 JavaScript 定义的方法，但是所调用的方法需要用双中括号包围，这相当于实现了 JavaScript 方法到 Lua 脚本的转换。</p>
<p>首先，声明了 JavaScript 定义的方法，然后在页面加载成功后调用了此方法计算出了页面中 div 节点的个数。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="keyword">local</span> get_div_count = splash:jsfunc(<span class="string">[[function () &#123;</span></span><br><span class="line"><span class="string">    var body = document.body;</span></span><br><span class="line"><span class="string">    var divs = body.getElementsByTagName('div');</span></span><br><span class="line"><span class="string">    return divs.length;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  ]]</span>)</span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  <span class="keyword">return</span> (<span class="string">"There are % s DIVs"</span>):<span class="built_in">format</span>(get_div_count())</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="evaljs"><a href="#evaljs" class="headerlink" title="evaljs"></a>evaljs</h5><p>执行 JavaScript 代码并返回最后一条 JavaScript 语句的返回结果。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">result = splash:evaljs(js)</span><br></pre></td></tr></table></figure>
<h5 id="runjs"><a href="#runjs" class="headerlink" title="runjs"></a>runjs</h5><p>执行 JavaScript 代码，它与 evaljs 方法的功能类似，但是更偏向于<strong>执行某些动作</strong>或<strong>声明某些方法</strong>。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  splash:runjs(<span class="string">"foo = function() &#123;return 'bar'&#125;"</span>)</span><br><span class="line">  <span class="keyword">local</span> result = splash:evaljs(<span class="string">"foo()"</span>)</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>用 runjs 方法先声明了一个 JavaScript 定义的方法，然后通过 evaljs 方法来调用得到的结果。</p>
<h5 id="autoload"><a href="#autoload" class="headerlink" title="autoload"></a>autoload</h5><p>设置每个页面访问时自动加载的对象。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">ok, reason = splash:autoload&#123;source_or_url, source=<span class="literal">nil</span>, url=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>方法只负责加载 JavaScript 代码或库，不执行任何操作。如果要执行操作，可以调用 evaljs 或 runjs 方法。</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:autoload(<span class="string">[[function get_document_title()&#123;return document.title;&#125;</span></span><br><span class="line"><span class="string">  ]]</span>)</span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com"</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:evaljs(<span class="string">"get_document_title()"</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用 autoload 方法加载某些方法库，如 jQuery，</li>
</ul>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  <span class="built_in">assert</span>(splash:autoload(<span class="string">"https://code.jquery.com/jquery-2.1.3.min.js"</span>))</span><br><span class="line">  <span class="built_in">assert</span>(splash:go(<span class="string">"https://www.taobao.com"</span>))</span><br><span class="line">  <span class="keyword">local</span> version = splash:evaljs(<span class="string">"$.fn.jquery"</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'JQuery version: '</span> .. version</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="call-later"><a href="#call-later" class="headerlink" title="call_later"></a>call_later</h5><p>设置定时任务和延迟时间来实现任务延时执行，并且可以在执行前通过 cancel 方法重新执行定时任务。</p>
<h5 id="htttp-get"><a href="#htttp-get" class="headerlink" title="htttp_get"></a>htttp_get</h5><p>拟发送 HTTP 的 GET 请求</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">response = splash:http_get&#123;url, headers=<span class="literal">nil</span>, follow_redirects=<span class="literal">true</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="http-post"><a href="#http-post" class="headerlink" title="http_post"></a>http_post</h5><figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">response = splash:http_post&#123;url, headers=<span class="literal">nil</span>, follow_redirects=<span class="literal">true</span>, body=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>body，可选参数，默认为空，即表单数据。</li>
</ul>
<h5 id="set-content"><a href="#set-content" class="headerlink" title="set_content"></a>set_content</h5><p>用来设置页面的内容</p>
<h5 id="html"><a href="#html" class="headerlink" title="html"></a>html</h5><p>用来获取网页的源代码</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash, args)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://httpbin.org/get"</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:html()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h5 id="png"><a href="#png" class="headerlink" title="png"></a>png</h5><p>获取 PNG 格式的网页截图</p>
<h5 id="jpeg"><a href="#jpeg" class="headerlink" title="jpeg"></a>jpeg</h5><p>用来获取 JPEG 格式的网页截图</p>
<h5 id="har"><a href="#har" class="headerlink" title="har"></a>har</h5><p>用来获取页面加载过程描述</p>
<h5 id="url"><a href="#url" class="headerlink" title="url"></a>url</h5><p>获取当前正在访问的 URL</p>
<h5 id="get-cokies"><a href="#get-cokies" class="headerlink" title="get_cokies"></a>get_cokies</h5><p>获取当前页面的 Cookies</p>
<h5 id="add-cokies"><a href="#add-cokies" class="headerlink" title="add_cokies"></a>add_cokies</h5><p>为当前页面添加 Cookies</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">cookies = splash:add_cookie&#123;name, value, <span class="built_in">path</span>=<span class="literal">nil</span>, domain=<span class="literal">nil</span>, expires=<span class="literal">nil</span>, httpOnly=<span class="literal">nil</span>, secure=<span class="literal">nil</span>&#125;</span><br></pre></td></tr></table></figure>
<h5 id="clear-cookies"><a href="#clear-cookies" class="headerlink" title="clear_cookies"></a>clear_cookies</h5><p>清除所有的 Cookies</p>
<h5 id="get-viewport-size"><a href="#get-viewport-size" class="headerlink" title="get_viewport_size"></a>get_viewport_size</h5><p>获取当前浏览器页面的大小，即宽高</p>
<h5 id="set-viewport-size"><a href="#set-viewport-size" class="headerlink" title="set_viewport_size"></a>set_viewport_size</h5><p>设置当前浏览器页面的大小，即宽高</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_viewport_size(width, height)</span><br></pre></td></tr></table></figure>
<h5 id="set-viewport-full"><a href="#set-viewport-full" class="headerlink" title="set_viewport_full"></a>set_viewport_full</h5><p>此方法可以设置浏览器全屏显示</p>
<h5 id="set-user-agent"><a href="#set-user-agent" class="headerlink" title="set_user_agent"></a>set_user_agent</h5><p>此方法可以设置浏览器的 User-Agent</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_user_agent(<span class="string">'Splash'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="set-custom-headers"><a href="#set-custom-headers" class="headerlink" title="set_custom_headers()"></a>set_custom_headers()</h5><p>此方法可以设置请求的 Headers</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">splash:set_custom_headers(&#123;[<span class="string">"User-Agent"</span>] = <span class="string">"Splash"</span>,</span><br><span class="line">     [<span class="string">"Site"</span>] = <span class="string">"Splash"</span>,</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>可以选中符合条件的第一个节点，如果有多个节点符合条件，则只会返回一个，其参数是 CSS 选择器。</p>
<h5 id="select-all"><a href="#select-all" class="headerlink" title="select_all()"></a>select_all()</h5><p>此方法可以选中所有的符合条件的节点，其参数是 CSS 选择器。</p>
<h5 id="mouse-click"><a href="#mouse-click" class="headerlink" title="mouse_click"></a>mouse_click</h5><p>此方法可以模拟鼠标点击操作，传入的参数为坐标值 x、y，也可以直接选中某个节点直接调用此方法。</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span><span class="params">(splash)</span></span></span><br><span class="line">  splash:go(<span class="string">"https://www.baidu.com/"</span>)</span><br><span class="line">  <span class="built_in">input</span> = splash:<span class="built_in">select</span>(<span class="string">"#kw"</span>)</span><br><span class="line">  <span class="built_in">input</span>:send_text(<span class="string">'Splash'</span>)</span><br><span class="line">  submit = splash:<span class="built_in">select</span>(<span class="string">'#su'</span>)</span><br><span class="line">  submit:mouse_click()</span><br><span class="line">  splash:wait(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">return</span> splash:png()</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h4 id="Splash-API-调用"><a href="#Splash-API-调用" class="headerlink" title="Splash API 调用"></a>Splash API 调用</h4><p>上述Splash Lua 脚本的用法，是在 Splash 页面里面测试运行的。</p>
<p>Splash 提供了一些 HTTP API 接口，请求这些接口并传递相应的参数即可获取页面渲染后的结果。</p>
<h5 id="render-html"><a href="#render-html" class="headerlink" title="render.html"></a>render.html</h5><p>用于获取 JavaScript 渲染的页面的 HTML 代码，接口地址就是 Splash 的运行地址加此接口名称</p>
<p><code>url = &#39;http://localhost:8050/render.html?url=https://www.baidu.com&#39;</code></p>
<p><code>url = &#39;http://localhost:8050/render.html?url=https://www.taobao.com&amp;amp;wait=5&#39;</code></p>
<h5 id="render-png"><a href="#render-png" class="headerlink" title="render.png"></a>render.png</h5><p>此接口可以获取网页截图,返回的是 PNG 格式的图片二进制数据</p>
<p><code>&#39;http://localhost:8050/render.png?url=https://www.jd.com&amp;wait=5&amp;width=1000&amp;height=700&#39;</code></p>
<h5 id="render-jpeg"><a href="#render-jpeg" class="headerlink" title="render.jpeg"></a>render.jpeg</h5><p>和 render.png 类似，返回的是 JPEG 格式的图片二进制数据。</p>
<p>另外此接口相比 render.png 还多了一个参数 quality，可以用来设置图片质量。</p>
<h5 id="render-har"><a href="#render-har" class="headerlink" title="render.har"></a>render.har</h5><p>此接口用于获取页面加载的 HAR 数据</p>
<p><code>http://localhost:8050/render.har?url=https://www.jd.com&amp;wait=5</code></p>
<h5 id="render-json"><a href="#render-json" class="headerlink" title="render.json"></a>render.json</h5><p>此接口包含了前面接口的所有功能，返回结果是 Json 格式</p>
<p><code>http://localhost:8050/render.json?url=https://httpbin.org&amp;html=1&amp;har=1</code></p>
<p>可以通过传入不同参数控制其返回结果。比如，传入 html=1，返回结果即会增加源代码数据；传入 png=1，返回结果即会增加页面 PNG 截图数据；传入 har=1，则会获得页面 HAR 数据。</p>
<h5 id="execute"><a href="#execute" class="headerlink" title="execute"></a>execute</h5><p>用此接口便可实现与 Lua 脚本的对接。实现一些交互操作。</p>
<p>将lua脚本转化为 URL 编码后的字符串，拼接到 execute 接口后面</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> quote</span><br><span class="line"></span><br><span class="line">lua = <span class="string">'''</span></span><br><span class="line"><span class="string">function main(splash)</span></span><br><span class="line"><span class="string">    return 'hello'</span></span><br><span class="line"><span class="string">end</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">url = <span class="string">'http://localhost:8050/execute?lua_source='</span> + quote(lua)</span><br><span class="line">response = requests.get(url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
        <tag>Selenium</tag>
        <tag>Slash</tag>
      </tags>
  </entry>
  <entry>
    <title>python爬虫学习之数据存储</title>
    <url>/2020/07/29/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h2 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h2><p>TXT, JSON, CSV等，以及关系型数据库MySQL，菲关系型数据库MongoDB、Redis 等</p>
<a id="more"></a>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><h4 id="TXT文本存储"><a href="#TXT文本存储" class="headerlink" title="TXT文本存储"></a>TXT文本存储</h4><p>文件写入还有一种简写方法，那就是使用 with as 语法。在 with 控制块结束时，文件会自动关闭，所以就不需要再调用 close 方法了。这种保存方式可以简写如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'explore.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> file:</span><br><span class="line">    file.write(<span class="string">'\n'</span>.join([question, author, answer]))</span><br><span class="line">    file.write(<span class="string">'\n'</span> + <span class="string">'='</span> * <span class="number">50</span> + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>JSON，全称为 JavaScript Object Notation, 也就是 JavaScript 对象标记，它通过对象和数组的组合来表示数据，构造简洁但是结构化程度非常高，是一种轻量级的数据交换格式。</p>
<h5 id="对象和数组"><a href="#对象和数组" class="headerlink" title="对象和数组"></a>对象和数组</h5><p>在 JavaScript 语言中，一切都是对象。因此，任何支持的类型都可以通过 JSON 来表示，例如字符串、数字、对象、数组等</p>
<p><strong>对象</strong> ：它在 JavaScript 中是使用花括号 {} 包裹起来的内容，数据结构为 {key1：value1, key2：value2, …} 的键值对结构。在面向对象的语言中，key 为对象的属性，value 为对应的值。键名可以使用整数和字符串来表示。值的类型可以是任意类型。</p>
<p><strong>数组</strong> ：数组在 JavaScript 中是方括号 [] 包裹起来的内容，数据结构为 [“java”, “javascript”, “vb”, …] 的索引结构。在 JavaScript 中，数组是一种比较特殊的数据类型，它也可以像对象那样使用键值对，但还是索引用得多。同样，值的类型可以是任意类型。</p>
<h5 id="读取和写入"><a href="#读取和写入" class="headerlink" title="读取和写入"></a>读取和写入</h5><p>loads() string to json # <strong>json数据需要使用双引号（</strong>double quotes<strong>）来包围</strong></p>
<p>dumps() json to string <code>son.dumps(data, indent=2)</code></p>
<p>注意：文本含有中文字符时，指定编码方式为<strong>utf-8</strong> 并且将ensure_ascii设为False：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'MaoYan_result.txt'</span>, <span class="string">'a'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(content, ensure_ascii=<span class="literal">False</span>) + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><p>见前篇：<a href="https://yuqie.github.io/2020/07/25/python%E4%B9%8Bcsv/" target="_blank" rel="noopener">python之csv</a></p>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><p>关系型数据库是基于<strong>关系模型</strong>的数据库，而关系模型是通过二维表来保存的，所以它的存储方式就是行列组成的表，每一列是一个字段，每一行是一条记录。表可以看作某个实体的集合，而实体之间存在联系，这就需要表与表之间的关联关系来体现，如主键外键的关联关系。多个表组成一个数据库，也就是关系型数据库。</p>
<p>关系型数据库有多种，如 SQLite、MySQL、Oracle、SQL Server、DB2 等。</p>
<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><p>在 Python 2 中，连接 MySQL 的库大多是使用 MySQLdb，但是此库的官方并不支持 Python 3，所以在Python3中使用 PyMySQL 操作 MySQL 数据库。</p>
<h5 id="创建新的数据库："><a href="#创建新的数据库：" class="headerlink" title="创建新的数据库："></a>创建新的数据库：</h5><p><code>&quot;CREATE DATABASE spiders DEFAULT CHARACTER SET utf8&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql  </span><br><span class="line"></span><br><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>,user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>)  </span><br><span class="line">cursor = db.cursor()  </span><br><span class="line">cursor.execute(<span class="string">"CREATE DATABASE spiders DEFAULT CHARACTER SET utf8"</span>)  </span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<p>之后重新连接数据库，指定参数db</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'123456'</span>, port=<span class="number">3306</span>, db=<span class="string">'spiders'</span>)</span><br><span class="line">cursor = db.cursor()</span><br></pre></td></tr></table></figure>
<h5 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a>创建表：</h5><p><code>&#39;CREATE TABLE IF NOT EXISTS students (id VARCHAR(255) NOT NULL, name VARCHAR(255) NOT NULL, age INT NOT NULL, PRIMARY KEY (id))&#39;</code></p>
<h5 id="插入数据："><a href="#插入数据：" class="headerlink" title="插入数据："></a>插入数据：</h5><p><code>&#39;INSERT INTO students(id, name, age) values(% s, % s, % s)&#39;</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    cursor.execute(sql, (id, user, age))</span><br><span class="line">    db.commit()</span><br><span class="line">except:</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<ul>
<li>对于数据插入、更新、删除操作，都需要执行 db 对象的 commit 方法才能真正生效，这个方法才是真正将语句提交到数据库执行的方法。</li>
<li>异常处理。如果执行失败，则调用 rollback 执行数据回滚，可以保证事务的一致性。</li>
<li>事务机制可以确保数据的一致性，也就是这件事要么发生了，要么没有发生。比如插入一条数据，不会存在插入一半的情况，要么全部插入，要么都不插入，这就是事务的原子性。</li>
<li>事务的 4 个属性，也称为 ACID 特性。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>原子性（atomicity）</td>
<td>事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做</td>
</tr>
<tr>
<td>一致性（consistency）</td>
<td>事务必须使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的</td>
</tr>
<tr>
<td>隔离性（isolation）</td>
<td>一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰</td>
</tr>
<tr>
<td>持久性（durability）</td>
<td>持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</td>
</tr>
</tbody>
</table>
</div>
<p><strong>动态数据传入</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20120001'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Bob'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span></span><br><span class="line">&#125;</span><br><span class="line">table = <span class="string">'students'</span></span><br><span class="line">keys = <span class="string">', '</span>.join(data.keys())</span><br><span class="line">values = <span class="string">', '</span>.join([<span class="string">'% s'</span>] * len(data))</span><br><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;)'</span>.format(table=table, keys=keys, values=values)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   <span class="keyword">if</span> cursor.execute(sql, tuple(data.values())):</span><br><span class="line">       print(<span class="string">'Successful'</span>)</span><br><span class="line">       db.commit()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line">    db.rollback()</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure>
<h5 id="更新数据："><a href="#更新数据：" class="headerlink" title="更新数据："></a>更新数据：</h5><p>现一种去重的方法，如果数据存在，则更新数据；如果数据不存在，则插入数据。</p>
<p><code>INSERT INTO students(id, name, age) VALUES (% s, % s, % s) ON DUPLICATE KEY UPDATE id = % s, name = % s, age = % s</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'INSERT INTO &#123;table&#125;(&#123;keys&#125;) VALUES (&#123;values&#125;) ON DUPLICATE KEY UPDATE'</span>.format(table=table, keys=keys, values=values)</span><br><span class="line">update = <span class="string">','</span>.join([<span class="string">"&#123;key&#125; = % s"</span>.format(key=key) <span class="keyword">for</span> key <span class="keyword">in</span> data])</span><br><span class="line">sql += update</span><br></pre></td></tr></table></figure>
<h5 id="删除数据："><a href="#删除数据：" class="headerlink" title="删除数据："></a>删除数据：</h5><p><code>&#39;DELETE FROM  {table} WHERE {condition}&#39;.format(table=table, condition=condition)</code></p>
<h5 id="查询数据："><a href="#查询数据：" class="headerlink" title="查询数据："></a>查询数据：</h5><p>查询年龄 20 岁及以上的学生<code>&#39;SELECT * FROM students WHERE age &gt;= 20&#39;</code></p>
<p>fetchone 方法，这个方法可以获取结果的第一条数据，返回结果是元组形式.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    print(<span class="string">'Count:'</span>, cursor.rowcount)</span><br><span class="line">    row = cursor.fetchone()</span><br><span class="line">    <span class="keyword">while</span> row:</span><br><span class="line">        print(<span class="string">'Row:'</span>, row)</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre></td></tr></table></figure>
<p>fetchall 方法，它可以得到结果的所有数据。然后将其结果和类型打印出来，它是二重元组，每个元素都是一条记录，我们将其遍历输出出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sql = <span class="string">'SELECT * FROM students WHERE age &gt;= 20'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    results = cursor.fetchall()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">        print(row)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Error'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="非关系型数据库存储"><a href="#非关系型数据库存储" class="headerlink" title="非关系型数据库存储"></a>非关系型数据库存储</h3><p>NoSQL，全称 Not Only SQL，意为不仅仅是 SQL，泛指非关系型数据库。NoSQL 是基于<strong>键值对</strong>的，而且不需要经过 SQL 层的解析，数据之间没有耦合性，性能非常高。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>代表</th>
</tr>
</thead>
<tbody>
<tr>
<td>键值存储数据库</td>
<td>Redis、Voldemort 和 Oracle BDB 等</td>
</tr>
<tr>
<td>列存储数据库</td>
<td>Cassandra、HBase 和 Riak 等</td>
</tr>
<tr>
<td>文档型数据库</td>
<td>CouchDB 和 MongoDB 等</td>
</tr>
<tr>
<td>图形数据库</td>
<td>Neo4J、InfoGrid 和 Infinite Graph 等</td>
</tr>
</tbody>
</table>
</div>
<p>对于<strong>爬虫的数据存储</strong>来说，一条数据可能存在<strong>某些字段提取失败而缺失</strong>的情况，而且<strong>数据可能随时调整</strong>。另外，数据之间还存在<strong>嵌套关系</strong>。如果使用关系型数据库存储，一是需要提前建表，二是如果存在数据嵌套关系的话，需要进行序列化操作才可以存储，这非常不方便。</p>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p>MongoDB 是由 <strong>C++ </strong> 语言编写的非关系型数据库，是一个基于<strong>分布式文件存储</strong> 的开源数据库系统，其内容存储形式类似 JSON 对象，它的字段值可以包含其他文档、数组及文档数组。</p>
<p><a href="https://www.jianshu.com/p/d99f6fd8b209" target="_blank" rel="noopener">安装MongoDB</a></p>
<p>CMD命令进入某个目录: 进入某个磁盘，直接盘符代号：如D：，不用CD 命令切换; 进入除根录以下的文件夹, cd 文件夹路径.</p>
<p>遇到warning：Access control is not enabled for the database.</p>
<p>原因分析：新版本的MongDB增加了安全性设计，推荐用户创建使用数据库时进行验证。如果用户想建立简单连接，则会提示警示信息。</p>
<p>解决办法：创建管理员并设置密码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">  &#123;</span><br><span class="line">    user: "userAdmin", //用户名</span><br><span class="line">    pwd: "123", //密码</span><br><span class="line">    roles: [ &#123; role: "userAdminAnyDatabase", db: "admin" &#125; ] //权限</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>重启MongoDB服务器</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mongod --auth --port <span class="number">27017</span> --dbpath &lt;关联路径:bin/&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>端口默认就是27017可以不指定</p>
<p><a href="https://blog.csdn.net/ttxsely/article/details/77726164" target="_blank" rel="noopener">https://blog.csdn.net/ttxsely/article/details/77726164</a></p>
</li>
</ul>
<h5 id="连接MongoDB"><a href="#连接MongoDB" class="headerlink" title="连接MongoDB"></a>连接MongoDB</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymongo</span><br><span class="line">client = pymongo.MongoClient(host=<span class="string">'localhost'</span>, port=<span class="number">27017</span>)</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">client = MongoClient(<span class="string">'mongodb://localhost:27017/'</span>)</span><br></pre></td></tr></table></figure>
<h5 id="指定数据库"><a href="#指定数据库" class="headerlink" title="指定数据库"></a>指定数据库</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">db = client.test</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">db = client[test]</span><br></pre></td></tr></table></figure>
<h5 id="指定集合（collection）"><a href="#指定集合（collection）" class="headerlink" title="指定集合（collection）"></a>指定集合（collection）</h5><p><strong>集合</strong>类似于关系型数据库中的<strong>表</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">collection = db.students</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">collection = db[<span class="string">'students'</span>]</span><br></pre></td></tr></table></figure>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">'id'</span>: <span class="string">'20170101'</span>,</span><br><span class="line">    <span class="string">'name'</span>: <span class="string">'Jordan'</span>,</span><br><span class="line">    <span class="string">'age'</span>: <span class="number">20</span>,</span><br><span class="line">    <span class="string">'gender'</span>: <span class="string">'male'</span></span><br><span class="line">&#125;</span><br><span class="line">result = collection.insert(student)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>在 MongoDB 中，每条数据其实都有一个_id 属性来唯一标识。如果没有显式指明该属性，MongoDB 会自动产生一个 ObjectId 类型的_id 属性。insert() 方法会在执行后返回_id 值。</p>
</li>
<li><p>以列表形式传递可同时插入多条数据。</p>
</li>
<li><p>PyMongo 3.x 版本中，官方不推荐使用 insert() 方法。而是推荐使用 insert_one() 和 insert_many() 方法来分别插入单条记录和多条记录。</p>
<p>insert_one() （返回InsertOneResult对象），用其 inserted_id 属性获取_id。</p>
<p>insert_many() （返回的类型是 InsertManyResult），调用 inserted_ids 属性可以获取插入数据的_id 列表。</p>
</li>
</ul>
<h5 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h5><ul>
<li>find_one() 查询得到的是单个结果，类型为字典：<code>result = collection.find_one({&#39;name&#39;: &#39;Mike&#39;})</code></li>
<li>find() 则返结果是 Cursor 类型，它相当于一个生成器：<code>results = collection.find({&#39;age&#39;: 20})</code></li>
<li>比较符号和功能符号：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>$lt</td>
<td>小于</td>
<td>{‘age’: {‘$lt’: 20}}</td>
</tr>
<tr>
<td>$gt</td>
<td>大于</td>
<td>{‘age’: {‘$gt’: 20}}</td>
</tr>
<tr>
<td>$lte</td>
<td>小于等于</td>
<td>{‘age’: {‘$lte’: 20}}</td>
</tr>
<tr>
<td>$gte</td>
<td>大于等于</td>
<td>{‘age’: {‘$gte’: 20}}</td>
</tr>
<tr>
<td>$ne</td>
<td>不等于</td>
<td>{‘age’: {‘$ne’: 20}}</td>
</tr>
<tr>
<td>$in</td>
<td>在范围内</td>
<td>{‘age’: {‘$in’: [20, 23]}}</td>
</tr>
<tr>
<td>$nin</td>
<td>不在范围内</td>
<td>{‘age’: {‘$nin’: [20, 23]}}</td>
</tr>
<tr>
<td>正则匹配查询</td>
<td>以 M 开头</td>
<td>{‘$regex’: ‘^M.*’}</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>符号</th>
<th>含义</th>
<th>示例</th>
<th>示例含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>$regex</td>
<td>匹配正则表达式</td>
<td>{‘$regex’: ‘^M.*’}</td>
<td>name 以 M 开头</td>
</tr>
<tr>
<td>$exists</td>
<td>属性是否存在</td>
<td>{‘name’: {‘$exists’: True}}</td>
<td>name 属性存在</td>
</tr>
<tr>
<td>$type</td>
<td>类型判断</td>
<td>{‘age’: {‘$type’: ‘int’}}</td>
<td>age 的类型为 int</td>
</tr>
<tr>
<td>$mod</td>
<td>数字模操作</td>
<td>{‘age’: {‘$mod’: [5, 0]}}</td>
<td>年龄模 5 余 0</td>
</tr>
<tr>
<td>$text</td>
<td>文本查询</td>
<td>{‘$text’: {‘$search’: ‘Mike’}}</td>
<td>text 类型的属性中包含 Mike 字符串</td>
</tr>
<tr>
<td>$where</td>
<td>高级条件查询</td>
<td>{‘$where’: ‘obj.fans_count == obj.follows_count’}</td>
<td>自身粉丝数等于关注数</td>
</tr>
</tbody>
</table>
</div>
<h5 id="计数"><a href="#计数" class="headerlink" title="计数"></a>计数</h5><p><code>count = collection.find({&#39;age&#39;: 20}).count()</code></p>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING)</code></p>
<p>调用 pymongo.ASCENDING 指定升序。如果要降序排列，可以传入 pymongo.DESCENDING。</p>
<h5 id="偏移"><a href="#偏移" class="headerlink" title="偏移"></a>偏移</h5><p>例如，忽略前两个元素，得到第三个及以后的元素：</p>
<p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2)</code></p>
<p>可以用 limit() 方法指定要取的结果个数：</p>
<p><code>results = collection.find().sort(&#39;name&#39;, pymongo.ASCENDING).skip(2).limit(2)</code></p>
<ul>
<li><p>在数据库数量非常庞大的时候，如千万、亿级别，最好不要使用大的偏移量来查询数据，因为这样很可能导致内存溢出。这时需要记录好上次查询的_id，使用类似如下操作来查询:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bson.objectid import ObjectId</span><br><span class="line">collection.find(&#123;&#39;_id&#39;: &#123;&#39;$gt&#39;: ObjectId(&#39;593278c815c2602678bb2b8d&#39;)&#125;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h5><ul>
<li><p>update</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">condition = &#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;</span><br><span class="line">student = collection.find_one(condition)</span><br><span class="line">student[<span class="string">'age'</span>] = <span class="number">25</span></span><br><span class="line">result = collection.update(condition, student)</span><br><span class="line"><span class="comment"># 使用 $set 操作符对数据进行更新</span></span><br><span class="line">result = collection.update(condition, &#123;<span class="string">'$set'</span>: student&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>update_one()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第二个参数不能再直接传入修改后的字典,而是需要使用 &#123;'$set': student&#125;</span></span><br><span class="line">condition = &#123;<span class="string">'age'</span>: &#123;<span class="string">'$gt'</span>: <span class="number">20</span>&#125;&#125;</span><br><span class="line">result = collection.update_one(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;) <span class="comment"># 执行之后会将第一条符合条件的数据年龄加 1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>update_many()，则会将所有符合条件的数据都更新</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.update_many(condition, &#123;<span class="string">'$inc'</span>: &#123;<span class="string">'age'</span>: <span class="number">1</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><ul>
<li><p>remove()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete_one()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_one(&#123;<span class="string">'name'</span>: <span class="string">'Kevin'</span>&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>delete_many()</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = collection.delete_many(&#123;<span class="string">'age'</span>: &#123;<span class="string">'$lt'</span>: <span class="number">25</span>&#125;&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h5><ul>
<li>组合方法，如 find_one_and_delete()、find_one_and_replace() 和 find_one_and_update(</li>
<li>对索引进行操作，如 create_index()、create_indexes() 和 drop_index() 等。</li>
</ul>
<h4 id="Redis-存储"><a href="#Redis-存储" class="headerlink" title="Redis 存储"></a>Redis 存储</h4><p>Redis 是一个基于<strong>内存</strong> 的高效的键值型非关系型数据库，存取效率极高，而且支持多种存储数据结构。</p>
<p>StrictRedis：set和get操作。</p>
<h5 id="连接-Redis"><a href="#连接-Redis" class="headerlink" title="连接 Redis"></a>连接 Redis</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis  </span><br><span class="line"></span><br><span class="line">redis = StrictRedis(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)  <span class="comment"># default： localhost、6379、0 和 None</span></span><br></pre></td></tr></table></figure>
<p>使用 ConnectionPool 来连接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> redis <span class="keyword">import</span> StrictRedis, ConnectionPool  </span><br><span class="line"></span><br><span class="line">pool = ConnectionPool(host=<span class="string">'localhost'</span>, port=<span class="number">6379</span>, db=<span class="number">0</span>, password=<span class="string">'foobared'</span>)  </span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure>
<p>ConnectionPool 还支持通过 URL 来构建, URL 的格式支持有如下 3 种</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis://[:password]@host:port/db   # 创建 Redis TCP 连接</span></span><br><span class="line"><span class="comment"># rediss://[:password]@host:port/db  # Redis TCP+SSL 连接</span></span><br><span class="line"><span class="comment"># unix://[:password]@/path/to/socket.sock?db=db # Redis UNIX socket 连接</span></span><br><span class="line">    </span><br><span class="line">url = <span class="string">'redis://:foobared@localhost:6379/0'</span>  </span><br><span class="line">pool = ConnectionPool.from_url(url)  </span><br><span class="line">redis = StrictRedis(connection_pool=pool)</span><br></pre></td></tr></table></figure>
<h5 id="键操作"><a href="#键操作" class="headerlink" title="键操作"></a>键操作</h5><h5 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h5><p>键值对形式存储</p>
<p>set(name,value) </p>
<p>mset(name,value)</p>
<p>get(value)</p>
<p>mget(value)</p>
<p>getset(name, value)</p>
<p>incr(name, amount=1)  键名为 name 的 value 增值操作，默认为 1，键不存在则被创建并设为 </p>
<p>decr(name, amount=1)</p>
<p>append(key, value)</p>
<h5 id="列表操作"><a href="#列表操作" class="headerlink" title="列表操作"></a>列表操作</h5><div class="table-container">
<table>
<thead>
<tr>
<th>方　　法</th>
<th>作　　用</th>
<th>参数说明</th>
<th>示　　例</th>
<th>示例说明</th>
<th>示例结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>rpush(name, *values)</td>
<td>在键名为 name 的列表末尾添加值为 value 的元素，可以传多个</td>
<td>name：键名；values：值</td>
<td>redis.rpush(‘list’, 1, 2, 3)</td>
<td>向键名为 list 的列表尾添加 1、2、3</td>
<td>3，列表大小</td>
</tr>
<tr>
<td>lpush(name, *values)</td>
<td>在键名为 name 的列表头添加值为 value 的元素，可以传多个</td>
<td>name：键名；values：值</td>
<td>redis.lpush(‘list’, 0)</td>
<td>向键名为 list 的列表头部添加 0</td>
<td>4，列表大小</td>
</tr>
<tr>
<td>llen(name)</td>
<td>返回键名为 name 的列表的长度</td>
<td>name：键名</td>
<td>redis.llen(‘list’)</td>
<td>返回键名为 list 的列表的长度</td>
<td>4</td>
</tr>
<tr>
<td>lrange(name, start, end)</td>
<td>返回键名为 name 的列表中 start 至 end 之间的元素</td>
<td>name：键名；start：起始索引；end：终止索引</td>
<td>redis.lrange(‘list’, 1, 3)</td>
<td>返回起始索引为 1 终止索引为 3 的索引范围对应的列表</td>
<td>[b’3’, b’2’, b’1’]</td>
</tr>
<tr>
<td>ltrim(name, start, end)</td>
<td>截取键名为 name 的列表，保留索引为 start 到 end 的内容</td>
<td>name：键名；start：起始索引；end：终止索引</td>
<td>ltrim(‘list’, 1, 3)</td>
<td>保留键名为 list 的索引为 1 到 3 的元素</td>
<td>True</td>
</tr>
</tbody>
</table>
</div>
<h5 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h5><p>集合中的元素都是不重复的</p>
<h5 id="有序集合操作"><a href="#有序集合操作" class="headerlink" title="有序集合操作"></a>有序集合操作</h5><p>有序集合比集合多了一个分数字段，利用它可以对集合中的数据进行排序</p>
<h5 id="散列操作"><a href="#散列操作" class="headerlink" title="散列操作"></a>散列操作</h5><p>散列表的数据结构</p>
<h5 id="RedisDump"><a href="#RedisDump" class="headerlink" title="RedisDump"></a>RedisDump</h5><p>提供了 Redis 数据的导入和导出功能，redis-dump 用于导出数据，redis-load 用于导入数据。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
        <tag>json，csv，数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>记人生的第一次面试</title>
    <url>/2020/07/21/%E8%AE%B0%E4%BA%BA%E7%94%9F%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95/</url>
    <content><![CDATA[<p>写在最前面：快26岁高龄才经历人生中第一次工作面试，值得写篇博客纪念一下。</p>
<a id="more"></a>
<h2 id="形式："><a href="#形式：" class="headerlink" title="形式："></a>形式：</h2><p>网络面试；2个HR，10分钟。</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><ol>
<li><p>1分钟自我介绍；</p>
</li>
<li><p>问了本科院系是下属院系（民办挂名）还是正经院系？</p>
<blockquote>
<p>原话不太一样，导致一开始竟然没有听出来HR的意思，还一本正经地向HR介绍。</p>
</blockquote>
</li>
<li><p>研究生升学是保研还是考研？</p>
</li>
<li><p>为什么选择招商银行，之后不打算做研究了么？</p>
<blockquote>
<p>主要从所学专业既可以继续在实验室探究更前沿的东西，也可以与企业，工业结合起来，并且战略客户部（有细分，房地产，新能源，电力等等）以及投资银行部（涉及行业研究）的岗位和专业有相关性，这样可以做到学以致用。</p>
</blockquote>
</li>
<li><p>能否接受城市的调剂？</p>
<blockquote>
<p>只有北京和深圳两个选项，个人无所谓，所以回答可以接受。</p>
</blockquote>
</li>
<li><p>能否接受岗位的调剂？</p>
<blockquote>
<p>报名表需要填写三个志愿，我先表示可以接受调剂，然后陈述第二个志愿与自己的契合点，但第三个志愿表现得有点不太乐意，HR问我帮你修改成前两个志愿可以么，我表示可以ORZ。深圳的职位和北京的不太一样（不一样怎么调剂城市呢），忘了问能不能加上深圳那边的某一个岗位。</p>
</blockquote>
</li>
</ol>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol>
<li>语速过快。</li>
<li>有点抢话，有时候没有听完HR的问题就开始接话准备回答了。</li>
</ol>
<hr>
<p>耐心等待结果！</p>
<p>​</p>
<p>​</p>
<p>​</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>《Scikit-Learn与TensorFlow机器学习实用指南》-第二部分</title>
    <url>/2020/09/03/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86/</url>
    <content><![CDATA[<p>学习资料参考：</p>
<p><a href="https://www.cntofu.com/book/27/docs/2.%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">一个完整的机器学习项目.md</a></p>
<p><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">原书Github上代码</a></p>
<p><a href="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/" target="_blank" rel="noopener">Oreilly上原书第二版（可以在线阅读）</a></p>
<p><a href="https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88.md" target="_blank" rel="noopener">第一版翻译</a></p>
<p><a href="https://www.jianshu.com/p/3470a6efbe8d" target="_blank" rel="noopener">简书第一版</a></p>
<p><a href="https://www.jianshu.com/p/86626c79814a" target="_blank" rel="noopener">简书第二版第二部分</a></p>
<p><a href="https://www.jianshu.com/p/4a94798f7dcc" target="_blank" rel="noopener">简书《Scikit-Learn、Keras与TensorFlow机器学习实用指南》第一版和第二版对照</a></p>
<p><a href="https://blog.csdn.net/jiaoyangwm/article/details/82387883#%E7%BB%83%E4%B9%A0%E9%A2%987" target="_blank" rel="noopener">练习题答案参考</a> <a href="https://blog.csdn.net/leowinbow/article/details/88581039" target="_blank" rel="noopener">参考2</a></p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="第10章-使用Keras搭建人工神经网络"><a href="#第10章-使用Keras搭建人工神经网络" class="headerlink" title="第10章 使用Keras搭建人工神经网络"></a>第10章 使用Keras搭建人工神经网络</h2><p>需要安装<a href="https://www.jianshu.com/p/3a76e4f0504a" target="_blank" rel="noopener">Tensorflow</a>和Keras</p>
<p>人工神经网络是受大脑中的生物神经元启发而来的机器学习模型。</p>
<p>人工神经网络是深度学习的核心，它不仅样式多样、功能强大，还具有可伸缩性，这让人工神经网络适宜处理庞大且复杂的机器学习任务，例如对数十亿张图片分类（谷歌图片）、语音识别（苹果Siri）、向数亿用户每天推荐视频（Youtube）、或者通过学习几百围棋世界冠军（DeepMind的AlphaGo）。</p>
<h3 id="神经元的逻辑计算"><a href="#神经元的逻辑计算" class="headerlink" title="神经元的逻辑计算"></a>神经元的逻辑计算</h3><p>1943年神经生理学家Warren McCulloch和数学家Walter Pitts在他们里程碑的论文<a href="https://scholar.google.com/scholar?q=A+Logical+Calculus+of+Ideas+Immanent+in+Nervous+Activity+author%3Amcculloch" target="_blank" rel="noopener">《A Logical Calculus of Ideas Immanent in Nervous Activity》</a> 中介绍了一个简单的生物神经元模型，它后来演化成了人工神经元：一个或多个二元（开或关）输入，一个二元输出。当达到一定的输入量时，神经元就会产生输出。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-51a591f44c8f7bba.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="感知机（单个TLU）"><a href="#感知机（单个TLU）" class="headerlink" title="感知机（单个TLU）"></a>感知机（单个TLU）</h3><p>感知机是最简单的人工神经网络结构之一，由 Frank Rosenblatt 发明于 1957年。</p>
<p>它基于一种稍微不同的人工神经元，阈值逻辑单元（TLU），或称为线性阈值单元（LTU）：输入和输出是数字（而不是二元开/关值），并且每个输入连接都一个权重。TLU计算其输入的加权和（$z = W_1x_1 + W_2x_2 + … + W_nx_n = x^T·W）$，然后将阶跃函数应用于该和，并输出结果：$h_W(x) = step(z)$，其中$z = x^T·W$。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c40c1380818019d3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1113/format/webp" alt="img"></p>
<h4 id="阶跃函数："><a href="#阶跃函数：" class="headerlink" title="阶跃函数："></a><strong>阶跃函数</strong>：</h4><p>单位阶跃函数（Heaviside step function）:</p>
<script type="math/tex; mode=display">
heaviside(z)=\left \{ \begin{array} {ll} 0& if\ z<0\\1&if \ z\geq 0 \end{array} \right.\\
sgn(z)=\left \{ \begin{array} {ll} 0& if\ z<0\\0 & if\ z =0\\1&if \ z\gt 0 \end{array} \right.</script><p>单一TLU 可用于简单的线性二元分类。它计算输入的线性组合，如果结果超过阈值，它输出正类或者输出负类（就像逻辑回归分类或线性SVM分类）。</p>
<p><strong>感知器只由一层 TLU 组成，每个TLU连接到所有输入</strong>。当一层的神经元连接着前一层的每个神经元时，该层被称为<strong>全连接层，或紧密层</strong>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-878dec9a6b1e9c09.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>通常再添加一个<strong>偏置特征（$X_0=1$）</strong>：这种偏置特性通常用一种称为偏置神经元的特殊类型的神经元来表示，它总是输出 1。</p>
<p>一个全连接层神经网络的输出：$h_{W,b}(x) = \phi (XW+B)$</p>
<h4 id="Hebb规则"><a href="#Hebb规则" class="headerlink" title="Hebb规则"></a>Hebb规则</h4><p>如何训练感知机：感知器一次被馈送一个训练实例，对于每个实例，它进行预测。对于每一个产生错误预测的输出神经元，修正输入的连接权重，以获得正确的预测。</p>
<script type="math/tex; mode=display">
\omega_{i,j}^{(next \ step)}=\omega_{i,j}+\eta (y_j-\hat y_j)x_i</script><p><strong>每个输出神经元的决策边界是线性的，因此感知器不能学习复杂的模式</strong>（比如 Logistic 回归分类器）。如果训练实例是线性可分的，Rosenblatt 证明该算法将收敛到一个解。这被称为<strong>感知器收敛定理</strong>。</p>
<p><strong>感知机不输出类概率，而是基于硬阈值进行预测。</strong></p>
<h4 id="感知机的局限性"><a href="#感知机的局限性" class="headerlink" title="感知机的局限性"></a>感知机的局限性</h4><ol>
<li>不能解决一些琐碎的问题（例如，异或（XOR）分类问题）（线性分类模型都不能解决异或问题）</li>
</ol>
<p>可以通过堆叠多个感知机消除，由此产生的人工神经网络被称为<strong>多层感知机（MLP）</strong>。特别地，MLP 可以解决 XOR 问题：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a8b41a11c481fc03.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="多层感知机（MLP）"><a href="#多层感知机（MLP）" class="headerlink" title="多层感知机（MLP）"></a>多层感知机（MLP）</h3><p>MLP 由一个输入层、一个或多个称为隐藏层的 TLU 组成，一个 TLU 层称为输出层（见图 10-7）。靠近输入层的层，通常被称为浅层，靠近输出层的层通常被称为上层。除了输出层，每一层都有一个偏置神经元，并且全连接到下一层。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-eb971779e84208ec.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>信号是从输入到输出单向流动，因此这种架构被称为<strong>前馈神经网络（FNN）</strong></p>
<p>当人工神经网络有多个隐含层时，称为<strong>深度神经网络（DNN）</strong></p>
<h3 id="反向传播（Back-Propagation）"><a href="#反向传播（Back-Propagation）" class="headerlink" title="反向传播（Back Propagation）"></a>反向传播（Back Propagation）</h3><p>一种训练 MLP 的方法，使用了高效梯度计算的梯度下降算法只需要两次网络传播（一次向前，一次向后），就可以算出网络误差的、和每个独立模型参数相关的梯度。</p>
<blockquote>
<ol>
<li>每次处理一个微批次（假如每个批次包含32个实例），用训练集多次训练BP，每次被称为一个周期（epoch）；</li>
<li>每个微批次先进入输入层，输入层再将其发到第一个隐藏层。计算得到该层所有神经元的（微批次的每个实例的）输出。输出接着传到下一层，直到得到输出层的输出。这个过程就是<strong>前向传播</strong>：就像做预测一样，只是保存了每个中间结果，中间结果要用于反向传播；</li>
<li>然后计算输出误差（使用损失函数比较目标值和实际输出值，然后返回误差）；</li>
<li>通过<strong>链式法则</strong>（对多个变量做微分）计算每个输出连接对误差的贡献量；</li>
<li>使用<strong>链式法则</strong>，计算最后一个隐藏层的每个连接对误差的贡献，这个过程不断向后传播，直到到达输入层。</li>
<li>BP算法做一次梯度下降步骤，用刚刚计算的误差梯度调整所有连接权重。</li>
</ol>
</blockquote>
<p>对每个训练实例，BP算法先做一次预测（前向传播），然后计算误差，然后反向通过每一层以测量误差贡献量（反向传播），最后调整所有连接权重以降低误差（梯度下降）。（每个循环：向前，向后，调整参数）</p>
<p><strong>注意：</strong></p>
<blockquote>
<p><strong>要机初始化隐藏层的连接权重</strong>。假如所有的权重和偏置都初始化为0，则在给定一层的所有神经元都是一样的，BP算法对这些神经元的调整也会是一样的。换句话，就算每层有几百个神经元，模型的整体表现就像每层只有一个神经元一样，模型会显得笨笨的。如果权重是随机初始化的，就可以打破对称性，训练出不同的神经元。</p>
<p><strong>自动计算梯度被称为自动微分。</strong>反向传播使用的是<strong>反向模式自微分</strong>。这种方法快而准，当函数有多个变量（连接权重）和多个输出（损失函数）要微分时也能应对。</p>
</blockquote>
<h4 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h4><p>用其他激活函数代替阶跃函数（因为阶跃函数只包含平坦的段，因此没有梯度，而 Logistic函数处处都有一个定义良好的非零导数，允许梯度下降在每步上取得一些进展。）</p>
<ul>
<li><p>sigmoid（Logistic）函数：输出范围0~1</p>
<p>$\sigma(z)=\frac{1}{1+\exp(-z)}$</p>
</li>
</ul>
<ul>
<li><p>双曲正切函数： S形，连续可微，输出范围-1~1</p>
<p>$\tanh (z) = 2σ(2z) – 1$</p>
</li>
<li><p>ReLU 函数：连续，但在<code>z=0</code>处不可微，没有最大输出值，但效果好，计算快速</p>
<p>$ReLU(z) = max(0, z)$</p>
</li>
<li><p>softplus函数：ReLU函数的平滑变体,z是负值时，softplus接近0，z是正值时，softplus接近z</p>
<p>$softplus(z) = log(1 + exp(z))$</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-cfc40648369f3b02.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>设置激活函数的原因</strong>：</p>
<p>如果将几个线性变化链式组合起来，得到的还是线性变换。比如，对于 <code>f(x) = 2x + 3</code> 和 <code>g(x) = 5x – 1</code> ，两者组合起来仍是线性变换：<code>f(g(x)) = 2(5x – 1) + 3 = 10x + 1</code>。<strong>如果层之间不具有非线性，则深层网络和单层网络其实是等同的，这样就不能解决复杂问题。</strong>相反的，足够深且有非线性激活函数的DNN（深度神经网络），在理论上可以近似于任意连续函数。</p>
<h3 id="回归MLP"><a href="#回归MLP" class="headerlink" title="回归MLP"></a>回归MLP</h3><p>预测一个单值，就只需要一个输出神经元；一次预测多个值，则每一维度都要有一个神经元。</p>
<p>回归问题可以不用激活函数，如果想限制输出落到一定范围内，可以使用激活函数。</p>
<p><strong>损失函数</strong>：一般使用<strong>均方误差</strong>，但如果训练集有许多异常值，则可以使用<strong>平均绝对误差</strong>。也可以使用<strong>Huber损失函数</strong>，它是前两者的组合。</p>
<blockquote>
<p>提示：当误差小于阈值δ时（一般为1），Huber损失函数是二次的；误差大于阈值时，Huber损失函数是线性的。相比均方误差，线性部分可以让Huber对异常值不那么敏感，二次部分可以让收敛更快，也比均绝对误差更精确。</p>
</blockquote>
<p><strong>回归MLP的典型架构</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-51306abe073c8ea2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="分类MLP"><a href="#分类MLP" class="headerlink" title="分类MLP"></a>分类MLP</h3><p>二元分类问题：需要一个使用Logistic激活的输出神经元：输出一个0和1之间的值，作为正类的估计概率。</p>
<p>多标签二元分类问题：需要为每个正类配一个输出神经元。多个输出概率的和不一定非要等于1。</p>
<p>多分类：softmax函数可以保证，每个估计概率位于0和1之间，并且各个值相加等于1。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-be616eb033cc7b19.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><strong>损失函数</strong>： 预测概率分布，可以使用交叉商损失函数</p>
<p><strong>分类MLP的典型架构</strong></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9e017b74d26835cf.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>如何在Jupyter Notebook中使用Python虚拟环境？</title>
    <url>/2020/08/25/%E5%A6%82%E4%BD%95%E5%9C%A8Jupyter%20Notebook%E4%B8%AD%E4%BD%BF%E7%94%A8Python%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83%EF%BC%9F/</url>
    <content><![CDATA[<p>电脑中多版本python并存，直接安装过python，使用过anaconda全家桶，同时创建过虚拟环境（虽然我也不知道两个都是python3.7为啥要用虚拟环境），这就导致了一个问题。</p>
<a id="more"></a>
<h2 id="虚拟环境下运行spyder"><a href="#虚拟环境下运行spyder" class="headerlink" title="虚拟环境下运行spyder"></a>虚拟环境下运行spyder</h2><p>在打开spyder时，默认使用base，如何使用虚拟环境呢？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入环境后</span></span><br><span class="line">spyder</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果已经打开spyder了</span></span><br><span class="line">spyder --new-instance</span><br></pre></td></tr></table></figure>
<h2 id="Jupyter-notebook使用虚拟环境"><a href="#Jupyter-notebook使用虚拟环境" class="headerlink" title="Jupyter notebook使用虚拟环境"></a>Jupyter notebook使用虚拟环境</h2><p>即便通过anaconda创造了新的虚拟环境，但是在jupyter 中并没有体现出来。</p>
<blockquote>
<p>尝试过<code>conda activate env</code> 进入虚拟环境，再执行jupyter notebook，结果还是使用默认python（D:\\Program Files (x86)\\Anaconda3\py37\\python.exe’），此时会出现一些包import失败的问题。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如何查看使用的是哪个版本的python</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path</span><br><span class="line">sys.executable</span><br></pre></td></tr></table></figure>
<h3 id="解决办法1："><a href="#解决办法1：" class="headerlink" title="解决办法1："></a>解决办法1：</h3><p>直接在sys.path这个列表append虚拟环境下的python路径和python库路径。</p>
<p>但是这种解决方案没有永久性，退出之后重新打开该文件运行时，则又会import失败，输出sys.path，发现之前加入的路径也不存在了。</p>
<h3 id="解决办法2："><a href="#解决办法2：" class="headerlink" title="解决办法2："></a>解决办法2：</h3><p><strong>用anaconda内生插件解决问题</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda install nb_conda</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已有的kernels</span></span><br><span class="line">jupyter kernelspec list</span><br></pre></td></tr></table></figure>
<p>再次启动jupyter notebook，就能看到<strong>所有虚拟环境</strong>都显示出来了。</p>
<p><strong>用jupyter插件解决问题</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">conda activate env</span><br><span class="line">conda install ipykernel</span><br><span class="line">python -m ipykernel install --name --display-name</span><br></pre></td></tr></table></figure>
<p>网上还有方法是安装ipykernel，不知道为什么，我可以看到kernel显示了虚拟环境，但是切换之后，没有效果，sys.exectubale仍然输出默认python的路径。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ol>
<li>anaconda powershell prompt 和 anaconda prompt的区别：前者多了一些linux命令，如pwd等，类似windows下cmd和windows powershell的区别。</li>
<li>虽然可以在prompt中通过cd切换文件夹，再打开jupyter notebook，或者在jupyter notebook命令后指定文件夹路径，但略显繁琐。<ul>
<li>在windows powershell下也可以运行jupyter notebook，所以可以在windows下打开文件夹，shift+鼠标右键，打开windows powershell，输入jupyter notebook命令</li>
<li>打开目标文件夹，选中上方文件位置栏，输入jupyter notebook即可</li>
<li>另外，如果想在windows powershell中激活虚拟环境，可执行：<code>conda init</code></li>
</ul>
</li>
<li>也可以到该文件夹下，右键-git bash，在git bash中启动jupyter notebook</li>
<li>注意2,3需要将anaconda安装路径里面的Scripts和Library\bin路径添加到windows系统环境变量中。</li>
</ol>
<h2 id="jupyter-notebook快捷键"><a href="#jupyter-notebook快捷键" class="headerlink" title="jupyter notebook快捷键"></a>jupyter notebook快捷键</h2><p>Jupyter Notebook 有两种键盘输入模式。</p>
<ol>
<li>编辑模式（enter进入），可以向单元中键入代码或文本；此时单元框线为绿色。</li>
<li>命令模式（Esc开启），键盘输入运行程序命令；此时单元框线为灰蓝色。</li>
</ol>
<h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>tab</td>
<td>代码补全或缩进</td>
<td>Ctrl+Up</td>
<td>跳到单元开头</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>shift+tab</td>
<td>提示</td>
<td>Ctrl+End</td>
<td>跳到单元末尾</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>ctrl+]</td>
<td>缩进</td>
<td>Ctrl+Down</td>
<td>跳到单元末尾</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>ctrl+[</td>
<td>解除缩进</td>
<td>Ctrl+Left</td>
<td>跳到左边一个字首</td>
<td>Ctrl+Shift+-</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+A</td>
<td>全选</td>
<td>Ctrl+Right</td>
<td>跳到右边一个字首</td>
<td>Ctrl+Shift+Subtract</td>
<td>分割单元</td>
</tr>
<tr>
<td>ctrl+Z</td>
<td>复原</td>
<td>Ctrl+Backspace</td>
<td>删除前面一个字</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
</tr>
<tr>
<td>ctrl+shift+z</td>
<td>再做</td>
<td>Ctrl+Delete</td>
<td>删除后面一个字</td>
<td>Shift</td>
<td>忽略</td>
</tr>
<tr>
<td>ctrl+y</td>
<td>再做</td>
<td>Esc</td>
<td>进入命令模式</td>
<td>Up</td>
<td>光标上移或转入上一单元</td>
</tr>
<tr>
<td>ctrl+Home</td>
<td>跳到单元开头</td>
<td>Ctrl+M</td>
<td>进入命令模式</td>
<td>Down</td>
<td>光标下移或转入下一单元</td>
</tr>
</tbody>
</table>
</div>
<h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><div class="table-container">
<table>
<thead>
<tr>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
<th>命令</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>enter</td>
<td>转入编辑模式</td>
<td>C</td>
<td>复制选中的单元</td>
<td>Shift+Enter</td>
<td>运行本单元，选中下一单元</td>
</tr>
<tr>
<td>Y</td>
<td>单元转入代码状态</td>
<td>V</td>
<td>粘贴到下方单元</td>
<td>Ctrl+Enter</td>
<td>运行本单元</td>
</tr>
<tr>
<td>M</td>
<td>单元转入markdown状态</td>
<td>Z</td>
<td>恢复删除的最后一个单元</td>
<td>Alt+Enter</td>
<td>运行本单元，在下面插入一单元</td>
</tr>
<tr>
<td>R</td>
<td>单元转入raw状态</td>
<td>DD</td>
<td>删除选中的单元</td>
<td>shift+K</td>
<td>扩大选中上方单元</td>
</tr>
<tr>
<td>1</td>
<td>设定 1 级标题</td>
<td>Ctrl+S</td>
<td>文件存盘</td>
<td>shift+J</td>
<td>扩大选中下方单元</td>
</tr>
<tr>
<td>2</td>
<td>设定 12级标题</td>
<td>S</td>
<td>文件存盘</td>
<td>shift+O</td>
<td>转换输出滚动</td>
</tr>
<tr>
<td>A</td>
<td>在上方插入新单元</td>
<td>L</td>
<td>转换行号</td>
<td>shift</td>
<td>忽略</td>
</tr>
<tr>
<td>B</td>
<td>在下方插入新单元</td>
<td>O</td>
<td>转换输出</td>
<td>K</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>X</td>
<td>剪切选中的单元</td>
<td>Q</td>
<td>关闭页面</td>
<td>J</td>
<td>选中下方单元</td>
</tr>
<tr>
<td>shift+V</td>
<td>粘贴到上方单元</td>
<td>H</td>
<td>显示快捷键帮助</td>
<td>Up</td>
<td>选中上方单元</td>
</tr>
<tr>
<td>shift+M</td>
<td>合并选中的单元</td>
<td>space</td>
<td>向下滚动</td>
<td>Down</td>
<td>选中下方单元</td>
</tr>
</tbody>
</table>
</div>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://blog.csdn.net/w55100/article/details/88925697" target="_blank" rel="noopener">简书：使用anaconda虚拟环境运行Jupyter Notebook详解</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/50456606" target="_blank" rel="noopener">Jupyter notebok 环境配置，与kernel切换（切换虚拟环境）</a></p>
<p><a href="https://blog.csdn.net/guolaoban11/article/details/103469952?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">jupyter notebook 打开任意文件夹，最简捷！！</a></p>
<p><a href="https://blog.csdn.net/lzbmc/article/details/102955750" target="_blank" rel="noopener">Jupyter Notebook在指定文件夹（位置）打开</a></p>
<p><a href="https://blog.csdn.net/lawme/article/details/51034543" target="_blank" rel="noopener">Jupyter Notebook 的快捷键</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>jupyter notebook</tag>
      </tags>
  </entry>
  <entry>
    <title>三星平板N8000刷机</title>
    <url>/2020/08/26/%E4%B8%89%E6%98%9F%E5%B9%B3%E6%9D%BFN8000%E5%88%B7%E6%9C%BA/</url>
    <content><![CDATA[<blockquote>
<p>刷机包+工具如下：</p>
<p>CWMRecoveryGTN8000.tar +  lineage-14.1-20170116-UNOFFICIAL-n8000.zip</p>
<p>线刷宝（用以进入挖煤模式）+ Odin</p>
</blockquote>
<a id="more"></a>
<p>家里小朋友在上网课，想买个平板，唤起了我对三星平板的记忆，大概13年入手，不过一两年没开过机了。</p>
<p>好不容易返校，拿出平板，发现不错，还能充电，也能开机。里面乱七八糟都是些啥，还有人人，干脆恢复出厂设置吧。</p>
<p>问题就出在这里，恢复出厂设置后发现没有三星应用中心了，也不能更新，因为之前用了kingsroot。那似乎只能刷机了。</p>
<ol>
<li><p>开机键+电源上键进入recovery模式，有install from external storage的选项，但是不支持第三方ROM包。</p>
<p>强行刷第三方包，会出出现：</p>
<p>E:failed to verify whole-file signature<br>e:signature verification failed<br>installation aborted</p>
</li>
<li><p>要刷第三方ROM包，需要先刷第三方recovery包。</p>
<p>电源键+音量下键进入挖煤模式，使用Odin刷入第三方REC包，旧版选择PDA，新版选择AP，其他不要勾选，一些默认勾选的也要去掉，点击start，几秒钟就可以了。</p>
</li>
</ol>
<p><img src="http://www.galaxyclub.cn//Upload/IMAGES/18/0507/126b124121ee40feb9f95aa5bc78c040_650x0.png" alt="【技术】Odin中的术语BL、AP、CP、CSC是什么意思？"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>BL(Bootloader) **</strong>：**</th>
<th>代表 <strong>引导程序</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AP (Application Processor or PDA)  **</strong>：**</td>
<td>表示<strong>Android系统</strong>（可能代表Android系统分区）; 在之前的Odin版本中，这被称为“PDA”</td>
</tr>
<tr>
<td><strong>CP(Core Processor**</strong>） ：**</td>
<td><strong> </strong>代表 <strong>调制解调器</strong></td>
</tr>
<tr>
<td><strong>CSC(Co numer Software Customization) **</strong>：**</td>
<td>代表 <strong>消费者软件定制</strong>，它包含特定于该地区的软件包，运营商品牌和APN设置（就像不同的运营商的数据接入点名称不通）。</td>
</tr>
<tr>
<td><strong>PIT (Partition Information Table)  **</strong>：**</td>
<td>代表 <strong>分区信息表</strong>，如果你搞砸分区表，或者由于分区表布局的变化，你只需要用它就好了。</td>
</tr>
</tbody>
</table>
</div>
<p>但又遇到问题了：电源键+音量下键无法进入挖煤模式，不知道是否跟之前用第三方软件root过有关，并且我的板子的电源键也不太好用，事态似乎陷入了僵局，只能求助第三方刷机软件<a href="http://www.xianshuabao.com/features/?fromsite=bd_xsb" target="_blank" rel="noopener">线刷宝</a>。</p>
<p>进入挖煤模式后，ID:COM 变成蓝色（实际上，正常开机连接时，应该是蓝色，挖煤模式连接时应为黄色，可能还是之前root过得原因）</p>
<p>不需要付费模式，只需要借助工具箱进入挖煤模式即可！也可以通过线刷宝进入recovery模式（谁让我的电源键不好用呢）。</p>
<ol>
<li>输入第三方ROM包</li>
</ol>
<p>将第三方包的zip文件放大存储卡中，卡刷，选择external card，这一步比较顺利。</p>
<p>因为一些帖子有反馈说无法联网，我没有遇到这个问题，顺利进入系统。但是无法调出键盘输入界面。</p>
<ol>
<li>将平板变成显示器</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/81255397" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/81255397</a></p>
<p><strong>Spacedesk</strong> 电脑和平板需要处于同一局域网下</p>
<p><strong>Splashtop Wired XDisplay</strong> 通过数据线连接，需要在google play上下载</p>
<p><strong>Twomon SE</strong></p>
<p><a href="https://www.splashtop.com/cn/wiredxdisplay](https://www.splashtop.com/cn/wiredxdisplay" target="_blank" rel="noopener">https://www.splashtop.com/cn/wiredxdisplay](https://www.splashtop.com/cn/wiredxdisplay</a>)</p>
<h2 id=""><a href="#" class="headerlink" title=" "></a> </h2><p>主要参考<a href="https://www.jianshu.com/p/182975bd9ee6" target="_blank" rel="noopener">简书</a>和<a href="https://blog.csdn.net/wulong710/article/details/91956773" target="_blank" rel="noopener">CSDN</a> 上的两个帖子。</p>
<p><a href="https://sspai.com/post/43338" target="_blank" rel="noopener">Android 玩机终极指南</a> 这个也值得一看。</p>
]]></content>
      <categories>
        <category>日常记录</category>
      </categories>
      <tags>
        <tag>刷机</tag>
        <tag>三星</tag>
        <tag>N8000</tag>
      </tags>
  </entry>
  <entry>
    <title>词云</title>
    <url>/2020/08/18/%E8%AF%8D%E4%BA%91/</url>
    <content><![CDATA[<p><a href="https://python123.io/tutorials/word_cloud/" target="_blank" rel="noopener">python123你不知道的词云</a></p>
<a id="more"></a>
<p>关键问题：<strong>如何做到词语之间紧密排布但又没有重叠</strong></p>
<h3 id="integral-image积分图"><a href="#integral-image积分图" class="headerlink" title="integral_image积分图"></a>integral_image积分图</h3><p>重叠检测方法：</p>
<p>词云布局方法：贪心策略</p>
<p><strong>矩形检测的积分图算法似乎不能很好的支持文字的旋转</strong></p>
<h3 id="四叉树"><a href="#四叉树" class="headerlink" title="四叉树"></a>四叉树</h3><p><strong>层次边界框</strong>（Hierarchical bounding boxes）来快速实现两个词语间的重叠检测。本质上是一棵记录空间信息的四叉树。</p>
<p>四叉树的构建并不困难，将图片横纵各切一刀，平均分割为「左上、左下、右上、右下」四个区域，如果某个区域中有内容（此时可以用积分图算法判断），那么继续将这个区域分割为四个部分，直到区域的大小小于某个值。</p>
<p>四叉树每深一层，对形状的描述就越精确，每一次分隔，都能排除一些空白矩形区域，剩下的有像素的区域，都记录到了树中。</p>
<p>之后两颗四叉树逐层判断。</p>
<h3 id="矩形螺旋布局"><a href="#矩形螺旋布局" class="headerlink" title="矩形螺旋布局"></a>矩形螺旋布局</h3><p>一种贪心布局策略，所有的单词紧密放置在图中心的螺旋形状上。每个单词都从螺旋的中心位置开始检测，如果不能放置，就移动到螺旋的下一个位置。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>一种策略的想法来源于四叉树。先把图像分割为多个矩形区域，比如 800×600 的图片，分割为 48（8×6）个区域，每个区域长宽都是 100 像素。布局每个单词后，就将这个单词添加到对应的区域中，这样在布局一个新的单词时，只要根据单词大概的大小和放置的位置，在有限的几个区域中进行重叠检测，大幅降低了需要进行重叠检测的次数。</p>
<p>第二种策略更多来源于经验。假如要放置数十个大小差不多的单词，第一个单词检测了螺旋上的 200 个坐标后，找到一个放置位置，那么下一个单词就跳过这 200 个坐标（因为大概率重叠），在第 300 个坐标上放置，下一个单词从第 300 个坐标开始……如果检测到了图片边界未找到可以放置的坐标，那么回到初始位置重新寻找。</p>
<h3 id="其他资源"><a href="#其他资源" class="headerlink" title="其他资源"></a>其他资源</h3><p><a href="https://github.com/TommyZihao/zihaowordcloud" target="_blank" rel="noopener">同济子豪兄在github上的词云可视化教程（wordcloud）</a></p>
<p>在线词云生成网站：</p>
<p><a href="http://www.yciyun.com/" target="_blank" rel="noopener">易词云</a></p>
<p><a href="http://www.picdata.cn/picdata/index.php" target="_blank" rel="noopener">图悦</a></p>
<p><a href="https://me.bdp.cn/home.html" target="_blank" rel="noopener">BDP</a></p>
<p><a href="https://www.jianshu.com/p/615c9d285c54" target="_blank" rel="noopener">https://www.jianshu.com/p/615c9d285c54</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>wordcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>《Scikit-Learn与TensorFlow机器学习实用指南》</title>
    <url>/2020/08/25/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B/</url>
    <content><![CDATA[<p>学习资料参考：</p>
<p><a href="https://www.cntofu.com/book/27/docs/2.%E4%B8%80%E4%B8%AA%E5%AE%8C%E6%95%B4%E7%9A%84%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E9%A1%B9%E7%9B%AE.md" target="_blank" rel="noopener">一个完整的机器学习项目.md</a></p>
<p><a href="https://github.com/ageron/handson-ml2" target="_blank" rel="noopener">原书Github上代码</a></p>
<p><a href="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/" target="_blank" rel="noopener">Oreilly上原书第二版（可以在线阅读）</a></p>
<p><a href="https://github.com/apachecn/hands-on-ml-zh/blob/master/docs/1.%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%A6%82%E8%A7%88.md" target="_blank" rel="noopener">第一版翻译</a></p>
<p><a href="https://www.jianshu.com/p/3470a6efbe8d" target="_blank" rel="noopener">简书第一版</a></p>
<p><a href="https://www.jianshu.com/p/86626c79814a" target="_blank" rel="noopener">简书第二版第二部分</a></p>
<p><a href="https://www.jianshu.com/p/4a94798f7dcc" target="_blank" rel="noopener">简书《Scikit-Learn、Keras与TensorFlow机器学习实用指南》第一版和第二版对照</a></p>
<p><a href="https://blog.csdn.net/jiaoyangwm/article/details/82387883#%E7%BB%83%E4%B9%A0%E9%A2%987" target="_blank" rel="noopener">练习题答案参考</a> <a href="https://blog.csdn.net/leowinbow/article/details/88581039" target="_blank" rel="noopener">参考2</a></p>
<a id="more"></a>
<p>[TOC]</p>
<h2 id="第01章-机器学习概览"><a href="#第01章-机器学习概览" class="headerlink" title="第01章 机器学习概览"></a>第01章 机器学习概览</h2><ol>
<li><p>os.makedirs(IMAGES_PATH, exist_ok=True)</p>
</li>
<li><p>pd.merge(left=oecd_bli, right=gdp_per_capita, left_index=True, right_index=True)</p>
<p>left_index和right_index：指定是否以索引为参考进行合并</p>
<!--more-->
<h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><ol>
<li>如何定义机器学习？</li>
</ol>
<blockquote>
<p>机器学习是通过编程让计算机从数据中进行学习的科学（和艺术）。</p>
<p><strong>更广义的概念：</strong></p>
<p>机器学习是让计算机具有学习的能力，无需进行明确编程。 —— 亚瑟·萨缪尔，1959</p>
<p><strong>工程性的概念：</strong></p>
<p>计算机程序利用经验 E 学习任务 T，性能是 P，如果针对任务 T 的性能 P 随着经验 E 不断增长，则称为机器学习。 —— 汤姆·米切尔，1997</p>
</blockquote>
<ol>
<li>机器学习可以解决的四类问题？</li>
</ol>
<blockquote>
<p>分类，回归，聚类，降维</p>
<p>机器学习可以根据训练时监督的量和类型进行分类。主要有四类：监督学习、非监督学习、半监督学习和强化学习。</p>
</blockquote>
<ol>
<li>什么是带标签的训练集？</li>
</ol>
<blockquote>
<p>在监督学习中，用来训练算法的训练数据包含了答案，称为标签。</p>
</blockquote>
<ol>
<li>最常见的两个监督任务是什么？</li>
</ol>
<blockquote>
<ol>
<li>分类：例如垃圾邮件过滤器：用许多带有归类（垃圾邮件或普通邮件）的邮件样本进行训练，过滤器必须还能对新邮件进行分类。</li>
<li>回归：预测目标数值，例如给出一些特征（里程数、车龄、品牌等等）称作预测值，来预测一辆汽车的价格。。要训练这个系统，需要给出大量汽车样本，包括它们的预测值和标签（即，它们的价格）。</li>
</ol>
</blockquote>
<ol>
<li>指出四个常见的非监督任务？</li>
</ol>
<blockquote>
<ol>
<li><strong>聚类算法</strong> ，检测相似访客的分组。假设有一份关于博客访客的大量数据，不告诉算法某个访客属于哪一类：它会自己找出关系，无需帮助。例如，算法可能注意到 40% 的访客是喜欢漫画书的男性，通常是晚上访问，20% 是科幻爱好者，他们是在周末访问等等。如果使用<strong>层次聚类分析</strong> ，它可能还会细分每个分组为更小的组。这可以帮助你为每个分组定位博文。</li>
<li><strong>可视化算法</strong> ：给算法大量复杂的且不加标签的数据，算法输出数据的2D或3D图像。算法会试图保留数据的结构（即尝试保留输入的独立聚类，避免在图像中重叠），这样就可以明白数据是如何组织起来的，也许还能发现隐藏的规律。</li>
<li><strong>降维</strong> ：降维的目的是简化数据、但是不能失去大部分信息。做法之一是合并若干相关的特征。例如，汽车的里程数与车龄高度相关，降维算法就会将它们合并成一个，表示汽车的磨损。这叫做<strong>特征提取</strong> 。</li>
<li><strong>异常检测（anomaly detection）</strong> ：例如，检测异常的信用卡转账以防欺诈，检测制造缺陷，或者在训练之前自动从训练数据集去除异常值。异常检测的系统使用正常值训练的，当它碰到一个新实例，它可以判断这个新实例是像正常值还是异常值。</li>
</ol>
</blockquote>
<ol>
<li>要让一个机器人能在各种未知地形行走，你会采用什么机器学习算法？</li>
</ol>
<blockquote>
<p>强化学习：</p>
</blockquote>
<ol>
<li>要对你的顾客进行分组，你会采用哪类算法？</li>
</ol>
<blockquote>
<p>非监督学习</p>
</blockquote>
<ol>
<li>垃圾邮件检测是监督学习问题，还是非监督学习问题？</li>
</ol>
<blockquote>
<p>监督学习：因为有标签</p>
</blockquote>
<ol>
<li>什么是在线学习系统？</li>
</ol>
<blockquote>
<p>从导入的数据流进行持续学习</p>
<p>在在线学习中，是用数据实例持续地进行训练，可以一次一个或一次几个实例（称为小批量）。每个学习步骤都很快且廉价，所以系统可以动态地学习收到的最新数据</p>
<p><img src="https://github.com/apachecn/hands-on-ml-zh/raw/master/images/chapter_1/1-13.png" alt="img"></p>
</blockquote>
<ol>
<li>什么是核外学习？</li>
</ol>
<blockquote>
<p>在线学习算法也适用于在超大数据集（一台计算机不足以用于存储它）上训练系统（这称作核外学习，<em>out-of-core</em> learning）。算法每次只加载部分数据，用这些数据进行训练，然后重复这个过程，直到使用完所有数据</p>
</blockquote>
<ol>
<li>什么学习算法是用相似度做预测？</li>
</ol>
<blockquote>
<p>基于实例学习：系统先用记忆学习案例，然后使用相似度测量推广到新的例子</p>
<p>例如，垃圾邮件检测器，不仅能标记和已知的垃圾邮件相同的邮件，也要能标记类似垃圾邮件的邮件。需要测量两封邮件的相似性。一个（简单的）相似度测量方法是统计两封邮件包含的相同单词的数量。如果一封邮件含有许多垃圾邮件中的词，就会被标记为垃圾邮件。</p>
</blockquote>
<ol>
<li>模型参数和学习算法的超参数的区别是什么？</li>
</ol>
<blockquote>
<p>学习算法搜寻模型参数值，使代价函数最小</p>
<p>超参数（hyperparameter）是一个学习算法的参数（而不是模型的），控制正则化的度。</p>
</blockquote>
<ol>
<li>基于模型学习的算法搜寻的是什么？最成功的策略是什么？基于模型学习如何做预测？</li>
</ol>
<blockquote>
<p>搜寻使得代价函数（测量线性模型的预测值和训练样本之间的距离差）最小的模型参数</p>
<p>线性回归算法</p>
<p>研究数据-选择模型-用训练数据进行训练（学习算法搜寻模型参数值，使得代价函数最小）-使用模型对新案例进行预测（这称作推断）</p>
</blockquote>
<ol>
<li>机器学习的四个主要挑战是什么？</li>
</ol>
<blockquote>
<p>训练数据量不足</p>
<p>没有代表性的训练数据</p>
<p>低质量数据</p>
<p>不相关的特征</p>
<p>过拟合</p>
<p>欠拟合</p>
</blockquote>
<ol>
<li>如果模型在训练集上表现好，但推广到新实例表现差，问题是什么？给出三个可能的解决方案。</li>
</ol>
<blockquote>
<p>过拟合：利用超参数正则化</p>
<p>不相关特征：</p>
<ul>
<li>特征选择：在所有存在的特征中选取最有用的特征进行训练。</li>
<li>特征提取：组合存在的特征，生成一个更有用的特征（如前面看到的，可以使用降维算法）。</li>
<li>收集新数据创建新特征。</li>
</ul>
<p>低质量数据：如果训练集中的错误、异常值和噪声（错误测量引入的）太多，系统检测出潜在规律的难度就会变大，性能就会降低。</p>
<ul>
<li>如果一些实例是明显的异常值，最好删掉它们或尝试手工修改错误；</li>
<li>如果一些实例缺少特征（比如，你的 5% 的顾客没有说明年龄），你必须决定是否忽略这个属性、忽略这些实例、填入缺失值（比如，年龄中位数），或者训练一个含有这个特征的模型和一个不含有这个特征的模型，等等。</li>
</ul>
</blockquote>
<ol>
<li>什么是测试集，为什么要使用它？</li>
</ol>
<blockquote>
<p>测试集：用来训练模型的数据集</p>
</blockquote>
<ol>
<li>验证集的目的是什么？</li>
</ol>
<blockquote>
<p>验证集：数据中分出来，对模型进行测试的数据集。</p>
<p>评估模型推广到新样本的效果（即对新样本的性能），可以将模型部署到生产环境，观察它的性能。这么做可以，但如果模型的性能很差，就会引起用户抱怨。更好的选项是将数据分成训练集和测试集。用训练集进行训练，用测试集进行测试。对新样本的错误率称作<strong>推广错误（或样本外错误）</strong> ，通过模型对测试集的评估，可以预估这个错误。这个值可以我们模型对新样本的性能。</p>
</blockquote>
<ol>
<li>如果用测试集调节超参数，会发生什么？</li>
</ol>
<blockquote>
<p>过拟合</p>
<p>在测试集上多次测量了推广误差率，调整了模型和超参数，以使模型最适合这个集合。这意味着模型对新数据的性能不会高。</p>
</blockquote>
<ol>
<li>什么是交叉验证，为什么它比验证集好？</li>
</ol>
<blockquote>
<p>交叉验证：训练集分成互补的子集，每个模型用不同的子集训练，再用剩下的子集验证。一旦确定模型类型和超参数，最终的模型使用这些超参数和全部的训练集进行训练，用测试集得到推广误差率。</p>
<p>而使用验证集：用训练集和多个超参数训练多个模型，选择在验证集上有最佳性能的模型和超参数。当对模型满意时，用测试集再做最后一次测试，以得到推广误差率的预估，会“浪费”过多训练数据在验证集上。</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="第02章-一个完整的机器学习项目"><a href="#第02章-一个完整的机器学习项目" class="headerlink" title="第02章 一个完整的机器学习项目"></a>第02章 一个完整的机器学习项目</h2><p>[Python API：crc32函数 计算CRC校验值](<a href="https://b）" target="_blank" rel="noopener">https://b）</a></p>
<p><a href="https://blog.csdn.net/liuyu60305002/article/details/6307152" target="_blank" rel="noopener">模2运算</a></p>
<p><a href="https://blog.csdn.net/sparkliang/article/details/5671510" target="_blank" rel="noopener">CRC32算法详细推导</a></p>
<blockquote>
<p>crc32用于计算 <em>data</em> 的 CRC (A cyclic redundancy check 32，循环冗余校验) 值。计算的结果是一个 32 位的整数。本质是<strong>模2除法模2运算包括模2加、模2减、模2乘、模2除四种二进制运算，不考虑进位和借位）</strong>， 的余数，采用的除数不同，CRC的类型也就不一样。通常，CRC的除数用生成多项式来表示。</p>
<p>此算法没有加密强度，不应用于身份验证和数字签名。仅<strong>为验证数据的正确性</strong> ，不适合作为通用散列算法。</p>
<h4 id="特点：检错能力极强，开销小等"><a href="#特点：检错能力极强，开销小等" class="headerlink" title="特点：检错能力极强，开销小等"></a>特点：检错能力极强，开销小等</h4><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>CRC 算法是以 GF(2) 多项式算术为数学基础的， GF(2) 多项式中只有一个变量 x ，其系数也只有 0 和 1 ，比如：</p>
<p>​    1 <em>x^6 + 0</em>x^5 + 1<em>x^4 + 0</em>x^3 + 0<em>x^2 +1</em>x^1 + 1*x^0</p>
<p>​       = x^6 + x^4 + x + 1</p>
<p>加减运算不考虑进位和退位。说白了就是下面的运算规则：</p>
<p>​    0 + 0 = 0    0 - 0 = 0</p>
<p>​    0 + 1 = 1    0 - 1 = 1</p>
<p>​    1 + 0 = 1    1 - 0 = 1</p>
<p>​    1 + 1 = 0    1 - 1 = 0<br>看看这个规则，其实就是一个<strong>异或运算</strong> 。</p>
<p>每个生成多项式的系数只能是 0 或 1 ，因此可以把它转化为二进制形式表示， 比如 g(x)=x^4 + x + 1 ，那么 g(x) 对应的二进制形式就是 10011 ， 于是把 GF(2) 多项式的除法转换成了二进制形式，和普通除法没有区别，只是加减运算没有进位和退位。</p>
<p>比如基于上述规则计算 11010/1001 ，那么商是 11 ，余数就是 1。</p>
<h4 id="CRC-校验的基本过程"><a href="#CRC-校验的基本过程" class="headerlink" title="CRC 校验的基本过程"></a>CRC 校验的基本过程</h4><p>采用 CRC 校验时，发送方和接收方用同一个生成多项式 g(x) ， g(x) 是一个 GF(2) 多项式，并且 g(x) 的首位和最后一位的系数必须为 1 。</p>
<p>CRC 的处理方法是：发送方用发送数据的二进制多项式 t(x) 除以 g(x) ，得到余数 y(x) 作为 CRC 校验码。校验时，以计算的校正结果是否为 0 为据，判断数据帧是否出错。设生成多项式是 r 阶的（最高位是 x^r ）具体步骤如下面的描述。</p>
<p>发送方：</p>
<p>1 ）在发送的 m 位数据的二进制多项式 t(x) 后添加 r 个 0 ，扩张到 m+ r 位，以容纳 r 位的校验码，追加 0 后的二进制多项式为  T(x) ；</p>
<p>2 ）用 T(x) 除以生成多项式 g(x) ，得到 r 位的余数 y(x) ，它就是 CRC 校验码；</p>
<p>3 ）把 y(x) 追加到 t(x) 后面，此时的数据 s(x) 就是包含了 CRC 校验码的待发送字符串；由于 s(x) = t(x) y(x) ，因此 s(x) 肯定能被 g(x) 除尽。</p>
<p>接收方：</p>
<p>1 ）接收数据 n(x) ，这个 n(x) 就是包含了 CRC 校验码的 m+r 位数据；</p>
<p>2 ）计算 n(x) 除以 g(x) ，如果余数为 0 则表示传输过程没有错误，否则表示有错误。从 n(x) 去掉尾部的 r 位数据，得到的就是原始数据。</p>
<p>生成多项式不是随意选择的，以下是一些标准的 CRC 算法的生成多项式：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标准</th>
<th>生成多项式</th>
<th>16 进制表示</th>
</tr>
</thead>
<tbody>
<tr>
<td>CRC12</td>
<td>x^12 + x^11 + x^3 + x^2 + x + 1</td>
<td>0x80F</td>
</tr>
<tr>
<td>CRC16</td>
<td>x^16 + x^15 + x^2 + 1</td>
<td>0x8005</td>
</tr>
<tr>
<td>CRC16-CCITT</td>
<td>x^16 + x^12 + x^5 + 1</td>
<td>0x1021</td>
</tr>
<tr>
<td>CRC32</td>
<td>x^32 + x^26 + x^23 + x^22 + x^16 + x^12 + x^11+ x^10 + x^8 + x^7 + x^5 + x^4 + x^2 + x + 1</td>
<td>0x04C11DB7</td>
</tr>
</tbody>
</table>
</div>
<p>在python 3.0 之后: 返回值永远是无符号数。要在所有的 Python 版本和平台上获得相同的值，请使用 <strong>crc32(data) &amp; 0xffffffff</strong>。</p>
</blockquote>
<p><strong>问题：</strong> </p>
<p>使用本章的房产数据集：</p>
<ol>
<li>尝试一个支持向量机回归器（<code>sklearn.svm.SVR</code>），使用多个超参数，比如<code>kernel=&quot;linear&quot;</code>（多个超参数<code>C</code>值）。现在不用担心这些超参数是什么含义。最佳的<code>SVR</code>预测表现如何？</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> SVR</span><br><span class="line"></span><br><span class="line">&gt;svm_reg = SVR(kernel=<span class="string">"linear"</span>)</span><br><span class="line">&gt;svm_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">&gt;housing_predictions = svm_reg.predict(housing_prepared)</span><br><span class="line">&gt;svm_mse = mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">&gt;svm_rmse = np.sqrt(svm_mse)</span><br><span class="line">&gt;svm_rmse <span class="comment"># output: 111094.6308539982</span></span><br></pre></td></tr></table></figure>
<p>结果不好。</p>
</blockquote>
<ol>
<li>尝试用<code>RandomizedSearchCV</code>替换<code>GridSearchCV</code>。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> RandomizedSearchCV</span><br><span class="line">&gt;<span class="keyword">from</span> scipy.stats <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line">&gt;param_distribs = &#123;</span><br><span class="line">       <span class="string">'n_estimators'</span>: randint(low=<span class="number">1</span>, high=<span class="number">200</span>),</span><br><span class="line">       <span class="string">'max_features'</span>: randint(low=<span class="number">1</span>, high=<span class="number">8</span>),</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&gt;forest_reg = RandomForestRegressor(random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search = RandomizedSearchCV(forest_reg, param_distributions=param_distribs,</span><br><span class="line">                               n_iter=<span class="number">10</span>, cv=<span class="number">5</span>, scoring=<span class="string">'neg_mean_squared_error'</span>, random_state=<span class="number">42</span>)</span><br><span class="line">&gt;rnd_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>尝试在准备流水线中添加一个只选择最重要属性的转换器。</li>
</ol>
<blockquote>
<p>​</p>
</blockquote>
<ol>
<li>尝试创建一个单独的可以完成数据准备和最终预测的流水线。</li>
</ol>
<blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;full_pipeline_with_predictor = Pipeline([</span><br><span class="line">       (<span class="string">"preparation"</span>, full_pipeline),</span><br><span class="line">       (<span class="string">"linear"</span>, LinearRegression())</span><br><span class="line">   ])</span><br><span class="line"></span><br><span class="line">&gt;full_pipeline_with_predictor.fit(housing, housing_labels)</span><br><span class="line">&gt;full_pipeline_with_predictor.predict(some_data)</span><br></pre></td></tr></table></figure>
</blockquote>
<ol>
<li>使用<code>GridSearchCV</code>自动探索一些准备过程中的候选项。</li>
</ol>
<h2 id="第03章-分类"><a href="#第03章-分类" class="headerlink" title="第03章 分类"></a>第03章 分类</h2><p><a href="https://blog.csdn.net/weixin_38145317/article/details/79650188" target="_blank" rel="noopener">SVM、SVC、SVR</a> </p>
<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><ol>
<li><p>尝试在 MNIST 数据集上建立一个分类器，使它在测试集上的精度超过 97%。提示：<code>KNeighborsClassifier</code>非常适合这个任务。你只需要找出一个好的超参数值（试一下对权重和超参数<code>n_neighbors</code>进行网格搜索）。</p>
<p>​</p>
</li>
<li><p>写一个函数可以是 MNIST 中的图像任意方向移动（上下左右）一个像素。然后，对训练集上的每张图片，复制四个移动后的副本（每个方向一个副本），把它们加到训练集当中去。最后在扩展后的训练集上训练你最好的模型，并且在测试集上测量它的精度。你应该会观察到你的模型会有更好的表现。这种人工扩大训练集的方法叫做数据增强，或者训练集扩张。</p>
<p>​</p>
</li>
<li><p>拿 Titanic 数据集去捣鼓一番。开始这个项目有一个很棒的平台：Kaggle</p>
<p>​</p>
</li>
<li><p>建立一个垃圾邮件分类器（这是一个更有挑战性的练习）：</p>
</li>
</ol>
<ul>
<li>下载垃圾邮件和非垃圾邮件的样例数据。地址是<a href="https://spamassassin.apache.org/publiccorpus/" target="_blank" rel="noopener">Apache SpamAssassin 的公共数据集</a></li>
<li>解压这些数据集，并且熟悉它的数据格式。</li>
<li>将数据集分成训练集和测试集</li>
<li>写一个数据准备的流水线，将每一封邮件转换为特征向量。你的流水线应该将一封邮件转换为一个稀疏向量，对于所有可能的词，这个向量标志哪个词出现了，哪个词没有出现。举例子，如果所有邮件只包含了<code>&quot;Hello&quot;,&quot;How&quot;,&quot;are&quot;, &quot;you&quot;</code>这四个词，那么一封邮件（内容是：<code>&quot;Hello you Hello Hello you&quot;</code>）将会被转换为向量<code>[1, 0, 0, 1]</code>(意思是：<code>&quot;Hello&quot;</code>出现，<code>&quot;How&quot;</code>不出现，<code>&quot;are&quot;</code>不出现，<code>&quot;you&quot;</code>出现)，或者<code>[3, 0, 0, 2]</code>，如果你想数出每个单词出现的次数。</li>
<li>你也许想给你的流水线增加超参数，控制是否剥过邮件头、将邮件转换为小写、去除标点符号、将所有 URL 替换成<code>&quot;URL&quot;</code>，将所有数字替换成<code>&quot;NUMBER&quot;</code>，或者甚至提取词干（比如，截断词尾。有现成的 Python 库可以做到这点）。</li>
<li>然后 尝试几个不同的分类器，看看你可否建立一个很棒的垃圾邮件分类器，同时有着高召回率和高准确率。</li>
</ul>
<h2 id="第04章-训练模型"><a href="#第04章-训练模型" class="headerlink" title="第04章 训练模型"></a>第04章 训练模型</h2><p>线性回归预测模型：</p>
<p>$\hat y = h_{\theta}(x)=\theta ^T\cdot x$</p>
<p>线性回归模型的MSE损失函数:</p>
<p>$MSE(X,h_\theta)=\frac{1}{m}\sum_{i=1}^{n}(\theta^T\cdot x^{(i)}-y^{(i)})^2$</p>
<h4 id="正态方程"><a href="#正态方程" class="headerlink" title="正态方程"></a><strong>正态方程</strong></h4><p>最小化损失函数 $\hat{\theta} =   (X^T \cdot X)^{-1} \cdot X^T \cdot y $</p>
<p>复杂度：需要计算$X^T\cdot X$ 的逆矩阵，是一个n*n的矩阵，运算复杂度大约在$O(n^{24})$ 到$O(n^{3})$之间。</p>
<p>可以numpy直接求解，也可以使用sklearn：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg = LinearRegression()</span><br><span class="line">lin_reg.fit(X, y)</span><br><span class="line">lin_reg.intercept_, lin_reg.coef_</span><br></pre></td></tr></table></figure>
<p><code>LinearRegression类基于numpy.linalg.lstsq （least squares）</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">theta_best_svd, residuals, rank, s = np.linalg.lstsq(X_b, y, rcond=<span class="number">1e-6</span>)</span><br><span class="line">theta_best_svd</span><br></pre></td></tr></table></figure>
<h5 id="pseudoinverse-Moore-Penrose-inverse"><a href="#pseudoinverse-Moore-Penrose-inverse" class="headerlink" title="pseudoinverse (Moore-Penrose inverse)"></a>pseudoinverse (Moore-Penrose inverse)</h5><p>该函数求解的是伪逆矩阵（pseudoinverse），即广义矩阵。其中最著名的伪逆矩阵为摩尔－彭若斯广义逆 A+（Moore–Penrose pseudoinverse)，常应用于求非一致线性方程组的最小范数最小二乘解（最小二乘法），并使得解的形式变得简单。矩阵的摩尔－彭若斯广义逆在实数域和复数域上都是唯一的，并且可以通过奇异值分解求得。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.linalg.pinv(X_b).dot(y)</span><br></pre></td></tr></table></figure>
<p>满足摩尔-彭若斯条件的矩阵G称为矩阵A的摩尔－彭若斯广义逆矩阵，记作A+：</p>
<p><img src="https://img-blog.csdn.net/20170824103329707?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="条件"></p>
<p>从摩尔－彭若斯条件出发，彭若斯推导出了摩尔－彭若斯广义逆的一些性质：<br><img src="https://img-blog.csdn.net/20170824103423352?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemVhbGZvcnk=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="img"></p>
<p> 参考：<a href="https://blog.csdn.net/zealfory/article/details/77526815" target="_blank" rel="noopener">https://blog.csdn.net/zealfory/article/details/77526815</a></p>
<h4 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h4><p>超参数学习率的值决定了步长的大小。如果学习率太小，必须经过多次迭代，算法才能收敛，这是非常耗时的，如果学习率太大，你可能使算法发散，函数值变得越来越大，永远不可能找到一个好的答案。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-4.PNG" alt="学习率过小"></p>
<center>学习率过小</center>

<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-5.PNG" alt="img"></p>
<center>学习率过大</center>

<p><strong>两个主要挑战</strong></p>
<ol>
<li>收敛到局部最小值</li>
</ol>
<p>当使用梯度下降的时候，应该确保所有的特征有着相近的尺度范围（例如：使用 Scikit Learn 的 <code>StandardScaler</code>类），否则它将需要很长的时间才能够收敛。</p>
<h4 id="batch-GD"><a href="#batch-GD" class="headerlink" title="batch-GD"></a>batch-GD</h4><p>使用梯度下降的过程中，需要计算每一个 $\theta_j$ 下损失函数的梯度，即计算关于$\theta_j$ 的损失函数的偏导数，记为： </p>
<script type="math/tex; mode=display">\frac{\partial}{\partial \theta_j} MSE(\theta)=\frac{2}{m}\sum_{i=1}^{m}({\theta^T\cdot x^{(i)}-y^{(i)})x_j^{}(i)}</script><p>写成矩阵的形式：</p>
<script type="math/tex; mode=display">\nabla_\theta MSE(\theta)=\left( \begin{array}{c} \frac{\partial}{\partial \theta_0} MSE(\theta)\\\frac{\partial}{\partial \theta_1} MSE(\theta)\\...\\\frac{\partial}{\partial \theta_n} MSE(\theta) \end{array} \right)=\frac {2}{m} X^T\cdot (X\cdot \theta-y)</script><blockquote>
<p>在这个方程中每一步计算时都包含了整个训练集$X$，这也是为什么这个算法称为<strong>批量梯度下降</strong>：每一次训练过程都使用所有的的训练数据。因此，在大数据集上，其会变得相当的慢。然而，梯度下降的运算规模和特征的数量成正比。训练一个数千数量特征的线性回归模型使用梯度下降要比使用正态方程快的多。</p>
</blockquote>
<p>梯度下降的步长：</p>
<script type="math/tex; mode=display">\theta^{(next step)}=\theta-\eta\nabla_\theta MSE(\theta)</script><p>$\eta$ 为学习率</p>
<p>为了找到一个好的学习率，可以使用网格搜索，设置一个<strong>迭代次数</strong>。设置一个非常大的迭代次数，但是当梯度向量变得非常小（容差 $\epsilon$ ）的时候，结束迭代。</p>
<blockquote>
<p>收敛速率：</p>
<p>当损失函数是凸函数，且斜率不能突变（就像均方差损失函数那样），则它的批量梯度下降算法固定学习率之后，收敛速率是 $O(\frac{1}{iterations})$。换句话说，如果将容差 $\epsilon$ 缩小 10 倍（这样可以得到一个更精确的结果），算法的迭代次数大约会变成原来的 10 倍。</p>
</blockquote>
<h4 id="stochastic-gradient-descent"><a href="#stochastic-gradient-descent" class="headerlink" title="stochastic gradient descent"></a>stochastic gradient descent</h4><p>批量梯度下降的最要问题是计算每一步的梯度时都需要使用整个训练集，这导致在规模较大的数据集上，其会变得非常的慢。</p>
<p>而随机梯度下降，每一步的梯度计算只随机选取训练集中的一个样本。由于每一次迭代，只需要在内存中有一个实例，算法非常快，这使随机梯度算法可以在大规模训练集上使用。</p>
<p>另一方面，由于其随机性，SGD呈现出更多的不规律性：到达最小值不是平缓的下降，损失函数会忽高忽低，只在大体上呈下降趋势。随着时间的推移，非常的靠近最小值，但不会停止在一个值上，而是一直在这个值附近摆动。因此，算法停止时，最后的参数不是最优值。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-9.PNG" alt="img"></p>
<p>当损失函数很不规则时，随机梯度下降算法能够跳过局部最小值。因此，随机梯度下降在寻找全局最小值上比批量梯度下降表现要好。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-6.PNG" alt="img"></p>
<p>虽然随机性可以很好的跳过局部最优值，但同时它却不能达到最小值。解决这个难题的一个办法是<strong>逐渐降低学习率</strong>。</p>
<p>开始时，走的每一步较大（有助于快速前进同时跳过局部最小值），然后变得越来越小，从而使算法到达全局最小值。，这个过程被称为<strong>模拟退火</strong>。</p>
<p>决定每次迭代的学习率的函数称为<code>learning schedule</code>。 如果学习速度降低得过快，可能会陷入局部最小值，甚至在到达最小值的半路就停止了。 如果学习速度降低得太慢，可能在最小值的附近长时间摆动，同时如果过早停止训练，最终只会出现次优解。</p>
<h4 id="mini-batch-GD"><a href="#mini-batch-GD" class="headerlink" title="mini-batch GD"></a>mini-batch GD</h4><p>在迭代的每一步，小批量梯度下降使用一个随机的小型实例集。与随机梯度相比主要优点在于可以通过矩阵运算的硬件优化得到一个较好的训练表现。</p>
<p>小批量梯度下降在参数空间上的表现比随机梯度下降要好的多，尤其在有大量的小型实例集时。作为结果，小批量梯度下降会比随机梯度更靠近最小值。但是，另一方面，它有可能陷在局部最小值中（在遇到局部最小值问题的情况下，和我们之前看到的线性回归不一样）。 </p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-11.PNG" alt="img"></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E8%A1%A84-1.PNG" alt="img"></p>
<h4 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h4><p>对每个特征进行加权后作为新的特征，然后训练一个线性模型在这个扩展的特征集。 这种方法称为多项式回归。</p>
<p><code>from sklearn.preprocessing import PolynomialFeatures</code></p>
<p>当存在多个特征时，多项式回归能够找出特征之间的关系（这是普通线性回归模型无法做到的）。 这是因为<code>LinearRegression</code>会自动添加当前阶数下特征的所有组合。例如，如果有两个特征 $a,b$，使用 3 阶（<code>degree=3</code>）的<code>LinearRegression</code>时，不仅有 $a^3, a^2, b^3, b^2$，同时也会有它们的其他组合项 $ab, ab^2, a^2b$</p>
<p><code>PolynomialFeatures(degree=d)</code>把一个包含$n$个特征的数组转换为一个包含 $\frac{(n+d)!}{d!n!}$特征的数组。小心大量特征的组合爆炸！</p>
<h4 id="学习曲线"><a href="#学习曲线" class="headerlink" title="学习曲线"></a>学习曲线</h4><p><strong>如何估计一个模型的泛化能力</strong> </p>
<ol>
<li>使用交叉验证。若模型在训练集上表现良好，通过交叉验证指标却得出其泛化能力很差，模型过拟合。如果在这两方面都表现不好，那么欠拟合。这种方法可以告诉我们模型是太复杂还是太简单了。</li>
<li>观察学习曲线：画出模型在训练集上的表现，同时画出以训练集规模为自变量的训练集函数。为了得到图像，需要在训练集的不同规模子集上进行多次训练。</li>
</ol>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-15.PNG" alt="img"></p>
<center>欠拟合</center>

<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-16.PNG" alt="img"></p>
<center>过拟合</center>

<blockquote>
<p>偏差和方差的权衡</p>
<p>在统计和机器学习领域有个重要的理论：一个模型的<strong>泛化误差</strong>由三个不同误差的和决定：</p>
<ul>
<li>偏差：泛化误差的这部分误差是由于错误的假设决定的。例如实际是一个二次模型，你却假设了一个线性模型。一个高偏差的模型最容易出现欠拟合。</li>
<li>方差：这部分误差是由于模型对训练数据的微小变化较为敏感，一个多自由度的模型更容易有高的方差（例如一个高阶多项式模型），因此会导致模型过拟合。</li>
<li>不可约误差：这部分误差是由于数据本身的噪声决定的。降低这部分误差的唯一方法就是进行数据清洗（例如：修复数据源，修复坏的传感器，识别和剔除异常值）。</li>
</ul>
</blockquote>
<h4 id="线性模型的正则化"><a href="#线性模型的正则化" class="headerlink" title="线性模型的正则化"></a>线性模型的正则化</h4><p>正则化这个模型（即限制它）：模型有越少的自由度，就越难以拟合数据。例如，正则化一个多项式模型，一个简单的方法就是减少多项式的阶数。</p>
<p>对于一个线性模型，正则化的典型实现就是约束模型中参数的权重。</p>
<h5 id="岭回归（Ridge）"><a href="#岭回归（Ridge）" class="headerlink" title="岭回归（Ridge）"></a>岭回归（Ridge）</h5><p>岭回归（也称为 Tikhonov 正则化）是线性回归的正则化版：在损失函数上直接加上一个正则项。这使得学习算法不仅能够拟合数据，而且能够使模型的参数权重尽量的小。注意到这个正则项只有在训练过程中才会被加到损失函数。当得到完成训练的模型后，我们应该使用没有正则化的测量方法去评价模型的表现。</p>
<blockquote>
<p>提示</p>
<p>一般情况下，训练过程使用的损失函数和测试过程使用的评价函数是不一样的。除了正则化，还有一个不同：训练时的损失函数应该在优化过程中易于求导，而在测试过程中，评价函数更应该接近最后的客观表现。一个好的例子：在分类训练中我们使用对数损失（马上我们会讨论它）作为损失函数，但是我们却使用精确率/召回率来作为它的评价函数。</p>
</blockquote>
<p>岭回归损失函数：</p>
<p>$J(\theta)=MSE(\theta)+\alpha \frac{1}{2} \sum_{i=1}^{n}{\theta _i ^2}$</p>
<p>$\theta_0$是没有被正则化的，所以累加从i=1开始，而不是i=0开始。如果定义w作为特征的权重向量（$\theta_1$到$\theta_n$），则正则项可以简写成$\frac{1}{2}(||w||_2)^2$ ，$||\cdot||_2$表示$l_2$范数。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-17.PNG" alt="img"></p>
<h6 id="封闭方程的解"><a href="#封闭方程的解" class="headerlink" title="封闭方程的解"></a>封闭方程的解</h6><script type="math/tex; mode=display">\hat \theta=(X^T\cdot X+\alpha A)^{-1}\cdot X^T\cdot y</script><p>A是一个除了左上角有一个0的nxn的单位矩阵，表示偏差$\theta_0​$不被正则化。</p>
<h6 id="随机梯度下降法求解"><a href="#随机梯度下降法求解" class="headerlink" title="随机梯度下降法求解"></a>随机梯度下降法求解</h6><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sgd_reg = SGDRegressor(penalty=<span class="string">"l2"</span>)</span><br><span class="line"><span class="comment"># penalty参数指的是正则项的惩罚类型。指定“l2”表明你要在损失函数上添加一项：权重向量 l2 范数平方的一半，这就是简单的岭回归。</span></span><br></pre></td></tr></table></figure>
<h5 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h5><p>Lasso 回归（也称 Least Absolute Shrinkage，或者 Selection Operator Regression）是另一种正则化版的线性回归：就像岭回归那样，它也在损失函数上添加了一个正则化项，但是它使用权重向量的$l_1$ 范数而不是权重向量 $l_2$范数平方的一半。</p>
<p>$J(\theta)=MSE(\theta)+\alpha \sum_{i=1}^{n}{|\theta _i|}$</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-18.PNG" alt="img"></p>
<p>Lasso 回归的一个重要特征是它倾向于完全消除最不重要的特征的权重（即将它们设置为零）。例如，右图中的虚线所示$\alpha=10^{-7}$，曲线看起来像一条二次曲线，而且几乎是线性的，这是因为所有的高阶多项特征都被设置为零。换句话说，Lasso回归自动的进行特征选择同时输出一个稀疏模型（即，具有很少的非零权重）。</p>
<p>Lasso 回归子梯度向量:</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-93eea6b5c197bbc8d7be8b4c14e9f8f3.gif" alt="g(\theta,J)=\nabla_{\theta}MSE(\theta)+ \alpha{\left(\begin{matrix} sign(\theta_1)\\ sign(\theta_2)\\ \vdots \\ sign(\theta_n)\\ \end{matrix}\right)}\ where\ sign(\theta_i)= \begin{cases} -1, &amp;\theta_i&lt;0 \\ 0, &amp;\theta_i=0 \\ +1,&amp;\theta_i&gt;0 \\ \end{cases}"></p>
<h5 id="弹性网络（ElasticNet）"><a href="#弹性网络（ElasticNet）" class="headerlink" title="弹性网络（ElasticNet）"></a>弹性网络（ElasticNet）</h5><p>弹性网络介于 Ridge 回归和 Lasso 回归之间。它的正则项是 Ridge 回归和 Lasso 回归正则项的简单混合，同时你可以控制它们的混合率 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-4b43b0aee35624cd95b910189b3dc231.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-4b43b0aee35624cd95b910189b3dc231.gif" alt="r"></a></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-e4da079f692fe35778bbdf1fdf120d99.gif" alt="J(\theta)=MSE(\theta)+r\alpha\sum\limits_{i=1}n\left|\theta_i \right|+\frac{1-r}{2}\alpha\sum\limits_{i=1}n\theta_i^2"></p>
<h5 id="早起停止法（Early-Stopping）"><a href="#早起停止法（Early-Stopping）" class="headerlink" title="早起停止法（Early Stopping）"></a>早起停止法（Early Stopping）</h5><p>对于迭代学习算法，有一种非常特殊的正则化方法，就像梯度下降在验证错误达到最小值时立即停止训练那样。我们称为早期停止法。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-20.PNG" alt="img"></p>
<h5 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h5><blockquote>
<p>一些回归算法也可以用于分类（反之亦然）。 Logistic 回归（也称为 Logit 回归）通常用于估计一个实例属于某个特定类别的概率。 若估计的概率大于 50%，则模型预测这个实例属于当前类（称为正类，标记为“1”），反之预测它不属于当前类（即属于负类 ，标记为“0”）。 这样便成为了一个二元分类器。</p>
</blockquote>
<p>逻辑回归模型的概率估计：</p>
<p>$\hat p=h_\theta=\sigma(\theta^T\cdot x)$</p>
<p>其中$\sigma()$是Logistic函数，是一个sigmoid函数，输出是介于0到1之间的数字。</p>
<p>逻辑函数：</p>
<p>$\sigma(t)=\frac{1}{1+\exp(-t)}$</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-21.PNG" alt="img"></p>
<p>逻辑回归预测模型：</p>
<p>$\hat y = \left\{ \begin{array}{cl} 0,&amp; \hat p &lt; 0.5 \\ 1,&amp; \hat p \geq 0.5 \end{array} \right.$</p>
<h6 id="训练和损失函数"><a href="#训练和损失函数" class="headerlink" title="训练和损失函数"></a>训练和损失函数</h6><p>单个样本的损失函数：</p>
<p>$c(\theta)=\left \{ \begin{array}{lc} -\log(\hat p), &amp;y=1 \\ -\log(1-\hat p),&amp; y=0 \end{array}\right.$</p>
<p>整个训练集的损失函数只是所有训练实例的平均值。</p>
<p>逻辑回归的损失函数：<br>$J (\theta) = -\frac{1}{m} \sum_{i=1}^{m}[y^{(i)}log(\hat p^{(i)})+(1-y^{(i)})log(1-\hat p^{(i)})]$</p>
<p>但是这个损失函数对于求解最小化损失函数的$\theta是没有公式解的（没有等价的正态方程），但该损失函数是凸的，所以梯度下降（或任何其他优化算法）一定能够找到全局最小值。</p>
<p>逻辑回归损失函数的偏导数：</p>
<script type="math/tex; mode=display">\frac{\partial}{\partial \theta_j}J(\theta_J)=\frac{1}{m}\sum_{i=1}^{m}(\sigma({\theta^T\cdot x^{(i)})-y^{(i)})x_j^{}(i)}</script><h6 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h6><p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_4/%E5%9B%BE4-23.PNG" alt="img"></p>
<p>概率=0.5的分界线</p>
<p>逻辑回归模型也可以 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-8524eb1789cf2093cfccc4c297138c7f.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-8524eb1789cf2093cfccc4c297138c7f.gif" alt="\ell_1"></a> 或者 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-f2d02eaf32cb7a351989198531c0d12a.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-f2d02eaf32cb7a351989198531c0d12a.gif" alt="\ell_2"></a> 惩罚使用进行正则化。Scikit-Learn 默认添加了 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-f2d02eaf32cb7a351989198531c0d12a.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-f2d02eaf32cb7a351989198531c0d12a.gif" alt="\ell_2"></a> 惩罚。</p>
<h5 id="Softmax回归"><a href="#Softmax回归" class="headerlink" title="Softmax回归"></a>Softmax回归</h5><p>Logistic 回归模型可以直接推广到支持多类别分类，不必组合和训练多个二分类器， 其称为 Softmax 回归或多类别 Logistic 回归。</p>
<p>当给定一个实例 $x$ 时，Softmax 回归模型首先计算 $k$ 类的分数，然$s_k(x)$ 后将分数应用在<code>Softmax</code>函数（也称为归一化指数）上，估计出每类的概率。</p>
<p>k类的Softmax得分：</p>
<p>$s_k(x)=\theta^T\cdot x$</p>
<blockquote>
<p>每个类都有自己独一无二的参数向量 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9f888eddb683fe5f80f87f44bd727b08.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9f888eddb683fe5f80f87f44bd727b08.gif" alt="\theta_k"></a>。 所有这些向量通常作为行放在参数矩阵 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-b9dce96eb3d5a71b28f9f198c28d2d1b.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-b9dce96eb3d5a71b28f9f198c28d2d1b.gif" alt="\Theta"></a> 中。</p>
</blockquote>
<p>Softmax函数：</p>
<script type="math/tex; mode=display">
\hat p_k=\sigma(s(x))_k=\frac{\exp(s_k(x))}{\sum_{j=1}^{K}{\exp(s_j(x))}}</script><p>$K$ 表示类的总数</p>
<p>Softmax 回归模型分类器预测结果:</p>
<p>$\hat y=argmax\  \sigma(s(x))_k=argmax\ s_k(x) = argmax \ (\theta_k^T\cdot x)$</p>
<blockquote>
<p>Softmax 回归分类器一次只能预测一个类（即它是多类的，但不是多输出的），因此它只能用于判断互斥的类别，如不同类型的植物。 不能用它来识别一张照片中的多个人。</p>
</blockquote>
<h6 id="训练和损失函数-1"><a href="#训练和损失函数-1" class="headerlink" title="训练和损失函数"></a>训练和损失函数</h6><p>目标是建立一个模型在目标类别上有着较高的概率（因此其他类别的概率较低）</p>
<p>交叉熵:</p>
<script type="math/tex; mode=display">
J (\theta) = -\frac{1}{m} \sum_{i=1}^{m}\sum_{k=1}^{K}y^{(i)}_klog(\hat p^{(i)}_k)</script><blockquote>
<p>交叉熵源于信息论。</p>
<p>假设你想要高效地传输每天的天气信息。如果有八个选项（晴天，雨天等），则可以使用3位对每个选项进行编码，因为 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-5f344a952e29992de54b8cfe645b2d5b.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-5f344a952e29992de54b8cfe645b2d5b.gif" alt="2^3=8"></a>。但是，如果你认为几乎每天都是晴天，更高效的编码“晴天”的方式是：只用一位（0）。剩下的七项使用四位（从 1 开始）。交叉熵度量每个选项实际发送的平均比特数。 如果你对天气的假设是完美的，交叉熵就等于天气本身的熵（即其内部的不确定性）。 但是，如果你的假设是错误的（例如，如果经常下雨）交叉熵将会更大，称为 Kullback-Leibler 散度（KL 散度）。</p>
<p>两个概率分布 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-83878c91171338902e0fe0fb97a8c47a.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-83878c91171338902e0fe0fb97a8c47a.gif" alt="p"></a> 和 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7694f4a66316e53c8cdd9d9954bd611d.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7694f4a66316e53c8cdd9d9954bd611d.gif" alt="q"></a> 之间的交叉熵定义为：<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-6bc68f603b52e51645b4bbd318f8cdfe.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-6bc68f603b52e51645b4bbd318f8cdfe.gif" alt="H(p,q)=-\sum_xp(x)\log q(x)"></a>（分布至少是离散的）</p>
</blockquote>
<p>$k$ 类交叉熵的梯度向量:</p>
<p>$\nabla_{\theta_k} J (\Theta) = -\frac{1}{m} \sum_{i=1}^{m}(p^{(i)}_k - y^{(i)}_k )x^{(i)})$</p>
<h4 id="Exercise"><a href="#Exercise" class="headerlink" title="Exercise"></a>Exercise</h4><ol>
<li><p>如果你有一个数百万特征的训练集，你应该选择哪种线性回归训练算法？</p>
<blockquote>
<p>mini-batch GD或者SGD</p>
</blockquote>
</li>
<li><p>假设你训练集中特征的数值尺度（scale）有着非常大的差异，哪种算法会受到影响？有多大的影响？对于这些影响你可以做什么？</p>
<blockquote>
<p>如果训练集的特征尺度差距太大，损失函数的等高线会呈椭圆状，利用梯度下降来求最优解的过程中会很难收敛，梯度方向变化很剧烈，收敛速度很慢，并且可能不会收敛到最优点。</p>
<p>对数据进行缩放（StandardScaler），归一化</p>
</blockquote>
</li>
<li><p>训练 Logistic 回归模型时，梯度下降是否会陷入局部最低点？</p>
<blockquote>
<p>不会，其损失函数是一个凸函数。</p>
</blockquote>
</li>
<li><p>在有足够的训练时间下，是否所有的梯度下降都会得到相同的模型参数？</p>
<blockquote>
<p>不是，SGD因为随机性，达到损失函数只会呈现大体下降趋势，随着时间的推移，会非常靠近最小值，但只会在附近摆动。</p>
<p>mini-batch GD也会有一定的摆动。</p>
</blockquote>
</li>
<li><p>假设你使用批量梯度下降法，画出每一代的验证误差。当你发现验证误差一直增大，接下来会发生什么？你怎么解决这个问题？</p>
<blockquote>
<p>模型发散，难以收敛。减小学习率</p>
<p>或者模型过拟合，需要早停</p>
</blockquote>
</li>
<li><p>当验证误差升高时，立即停止小批量梯度下降是否是一个好主意？</p>
<blockquote>
<p>不是，因为mini-batch的损失函数随时间大体下降，但会有一定波动。</p>
<p>更好的选择是定期保存模型，如果经过很长一段时间仍然没有改进的话，可以恢复到保存的最好模型。</p>
</blockquote>
</li>
<li><p>哪个梯度下降算法（在我们讨论的那些算法中）可以最快到达解的附近？哪个的确实会收敛？怎么使其他算法也收敛？</p>
<blockquote>
<p>SGD最快</p>
<p>梯度下降法</p>
<p>逐步减小学习率</p>
</blockquote>
</li>
<li><p>假设你使用多项式回归，画出学习曲线，在图上发现学习误差和验证误差之间有着很大的间隙。这表示发生了什么？有哪三种方法可以解决这个问题？</p>
<blockquote>
<p>如果学习误差比验证误差小很多，说明发生了过拟合。</p>
<p>可以通过正则化（岭回归，Lasso回归和弹性网络）这个模型降低过拟合程度。</p>
<p>也可以提供更多的训练数据。</p>
<p>或者改变模型。</p>
</blockquote>
</li>
<li><p>假设你使用岭回归，并发现训练误差和验证误差都很高，并且几乎相等。你的模型表现是高偏差还是高方差？这时你应该增大正则化参数 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7b7f9dbfea05c83784f8b85149852f08.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7b7f9dbfea05c83784f8b85149852f08.gif" alt="\alpha"></a>，还是降低它？</p>
<blockquote>
<p>高偏差，应该减小$\alpha$。</p>
</blockquote>
</li>
<li><p>你为什么要这样做：</p>
</li>
</ol>
<ul>
<li><p>使用岭回归代替线性回归？</p>
<blockquote>
<p>模型有正则化的时候会比没有正则化的时候又更好的泛化性能，岭回归就是对模型的参数做了正则化，约束其幅值变化不能太大，否则会容易出现过拟合。</p>
</blockquote>
</li>
<li><p>Lasso 回归代替岭回归？</p>
<blockquote>
<p>当特征仅有少数是真正有用的时候，对重要的特征进行选择，将无用特征的权重降为零，增加模型的可解释性。</p>
</blockquote>
</li>
<li><p>弹性网络代替 Lasso 回归？</p>
<blockquote>
<p>当特征数量比样本的数量大的时候，或者特征之间有很强的相关性时，Lasso 可能会表现的不规律。</p>
</blockquote>
</li>
</ul>
<ol>
<li><p>假设你想判断一副图片是室内还是室外，白天还是晚上。你应该选择二个逻辑回归分类器，还是一个 Softmax 分类器？</p>
<blockquote>
<p>两个逻辑回归分类器</p>
</blockquote>
</li>
<li><p>在 Softmax 回归上应用批量梯度下降的早期停止法（不使用 Scikit-Learn）。</p>
<blockquote>
<p>​</p>
</blockquote>
</li>
</ol>
<hr>
<h2 id="第05章-支持向量机"><a href="#第05章-支持向量机" class="headerlink" title="第05章 支持向量机"></a>第05章 支持向量机</h2><p>能够做线性或者非线性的分类，回归，甚至异常值检测。SVM 特别适合应用于复杂但中小规模数据集的分类问题。</p>
<h4 id="线性支持向量机分类"><a href="#线性支持向量机分类" class="headerlink" title="线性支持向量机分类"></a>线性支持向量机分类</h4><p>SVM 分类器的判定边界实线，不仅分开了两种类别，而且还尽可能地远离了最靠近的训练数据点。（最大间隔分类）</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/5-1.jpg" alt="img"></p>
<p>判定边界是由位于“街道”边缘的样本点确定的，这些样本点被称为“支持向量”</p>
<h5 id="软间隔分类"><a href="#软间隔分类" class="headerlink" title="软间隔分类"></a>软间隔分类</h5><p>硬间隔分类有两个问题，</p>
<ol>
<li>只对线性可分的数据起作用.</li>
<li>对异常点敏感。</li>
</ol>
<p>在 Scikit-Learn 库的 SVM 类，可以用<code>C</code>超参数（惩罚系数）来控制这种平衡：较小的<code>C</code>会导致更宽的“街道”，但更多的间隔违规。</p>
<blockquote>
<p>SVM 模型过拟合，可以尝试通过减小超参数<code>C</code>去调整</p>
</blockquote>
<h4 id="非线性支持向量机分类"><a href="#非线性支持向量机分类" class="headerlink" title="非线性支持向量机分类"></a>非线性支持向量机分类</h4><h5 id="增加更多的特征"><a href="#增加更多的特征" class="headerlink" title="增加更多的特征"></a>增加更多的特征</h5><p>通过 Scikit-Learn，可以创建一个流水线（Pipeline）去包含多项式特征（PolynomialFeatures）变换，然后StandardScaler.</p>
<h5 id="多项式核"><a href="#多项式核" class="headerlink" title="多项式核"></a>多项式核</h5><p>添加多项式特征会：大量特征导致的组合爆炸</p>
<h5 id="增加相似特征"><a href="#增加相似特征" class="headerlink" title="增加相似特征"></a>增加相似特征</h5><p>使用相似函数（similarity funtion）计算每个样本与特定地标（landmark）的相似度。</p>
<p>定义一个相似函数，即<strong>高斯径向基函数（Gaussian Radial Basis Function，RBF）</strong>，设置<code>γ = 0.3</code></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-8b908429a5b5ee2e519f8caa16f82ee1.gif" alt="\phi_{\gamma}(x, \ell) = exp(-\gamma \|x - \ell \|^2)"></p>
<p>是个从 0 到 1 的钟型函数。</p>
<h5 id="高斯-RBF-核"><a href="#高斯-RBF-核" class="headerlink" title="高斯 RBF 核"></a>高斯 RBF 核</h5><p>相似特征法在所有额外特征上的计算成本可能很高，特别是在大规模的训练集上。</p>
<h5 id="计算复杂性"><a href="#计算复杂性" class="headerlink" title="计算复杂性"></a>计算复杂性</h5><p><code>LinearSVC</code>类基于<code>liblinear</code>库，它实现了线性 SVM 的优化算法。它并不支持核技巧，但是它样本和特征的数量几乎是线性的：训练时间复杂度大约为<code>O(m × n)</code>。</p>
<p>SVC 类基于<code>libsvm</code>库，它实现了支持核技巧的算法。训练时间复杂度通常介<code>于O(m^2 × n)</code>和<code>O(m^3 × n)</code>之间。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/tb-5-1.jpg" alt="img"></p>
<h4 id="SVM回归"><a href="#SVM回归" class="headerlink" title="SVM回归"></a>SVM回归</h4><p>SVM 回归任务是限制间隔违规情况下，尽量放置更多的样本在“街道”上。“街道”的宽度由超参数<code>ϵ</code>控制。</p>
<p>可以使用 Scikit-Learn 的<code>LinearSVR</code>类去实现线性 SVM 回归。</p>
<p>处理非线性回归任务，可以使用核化的 SVM 模型。</p>
<blockquote>
<p>LinearSVR没有support_属性</p>
</blockquote>
<h4 id="背后机制"><a href="#背后机制" class="headerlink" title="背后机制"></a>背后机制</h4><p>首先，关于符号的约定：在第 4 章，我们将所有模型参数放在一个矢量<code>θ</code>里，包括偏置项<code>θ0</code>，<code>θ1</code>到<code>θn</code>的输入特征权重，和增加一个偏差输入<code>x0 = 1</code>到所有样本。</p>
<p>在本章中，我们将使用一个不同的符号约定，在处理 SVM 上，这更方便，也更常见：<strong>偏置项被命名为b，特征权重向量被称为w</strong>，在输入特征向量中不再添加偏置特征。</p>
<h5 id="决策函数和预测"><a href="#决策函数和预测" class="headerlink" title="决策函数和预测"></a>决策函数和预测</h5><p>线性 SVM 分类器通过简单地计算决策函数 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7781983bd977537b3c5d060e217ea82a.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-7781983bd977537b3c5d060e217ea82a.gif" alt="w \cdot x+b = w_1 x_1 + ... + w_n x_n + b"></a> 来预测新样本的类别：如果结果是正的，预测类别<code>ŷ</code>是正类，为 1，否则他就是负类，为 0。</p>
<p>$\hat y = \left \{ \begin{array}{ll}  0 &amp; if \ w^T\cdot x+b&lt;0 \\1 &amp; \ w^T\cdot x+b\geq0\end{array}\right.$</p>
<p>训练线性 SVM 分类器意味着找到<code>w</code>值和<code>b</code>值使得这一个间隔尽可能大，同时避免间隔违规（硬间隔）或限制它们（软间隔）</p>
<h5 id="训练目标"><a href="#训练目标" class="headerlink" title="训练目标"></a>训练目标</h5><p>决策函数的斜率：它等于权重向量的范数 $||\omega||$ ，斜率除于 2，那么间隔将增加两倍。权重向量<code>w</code>越小，间隔越大。</p>
<p>目标是最小化$||\omega||$ ，从而获得大的间隔。如果想要避免间隔违规（硬间隔），对于正的训练样本，需要决策函数大于 1，对于负训练样本，小于 -1。即：$t^{(i)}\ w^T\cdot x^{(i)}+b\geq1$</p>
<p><strong>可以将硬间隔线性 SVM 分类器表示为约束优化问题:</strong></p>
<script type="math/tex; mode=display">
minimize \frac{1}{2} \omega^T\cdot \omega \\
subject \  to\  t^{(i)}\ w^T\cdot x^{(i)}+b\geq1 \ \ \ for \ i=1,2,3,\cdots , m</script><blockquote>
<p><a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9a84ebda628c391e3046dfc2307e3c85.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9a84ebda628c391e3046dfc2307e3c85.gif" alt="1/2 w^T w"></a> 等于 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-98c822c91ab5af02c383eb03fa5b5446.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-98c822c91ab5af02c383eb03fa5b5446.gif" alt="1/2 \|w\|^2"></a>，最小化 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9a84ebda628c391e3046dfc2307e3c85.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-9a84ebda628c391e3046dfc2307e3c85.gif" alt="1/2 w^T w"></a>，而不是最小化 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-03549015bd48d379883d926e6857b448.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-03549015bd48d379883d926e6857b448.gif" alt="\|w\|"></a>。因为<a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-03549015bd48d379883d926e6857b448.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-03549015bd48d379883d926e6857b448.gif" alt="\|w\|"></a> 在<code>w=0</code>处是不可微的。优化算法在可微函数表现得更好。</p>
</blockquote>
<p>软间隔：</p>
<p>对每个样本应用一个松弛变量（slack variable）$\zeta^{(i)}\geq0$ 。$\zeta^{(i)}$表示了第<code>i</code>个样本允许违规间隔的程度。</p>
<p>现在有两个不一致的目标：</p>
<ol>
<li>使松弛变量尽可能的小，从而减小间隔违规.</li>
<li>使<code>1/2 w·w</code>尽量小，从而增大间隔。</li>
</ol>
<p>这时<code>C</code>超参数发挥作用：它允许我们在两个目标之间权衡。</p>
<script type="math/tex; mode=display">
minimize\  \frac{1}{2} \omega^T\cdot \omega +C\sum_{i=1}^{m}\zeta^{(i)}\\

subject \  to\  t^{(i)}\ w^T\cdot x^{(i)}+b\geq1-\zeta^{(i)}\ \  and \ \ \zeta^{(i)} \geq0 \ \  for \ i=1,2,3,\cdots , m</script><h5 id="二次间隔"><a href="#二次间隔" class="headerlink" title="二次间隔"></a>二次间隔</h5><p>硬间隔和软间隔都是<strong>线性约束的凸二次规划优化问题</strong>。这些问题被称之为二次规划（QP）问题。</p>
<h5 id="对偶问题"><a href="#对偶问题" class="headerlink" title="对偶问题"></a>对偶问题</h5><p>给出一个约束优化问题，即原始问题（primal problem），它可能表示不同但是和另一个问题紧密相连，称为对偶问题（Dual Problem）。对偶问题的解通常是对原始问题的解给出一个下界约束，但在某些条件下，它们可以获得相同解。</p>
<p><strong>线性 SVM 的对偶形式（核技巧的基本）</strong>：</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-6.gif" alt="img"></p>
<p>一旦找到最小化公式的向量<code>α</code>，可以计算<code>w</code>和<code>b</code>，从而使原始问题最小化。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-7.gif" alt="img"></p>
<p>训练样本的数量比特征数量小的时候，对偶问题比原始问题要快得多。</p>
<h5 id="核化支持向量机"><a href="#核化支持向量机" class="headerlink" title="核化支持向量机"></a>核化支持向量机</h5><p>把一个 2 次多项式变换应用到二维空间的训练集，然后在变换后的训练集上训练一个线性SVM分类器。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-8.gif" alt="img"></p>
<p>转换后向量的点积等于原始向量点积的平方:</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-9.gif" alt="img"></p>
<p><strong>核技巧的精髓:</strong></p>
<p>不需要对训练样本进行转换：仅仅需要在对偶问题公式中，将点积替换成它点积的平方。</p>
<p>函数$K(a, b) = (a^T b)^2$ 被称为二次多项式核（polynomial kernel）。在机器学习，核函数是一个能计算点积的函数，并只基于原始向量<code>a</code>和<code>b</code>，不需要计算（甚至知道）转换<code>ϕ</code>。</p>
<p><strong>一些常见的核函数</strong></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-10.gif" alt="img"></p>
<blockquote>
<p>Mercer 定理</p>
<p>根据 Mercer 定理，如果函数<code>K(a, b)</code>满足一些 Mercer 条件的数学条件(<code>K</code>函数在参数内必须是连续，对称，即<code>K(a, b)=K(b, a)</code>，等)，那么存在函数<code>ϕ</code>，将<code>a</code>和<code>b</code>映射到另一个空间（可能有更高的维度），有 $K(a, b) = \phi(a)^T ϕ(b)$。所以可以用<code>K</code>作为核函数，即使不知道<code>ϕ</code>。使用高斯核（Gaussian RBF kernel）情况下，它实际是将每个训练样本映射到无限维空间，所以不需要知道是怎么执行映射的也是一件好事。</p>
<p>注意一些常用核函数（例如 Sigmoid 核函数）并不满足所有的 Mercer 条件，然而在实践中通常表现得很好。</p>
</blockquote>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-11.gif" alt="img"></p>
<p>也需要使用同样的技巧来计算偏置项<code>b</code></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-12.gif" alt="img"></p>
<p>支持向量才满足<code>α(i)≠0</code>，做出预测只涉及计算为支持向量部分的输入样本 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-992fd41f053d328db0ca0287eed0e2e9.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-992fd41f053d328db0ca0287eed0e2e9.gif" alt="x^{(n)}"></a> 的点积，而不是全部的训练样本。</p>
<h5 id="在线支持向量机"><a href="#在线支持向量机" class="headerlink" title="在线支持向量机"></a>在线支持向量机</h5><p>线学习意味着增量地学习，不断有新实例。</p>
<p>于线性SVM分类器，一种方式是使用梯度下降（例如使用<code>SGDClassifire</code>）最小化代价函数：</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-13.gif" alt="img"></p>
<p>第一个和会使模型有一个小的权重向量<code>w</code>，从而获得一个更大的间隔。第二个和计算所有间隔违规的总数。如果样本位于“街道”上和正确的一边，或它与“街道”正确一边的距离成比例，则间隔违规等于 0。最小化保证了模型的间隔违规尽可能小并且少。</p>
<blockquote>
<p>Hinge 损失</p>
<p>函数<code>max(0, 1–t)</code>被称为 Hinge 损失函数（如下）。当<code>t≥1</code>时，Hinge 值为 0。如果<code>t&lt;1</code>,它的导数（斜率）为 -1，若<code>t&gt;1</code>，则等于0。在<code>t=1</code>处，它是不可微的，但就像套索回归（Lasso Regression）一样，仍然可以在<code>t=0</code>时使用梯度下降法（即 -1 到 0 之间任何值）<img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/5-hinge.jpg" alt="img"></p>
</blockquote>
<p>大规模的非线性问题，可能需要考虑使用神经网络。</p>
<h4 id="Exercise-1"><a href="#Exercise-1" class="headerlink" title="Exercise"></a>Exercise</h4><ol>
<li><p>支持向量机背后的基本思想是什么</p>
<blockquote>
<p>支持向量机的背后的基本思想：寻找具有最大间隔的分类平面，来对正负样本进行分类。</p>
</blockquote>
</li>
<li><p>什么是支持向量</p>
<blockquote>
<p>支持向量就是最大间隔平面边界上样本点，这些样本点被称为“支持向量”</p>
</blockquote>
</li>
<li><p>当使用 SVM 时，为什么标准化输入很重要？</p>
<blockquote>
<p>因为SVM 对特征缩放比较敏感，对特征进行缩放可以使得判定边界更宽。</p>
<p>SVM寻找具有最大分类间隔的平面，如果不对输入进行归一化，SVM会忽略小的特征。</p>
</blockquote>
</li>
<li><p>分类一个样本时，SVM 分类器能够输出一个置信值吗？概率呢？</p>
<blockquote>
<p>SVM分类器通过简单地计算决策函数$\omega \cdot x+b$来预测新样本的类别，如果小于0，则为负类，如果大于等于0，则为正类。</p>
<p>SVM分类器不会输出每个类别的概率。</p>
</blockquote>
</li>
<li><p>在一个有数百万训练样本和数百特征的训练集上，你是否应该使用 SVM 原始形式或对偶形式来训练一个模型？</p>
<blockquote>
<p>线性SVM的训练时间复杂度约为O(m x n)，而对偶形式的复杂度通常介于O(m^2 x n) 到 O(m^3 x n)，m为实例个数，当训练样本变大时，它将变得极其慢。</p>
<p>所以对于大规模线性问题，可以使用SVM的原始形式，而对于大规模的非线性问题，可能需要考虑使用神经网络。</p>
</blockquote>
</li>
<li><p>假设你用 RBF 核来训练一个 SVM 分类器，如果对训练集欠拟合：你应该增大或者减小<code>γ</code>吗？调整参数<code>C</code>呢？</p>
<blockquote>
<p>RBF的形式：$\phi_{\gamma}(x, \ell) = exp(-\gamma |x - \ell |^2)$，是一个钟形曲线，<code>γ</code> 越大，钟形曲线越窄，每个样本的影响范围变得更小，边界更细化。</p>
<p>超参数<code>C</code>控制SCM分类模型的软硬，较小的<code>C</code>会导致更宽的分类间隔平面，但更多的间隔违规。</p>
<p>所以欠拟合时可以增大<code>γ</code>，增大<code>C</code></p>
</blockquote>
</li>
<li><p>使用现有的 QP 解决方案，你应该怎么样设置 QP 参数（<code>H</code>，<code>f</code>，<code>A</code>，和<code>b</code>）去解决一个软间隔线性 SVM 分类器问题？</p>
<blockquote>
<p>软间隔分类：</p>
<script type="math/tex; mode=display">
minimize\  \frac{1}{2} \omega^T\cdot \omega +C\sum_{i=1}^{m}\zeta^{(i)}\\

subject \  to\  t^{(i)}\ w^T\cdot x^{(i)}+b\geq1-\zeta^{(i)}\ \  and \ \ \zeta^{(i)} \geq0 \ \  for \ i=1,2,3,\cdots , m</script><p>QP(二次规划问题，即线性约束的凸二次规划优化问题)</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_5/eq-5-5.gif" alt="img"></p>
<p>H 是 $n_p \times n_p$的单位矩阵，左上角为0（忽略偏置向）</p>
<p>p = $（b,\ \omega_1\ \cdots\ \omega_n)^T$</p>
<p>$f^T\cdot p \ = \     C\cdot max(1-p^T\cdot A_i,0))$</p>
<p>$b_i=1-max(1-p^T\cdot A_i,0)$</p>
<p>$a_i^j=x_j^{(i)}\  \  i=1\cdots n_c;\ j=1\cdots n_p$ 第i个实例的第j个特征，但$x^{(i)}$带一个1的偏置项。</p>
</blockquote>
</li>
<li><p>在一个线性可分的数据集训练一个<code>LinearSVC</code>，并在同一个数据集上训练一个<code>SVC</code>和<code>SGDClassifier</code>，看它们是否产生了大致相同效果的模型。</p>
<blockquote>
<p>​</p>
</blockquote>
</li>
<li><p>在 MNIST 数据集上训练一个 SVM 分类器。因为 SVM 分类器是二元的分类，你需要使用一对多（one-versus-all）来对 10 个数字进行分类。你可能需要使用小的验证集来调整超参数，以加快进程。最后你能达到多少准确度？</p>
</li>
<li><p>在加利福尼亚住宅（California housing）数据集上训练一个 SVM 回归模型</p>
</li>
</ol>
<hr>
<h2 id="第06章-决策树"><a href="#第06章-决策树" class="headerlink" title="第06章 决策树"></a>第06章 决策树</h2><p>决策树是一种多功能机器学习算法， 即可以执行分类任务也可以执行回归任务， 甚至包括多输出（multioutput）任务。</p>
<h3 id="决策树的训练和可视化"><a href="#决策树的训练和可视化" class="headerlink" title="决策树的训练和可视化"></a>决策树的训练和可视化</h3><blockquote>
<p>决策树的众多特性之一就是， 它不需要太多的数据预处理， 尤其是不需要进行特征的缩放或者归一化。</p>
</blockquote>
<ul>
<li>节点的<code>samples</code>属性统计出它应用于多少个训练样本实例。</li>
<li>节点的<code>value</code>属性：这个节点对于每一个类别的样例有多少个。</li>
<li>节点的<code>Gini</code>属性用于测量它的纯度：如果一个节点包含的所有训练样例全都是同一类别的，这个节点是纯的（<code>Gini=0</code>）。</li>
</ul>
<p><strong>Gini分数$G_i$</strong></p>
<p>$G_i=1-\sum_{k=1}^{n}P_{i,k}^2$</p>
<p>$P_{i,k}$是第<code>i</code>个节点中训练实例为的<code>k</code>类实例的比例。</p>
<blockquote>
<p>Scikit-Learn 用的是 CART 算法， CART 算法仅产生二叉树：每一个非叶节点总是只有两个子节点（只有是或否两个结果）。然而，像 ID3 这样的算法可以产生超过两个子节点的决策树模型。</p>
</blockquote>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_6/102" alt="1528081141956"></p>
<h3 id="估计分类概率"><a href="#估计分类概率" class="headerlink" title="估计分类概率"></a>估计分类概率</h3><p>决策树还可以估计某个实例属于特定类<code>k</code>的概率：首先遍历树来查找此实例的叶节点，然后它返回此节点中类<code>k</code>的训练实例的比例。</p>
<blockquote>
<p>假设你发现了一个花瓣长 5 厘米，宽 1.5 厘米的花朵。相应的叶节点是深度为 2 的左节点，因此决策树应该输出以下概率：Iris-Setosa 为 0%（0/54），Iris-Versicolor 为 90.7%（49/54），Iris-Virginica 为 9.3%（5/54）。当然，如果你要求它预测具体的类，它应该输出 Iris-Versicolor（类别 1），因为它具有最高的概率。</p>
</blockquote>
<h3 id="CART训练算法"><a href="#CART训练算法" class="headerlink" title="CART训练算法"></a>CART训练算法</h3><p>Scikit-Learn 用<strong>分裂回归树（Classification And Regression Tree，简称 CART）算法训练决策树（也叫“增长树”）</strong>。</p>
<p>首先使用单个特征<code>k</code>和阈值 $t_k$ 例如，（“花瓣长度<code>≤2.45cm</code>”）将训练集分成两个子集。它如何选择<code>k</code>和 $t_k$ ？它寻找到能够产生最纯粹子集的一对 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-32cb6265eb19ce4be37ecf6650ff766a.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-32cb6265eb19ce4be37ecf6650ff766a.gif" alt="(k, t_k)"></a>，然后通过子集大小加权计算。</p>
<p>算法会尝试最小化成本函数：</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_6/104" alt="1528086977613"></p>
<blockquote>
<p>CART 算法是一种贪婪算法：贪婪地搜索最高级别的最佳分割方式，然后在每个深度重复该过程。 </p>
<p>不检查分割是否能够在几个级别中的全部分割可能中找到最佳方法。</p>
<p>贪婪算法通常会产生一个相当好的解决方法，但它不保证这是全局中的最佳解决方案。</p>
</blockquote>
<h4 id="NP完全问题"><a href="#NP完全问题" class="headerlink" title="NP完全问题"></a>NP完全问题</h4><p>寻找最佳的决策树是NP完成问题(<code>Non-deterministic Polynomial</code>，即多项式复杂程度的非确定性问题)，也会简称为NP-C问题。</p>
<p>决策树的这一特点，说明无法利用计算机在多项式时间内，找出全局最优的解。也正因为如此，大多数决策树算法都采用启发式的算法，如&amp;<strong>贪心算法</strong>，来指导对假设空间的搜索。可以说，决策树最后的结果，是在每一步、每一个节点上做的局部最优选择。决策树得到的结果，无法保证是全局最优解。</p>
<h5 id="P类问题"><a href="#P类问题" class="headerlink" title="P类问题"></a>P类问题</h5><blockquote>
<p> 所有可以在多项式时间内求解的判定问题构成<strong>P类问题</strong></p>
</blockquote>
<p><strong>判定问题</strong>是指回答结果输出为<code>Yes</code>或<code>No</code>的问题，比如：3233是否可以写成两个大于1的数字的乘积？</p>
<p>在设计程序时，需要评估这个程序的时间复杂度，即衡量当问题规模变大后，程序执行所需的时间增长会有多快。如$O(1)$表示常数级别，即不管问题的规模变大多少倍，所耗的时间不会改变；$O(N^2)$表示平方级别，即当问题规模增大至2倍时，所花费的时间则放大至4倍；$O(2^N)$表示指数级别，即当问题规模倍数扩大时，所用时间会呈指数放大。</p>
<p><strong>多项式时间</strong>则是指$O(1)、O(logN)、O(N^2)$等这类可用多项式表示的时间复杂度，通常认为计算机可解决的问题只限于多项式时间内。而$O(2^N)、O(N!)$这类非多项式级别的问题，其复杂度往往已经到了计算机都接受不了的程度。</p>
<h5 id="NP类问题"><a href="#NP类问题" class="headerlink" title="NP类问题"></a>NP类问题</h5><blockquote>
<p>所有非确定性多项式时间内可解的判定问题构成<strong>NP类问题</strong></p>
</blockquote>
<p>NP类问题将问题分为求解和验证两个阶段，问题的求解是非确定性的，无法在多项式时间内得到答案，而问题的验证却是确定的，能够在多项式时间里确定结果。</p>
<p>比如：是否存在一个公式可以计算下一个质数是多少？这个问题的答案目前是无法直接计算出来的，但是如果某人给出了一个公式，我们却可以在多项式时间里对这个公式进行验证。</p>
<h5 id="NP完全问题-1"><a href="#NP完全问题-1" class="headerlink" title="NP完全问题"></a>NP完全问题</h5><blockquote>
<p>NP类问题的一种特殊情况，这类问题中每个问题的复杂度与整个类的复杂度有关联性，假如其中任意一个问题在多项式时间内可解的，则这一类问题都是多项式时间可解。这些问题被称为<strong>NP完全问题</strong>。</p>
</blockquote>
<p>总结这几类问题的特点，可参考如下这个表格：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>问题类型</th>
<th>是否能在多项式时间内求解</th>
<th>是否能在多项式时间内验证</th>
</tr>
</thead>
<tbody>
<tr>
<td>P</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>NP</td>
<td>是 or 否</td>
<td>是</td>
</tr>
<tr>
<td>NP-C</td>
<td>未知</td>
<td>是</td>
</tr>
</tbody>
</table>
</div>
<p>参考：<a href="https://www.jianshu.com/p/dcb0b52f4935" target="_blank" rel="noopener">https://www.jianshu.com/p/dcb0b52f4935</a></p>
<h3 id="计算复杂度"><a href="#计算复杂度" class="headerlink" title="计算复杂度"></a>计算复杂度</h3><p>建立好决策树模型后， 做出<strong>预测</strong>需要遍历决策树， 从根节点一直到叶节点。决策树通常近似左右平衡，因此遍历决策树需要经历大致  $O(log_2m)$个节点。由于每个节点只需要检查一个特征的值，因此总体预测复杂度仅为 $O(log_2m)$，与特征的数量无关。</p>
<p><strong>训练</strong>算法的时候（训练和预测不同）需要比较所有特征（如果设置了<code>max_features</code>会更少一些）在每个节点的所有样本上。训练复杂度为$O(nmlog_m)$</p>
<h3 id="基尼不纯度和信息熵"><a href="#基尼不纯度和信息熵" class="headerlink" title="基尼不纯度和信息熵"></a>基尼不纯度和信息熵</h3><p>默认算法使用 Gini 不纯度来进行检测， 但是也可以通过将标准超参数设置为<code>&quot;entropy&quot;</code>来使用熵不纯度进行检测。</p>
<p><strong>熵的计算：</strong></p>
<script type="math/tex; mode=display">
H_i=-\sum_{k=1\ P_{i,k=!0}}^n{P_{i,k}}log(p_{i,k})</script><p>熵的减少通常称为<strong>信息增益</strong></p>
<blockquote>
<p>基尼指数计算稍微快一点，所以这是一个很好的默认值。</p>
<p>但是，也有的时候它们会产生不同的树，基尼指数会趋于在树的分支中将最多的类隔离出来，而熵指数趋向于产生略微平衡一些的决策树模型。</p>
</blockquote>
<h3 id="正则化超参数"><a href="#正则化超参数" class="headerlink" title="正则化超参数"></a>正则化超参数</h3><p>决策树几乎不对训练数据做任何假设（于此相反的是线性回归等模型，这类模型通常会假设数据是符合线性关系的）。这一类的模型通常会被称为<strong>非参数模型&amp;</strong>，这不是因为它没有任何参数（通常也有很多），而是因为<strong>在训练之前没有确定参数的具体数量，所以模型结构可以根据数据的特性自由生长。</strong></p>
<p>如果不添加约束，树结构模型通常将根据训练数据调整自己，使自身能够很好的拟合数据，而这种情况下大多数会导致<strong>模型过拟合</strong>。</p>
<blockquote>
<p><strong><code>DecisionTreeClassifier</code>类还有一些其他的参数用于限制树模型的形状:</strong></p>
<p><code>min_samples_split</code>（节点在被分裂之前必须具有的最小样本数）</p>
<p><code>min_samples_leaf</code>（叶节点必须具有的最小样本数），<code>min_weight_fraction_leaf</code>（和<code>min_samples_leaf</code>相同，但表示为加权总数的一小部分实例）</p>
<p><code>max_leaf_nodes</code>（叶节点的最大数量）</p>
<p><code>max_features</code>（在每个节点被评估是否分裂的时候，具有的最大特征数量）</p>
<p>增加<code>min_* hyperparameters</code>或者减少<code>max_* hyperparameters</code>会使模型正则化。</p>
<p><strong>剪枝</strong></p>
<p>在没有任何约束条件下训练决策树模型，让模型自由生长，然后再对不需要的节点进行剪枝。</p>
<p>当一个节点的全部子节点都是叶节点时，如果它对纯度的提升不具有统计学意义，我们就认为这个分支是不必要的。</p>
<p>标准的假设检验，例如卡方检测，通常会被用于评估一个概率值 — 即改进是否纯粹是偶然性的结果（也叫原假设）</p>
<p>如果 p 值比给定的阈值更高（通常设定为 5%，也就是 95% 置信度，通过超参数设置），那么节点就被认为是非必要的，它的子节点会被删除。</p>
<p>这种剪枝方式将会一直进行，直到所有的非必要节点都被删光。</p>
</blockquote>
<h3 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h3><p>Scikit-Learn 的<code>DecisionTreeRegressor</code>类构建回归树，不再以最小化不纯度的方式分割训练集，而是试图以最小化 MSE 的方式分割训练集。</p>
<blockquote>
<p> 每个区域的预测值总是该区域中实例的平均目标值。</p>
</blockquote>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_6/108" alt="1528375227547"></p>
<h3 id="不稳定性"><a href="#不稳定性" class="headerlink" title="不稳定性"></a>不稳定性</h3><p>决策树的特点：</p>
<ol>
<li><p>容易理解和解释，易于使用且功能丰富而强大。</p>
</li>
<li><p>决策树很喜欢设定正交化的决策边界，（所有边界都是和某一个轴相垂直的），这使得它对训练数据集的旋转很敏感。</p>
<blockquote>
<p>解决办法：主成分分析PCA</p>
</blockquote>
</li>
<li><p>决策时的主要问题是它对训练数据的微小变化非常敏感</p>
</li>
</ol>
<h3 id="exercise"><a href="#exercise" class="headerlink" title="exercise"></a>exercise</h3><ol>
<li><p>在 100 万例训练集上训练（没有限制）的决策树的近似深度是多少？</p>
<blockquote>
<p>$log_2(m)$，m=100万时，该值大约为20</p>
</blockquote>
</li>
<li><p>节点的基尼指数比起它的父节点是更高还是更低？它是通常情况下更高/更低，还是永远更高/更低？</p>
<blockquote>
<p>节点的基尼指数通常低于其父节点，这是由CART数的训练损失函数所确定的，每个节点经过最优属性分割之后，子节点的基尼指数之和都会小于父节点的基尼指数，然而如果一个孩子节点的基尼指数比另外一个的基尼指数小，则可能比其父节点的基尼不纯度更大，但是其基尼不纯度的增加肯定小于另外孩子基尼不纯度的减少。</p>
</blockquote>
</li>
<li><p>如果决策树过拟合了，减少最大深度是一个好的方法吗？</p>
<blockquote>
<p>是一个好方法，可以对模型进行约束，使其规范化</p>
</blockquote>
</li>
<li><p>如果决策树对训练集欠拟合了，尝试缩放输入特征是否是一个好主意？</p>
<blockquote>
<p>不是，因为决策树对于数据的缩放并不敏感</p>
</blockquote>
</li>
<li><p>如果对包含 100 万个实例的数据集训练决策树模型需要一个小时，在包含 1000 万个实例的培训集上训练另一个决策树大概需要多少时间呢？</p>
<blockquote>
<p>训练复杂度$O(n\times m \log(m))$，如果实例m增加10倍，则复杂度变为$10\times\log(10m)/\log(m)$ 倍，m=100万时，该值为11.7，所以需要11.7个小时</p>
</blockquote>
</li>
<li><p>如果你的训练集包含 100,000 个实例，设置<code>presort=True</code>会加快训练的速度吗？</p>
<blockquote>
<p>只有当数据集小于几千时，才会加速训练实例。如果它包含100,000个实例，那么设置presort=True的训练将会慢得多。</p>
</blockquote>
</li>
<li><p>对<code>moons</code>数据集进行决策树训练并优化模型。</p>
<ol>
<li><p>通过语句<code>make_moons(n_samples=10000, noise=0.4)</code>生成<code>moons</code>数据集</p>
</li>
<li><p>通过<code>train_test_split()</code>将数据集分割为训练集和测试集。</p>
</li>
<li><p>进行交叉验证，并使用网格搜索法寻找最好的超参数值（使用<code>GridSearchCV</code>类的帮助文档）</p>
<p>提示: 尝试各种各样的<code>max_leaf_nodes</code>值</p>
</li>
<li><p>使用这些超参数训练全部的训练集数据，并在测试集上测量模型的表现。你应该获得大约 85% 到 87% 的准确度。</p>
</li>
</ol>
</li>
<li><p>生成森林</p>
<ol>
<li>接着前边的练习，现在，让我们生成 1,000 个训练集的子集，每个子集包含 100 个随机选择的实例。提示：你可以使用 Scikit-Learn 的<code>ShuffleSplit</code>类。</li>
<li>使用上面找到的最佳超参数值，在每个子集上训练一个决策树。在测试集上测试这 1000 个决策树。由于它们是在较小的集合上进行了训练，因此这些决策树可能会比第一个决策树效果更差，只能达到约 80% 的准确度。</li>
<li>见证奇迹的时刻到了！对于每个测试集实例，生成 1,000 个决策树的预测结果，然后只保留出现次数最多的预测结果（您可以使用 SciPy 的<code>mode()</code>函数）。这个函数使你可以对测试集进行多数投票预测。</li>
<li>在测试集上评估这些预测结果，你应该获得了一个比第一个模型高一点的准确率，（大约 0.5% 到 1.5%），恭喜，你已经弄出了一个随机森林分类器模型!</li>
</ol>
</li>
</ol>
<h2 id="第07章-集成学习和随机森林"><a href="#第07章-集成学习和随机森林" class="headerlink" title="第07章 集成学习和随机森林"></a>第07章 集成学习和随机森林</h2><p>合并了一组分类器的预测（像分类或者回归），得到一个比单一分类器更好的预测结果。这一组分类器就叫做<strong>集成</strong>；因此，这个技术就叫做<strong>集成学习</strong>，一个集成学习算法就叫做<strong>集成方法</strong>。一种决策树的集成就叫做<strong>随机森林</strong>。</p>
<p>即使每一个分类器都是一个<strong>弱学习器</strong>（意味着它们也就比瞎猜好点），集成后仍然是一个<strong>强学习器</strong>（高准确率），只要有足够数量的弱学习者，他们就足够多样化。</p>
<h3 id="投票分类"><a href="#投票分类" class="headerlink" title="投票分类"></a>投票分类</h3><p>一个非常简单去创建一个更好的分类器的方法就是去整合每一个分类器的预测然后经过投票去预测分类。这种分类器就叫做<strong>硬投票分类器</strong></p>
<blockquote>
<p>每一个分类器都在同一个数据集上训练，导致其很可能会发生这样的错误。他们可能会犯同一种错误，所以也会有很多票投给了错误类别导致集成的准确率下降。</p>
</blockquote>
<p>所以应该用完全不同的算法得到多样的分类器，使它们会做出不同种类的错误，提高集成的正确率。</p>
<p>如果所有的分类器都能够预测类别的概率（有一个<code>predict_proba()</code>方法），可以让 sklearn 以最高的类概率来预测这个类，平均在所有的分类器上。这种方式叫做<strong>软投票</strong>。其表现比硬投票更好，因为给予高自信的投票更大的权重。</p>
<h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p><strong>有放回采样被称为装袋（<em>Bagging</em>，是 <em>bootstrap aggregating</em> 的缩写）。无放回采样称为粘贴（<em>pasting</em>）</strong></p>
<p>Bagging 和 Pasting 都允许在多个分类器间对训练集进行多次采样，但只有 Bagging可以通过使用不同的训练算法去得到一些不同的分类器。 Pasting是对每一个分类器都使用相同的训练算法，但是在不同的训练集上去训练。</p>
<blockquote>
<p>当所有的分类器被训练后，集成可以通过对所有分类器结果的简单聚合来对新的实例进行预测。<strong>聚合函数</strong>通常对分类是<em>统计模式</em>（例如硬投票分类器）或者对回归是平均。</p>
<p>每一个单独的分类器在如果在原始训练集上都是高偏差，但是聚合降低了偏差和方差。通常情况下，集成的结果是有一个相似的偏差，但是对比与在原始训练集上的单一分类器来讲有更小的方差。</p>
</blockquote>
<p>如果基分类器可以预测类别概率（例如它拥有<code>predict_proba()</code>方法），那么<code>BaggingClassifier</code>会自动的运行软投票。</p>
<h4 id="Out-of-bag"><a href="#Out-of-bag" class="headerlink" title="Out-of-bag"></a>Out-of-bag</h4><p>对于 Bagging 来说，一些实例可能被一些分类器重复采样，但其他的有可能不会被采样。<code>BaggingClassifier</code>默认是有放回的采样<code>m</code>个实例 （<code>bootstrap=True</code>）。意味着平均下来只有63%的训练实例被每个分类器采样，剩下的37%个没有被采样的训练实例就叫做 <em>Out-of-Bag</em> 实例。注意对于每一个的分类器它们的 37% 不是相同的。</p>
<p>可以拿出每一个分类器的 oob 来评估集成本身。</p>
<h4 id="随机贴片与随机子空间"><a href="#随机贴片与随机子空间" class="headerlink" title="随机贴片与随机子空间"></a>随机贴片与随机子空间</h4><p><code>BaggingClassifier</code>也支持采样特征。</p>
<p>对训练实例和特征的采样被叫做随机贴片。保留了所有的训练实例（例如<code>bootstrap=False</code>和<code>max_samples=1.0</code>），但是对特征采样（<code>bootstrap_features=True</code>并且/或者<code>max_features</code>小于 1.0）叫做随机子空间。</p>
<p><strong>采样特征导致更多的预测多样性，用高偏差换低方差。</strong></p>
<h3 id="随机森林（一种bagging模型）"><a href="#随机森林（一种bagging模型）" class="headerlink" title="随机森林（一种bagging模型）"></a>随机森林（一种bagging模型）</h3><p>随机森林算法在树生长时引入了额外的随机；与在节点分裂时需要找到最好分裂特征相反（详见第六章），它<strong>在一个随机的特征集中找最好的特征，</strong>导致了树的差异性，<strong>再一次用高偏差换低方差</strong>，总的来说是一个更好的模型。</p>
<h4 id="极端随机树"><a href="#极端随机树" class="headerlink" title="极端随机树"></a>极端随机树</h4><p>在随机森林上生长树时，在每个结点分裂时只考虑随机特征集上的特征。可以通过对特征使用随机阈值使树更加随机。<strong>这种极端随机的树被称为Extremely Randomized Trees简称为 <em>Extra-Tree</em>。</strong></p>
<blockquote>
<p>因为在每个节点上找到每个特征的最佳阈值是生长树最耗时的任务之一，所以 <em>Extra-Tree</em> 比规则的随机森林训练更快。</p>
</blockquote>
<h4 id="特征重要度"><a href="#特征重要度" class="headerlink" title="特征重要度"></a>特征重要度</h4><p><strong>重要的特征会出现在单一决策树更靠近根部的位置，而不重要的特征会经常出现在靠近叶子的位置。因此可以通过计算一个特征在森林的全部树中出现的平均深度来预测特征的重要性。</strong></p>
<p>随机森林可以非常方便快速得了解哪些特征实际上是重要的，特别是你需要进行特征选择的时候。</p>
<h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>提升（Boosting，最初称为<em>假设增强</em>）指的是可以将几个弱学习者组合成强学习者的集成方法。对于大多数的提升方法的思想就是按顺序去训练分类器，每一个都要尝试修正前面的分类。现如今已经有很多的提升方法了，但最著名的就是 <em>Adaboost</em>（适应性提升，是 <em>Adaptive Boosting</em> 的简称） 和 <em>Gradient Boosting</em>（梯度提升）。</p>
<h4 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h4><p>使一个新的分类器去修正之前分类结果的方法就是<strong>对之前分类结果错误的训练实例多加关注</strong>。这导致新的预测因子越来越多地聚焦于这种情况。这是 <em>Adaboost</em> 使用的技术。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_7/7-7.png" alt="图7-7"></p>
<blockquote>
<p>序列学习技术的一个重要的<strong>缺点</strong>是：它不能被并行化（只能按步骤），因为每个分类器只能在之前的分类器已经被训练和评价后再进行训练。</p>
</blockquote>
<p><strong>Adaboost的算法</strong></p>
<p>每一个实例的权重<code>wi</code>初始都被设为<code>1/m</code></p>
<p>第一个分类器被训练后，在训练集上算出权重误差率<code>r1</code>：</p>
<p><strong>第j个分类器的权重误差率：</strong></p>
<script type="math/tex; mode=display">
r_j\ = \ \frac{\sum_{i=1,\hat y_j^{(i)}\neq y^{(i)}}^m \omega^{(i)}}{\sum _{i=1}^m \omega^{(i)}}</script><p>$\hat y_j^i$ 是第j个分类器对于第i个实例的预测。</p>
<p><strong>分类器的权重</strong></p>
<p>其中<code>η</code>是超参数学习率（默认为 1）。分类器准确率越高，它的权重就越高。</p>
<script type="math/tex; mode=display">
\alpha_j = \eta \log \frac{1-r_j}{r_j}</script><p><strong>权重更新规则</strong></p>
<p>对于<code>i=1, 2, ..., m</code></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_7/E7-3.png" alt="公式7-3"></p>
<p>随后所有实例的权重都被归一化。</p>
<p>为了进行预测，Adaboost 通过分类器权重 $α_{j}$简单的计算了所有的分类器和权重。预测类别会是权重投票中主要的类别。</p>
<p><strong>Adaboost 分类器</strong></p>
<script type="math/tex; mode=display">
\hat y(x)\ = \ {argmax}_k \ \ \sum^N_{j=1,\hat y_j(x)=k} \alpha_j</script><p>其中<code>N</code>是分类器的数量。</p>
<blockquote>
<p>sklearn 通常使用 Adaboost 的多分类版本 <em>SAMME</em>（<em>分段加建模使用多类指数损失函数</em>）。如果只有两类别，那么 <em>SAMME</em> 是与 Adaboost 相同的。如果分类器可以预测类别概率（有<code>predict_proba()</code>），如果 sklearn 可以使用 <em>SAMME</em> 叫做<code>SAMME.R</code>的变量（R 代表“REAL”），这种依赖于类别概率的通常比依赖于分类器的更好。</p>
</blockquote>
<p>如果 Adaboost 集成<strong>过拟合</strong>，可以尝试<strong>减少基分类器的数量</strong>或者<strong>对基分类器使用更强的正则化</strong>。</p>
<h4 id="梯度提升"><a href="#梯度提升" class="headerlink" title="梯度提升"></a>梯度提升</h4><p>梯度提升也是通过向集成中逐步增加分类器运行的，每一个分类器都修正之前的分类结果。然而，并不像 Adaboost 那样每一次迭代都更改实例的权重，这个方法<strong>使用新的分类器去拟合前面分类器预测的<em>残差</em> </strong>。</p>
<p><strong>梯度提升回归树</strong>（GBRT，<em>Gradient Tree Boosting</em> 或者 <em>Gradient Boosted Regression Trees</em>）</p>
<p><strong>梯度提升决策树</strong> (GBDT， <em>Gradient Boosted Decision Trees</em>)是梯度提升(GB)算法限定基学习器是<strong>回归决策树时的模型，尤其是CART回归树</strong>。</p>
<p>sklean 中的<code>GradientBoostingRegressor</code>可以用来训练 GBRT 集成，也有超参数去控制集成训练，例如基分类器的数量（<code>n_estimators</code>）。超参数<code>learning_rate</code> 确立了每个树的贡献。</p>
<blockquote>
<p>如果把<code>learning_rate</code>设置为一个很小的树，例如 0.1，在集成中就需要更多的树去拟合训练集，但预测通常会更好。这个正则化技术叫做 <strong><em>shrinkage</em></strong>。</p>
</blockquote>
<h5 id="Early-stop-早停"><a href="#Early-stop-早停" class="headerlink" title="Early stop(早停)"></a>Early stop(早停)</h5><p><code>GradientBoostingRegressor</code>有方法<code>staged_predict()</code>：它在训练的每个阶段返回一个迭代器。</p>
<p>与先在一大堆树中训练，然后再回头去找最优数目相反。可以通过设置<code>warm_start=True</code>来实现 早停，这使得当<code>fit()</code>方法被调用时 sklearn 保留现有树，并允许增量训练。</p>
<p><code>GradientBoostingRegressor</code>也支持指定用于训练每棵树的训练实例比例的超参数<code>subsample</code>。例如如果<code>subsample=0.25</code>，那么每个树都会在 25% 随机选择的训练实例上训练。这也是个高偏差换低方差的作用。同样也加速了训练。这个技术叫做<strong><em>随机梯度提升</em></strong>。</p>
<h4 id="极端梯度提升（XGBoost）"><a href="#极端梯度提升（XGBoost）" class="headerlink" title="极端梯度提升（XGBoost）"></a>极端梯度提升（XGBoost）</h4><ol>
<li>提升树只使用了一阶泰勒展开，而XGBoost使用了二阶泰勒展开。</li>
<li>xgboost在<strong>代价函数里加入了正则项，用于控制模型的复杂度</strong>。</li>
<li><strong>列抽样（column subsampling）</strong>。xgboost借鉴了随机森林的做法，支持列抽样（即每次的输入特征不是全部特征），不仅能降低过拟合，还能减少计算</li>
<li><strong>并行化处理</strong>：在训练之前，预先对每个特征内部进行了排序找出候选切割点，然后保存为block结构，后面的迭代中重复地使用这个结构，大大减小计算量。</li>
</ol>
<p>xgboost工具支持自定义代价函数，只要函数可一阶和二阶求导。例如，xgboost支持线性分类器，这个时候xgboost相当于带L1和L2正则化项的逻辑斯蒂回归（分类问题）或者线性回归（回归问题）</p>
<p><a href="https://zhuanlan.zhihu.com/p/57814935" target="_blank" rel="noopener">参考</a></p>
<h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p><strong><em>Stacking</em>（<em>stacked generalization</em> 的缩写），这个算法不使用琐碎的函数（如硬投票）来聚合集合中所有分类器的预测，我直接训练一个模型来执行这个聚合。</strong></p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_7/7-12.png" alt="图7-12"></p>
<p>为了训练这个 <em>blender</em> ，一个通用的方法是<strong>采用保持集</strong>。</p>
<ol>
<li>首先，训练集被分为两个子集，第一个子集被用作训练第一层。</li>
<li>第一层的分类器被用来预测第二个子集（保持集）。</li>
<li>使用这些预测结果作为输入特征来创建一个新的训练集，保持目标数值不变，随后 <em>blender</em> 在这个新的训练集上训练。</li>
</ol>
<p>sklearn 并不直接支持 stacking ，但可以使用开源项目<a href="https://github.com/Menelau/DESlib" target="_blank" rel="noopener">DESlib</a>（基于sklearn）</p>
<h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ol>
<li><p>如果你在相同训练集上训练 5 个不同的模型，它们都有 95% 的准确率，那么你是否可以通过组合这个模型来得到更好的结果？如果可以那怎么做呢？如果不可以请给出理由。</p>
<blockquote>
<p>可以通过集成学习将5个模型集成在一起</p>
<p>通过投票的方式预测</p>
</blockquote>
</li>
<li><p>软投票和硬投票分类器之间有什么区别？</p>
<blockquote>
<p>硬投票分类器计算集合中每个分类器的投票，并选择得到最多选票的类。</p>
<p>软投票分类器计算每个类的平均估计类概率，并选择概率最高的类，也就是给置信度高的类更高的权重，但是前提是可以得到每个类的概率。</p>
</blockquote>
</li>
<li><p>是否有可能通过分配多个服务器来加速 bagging 集成系统的训练？pasting 集成，boosting 集成，随机森林，或 stacking 集成怎么样？</p>
<blockquote>
<p>bagging，pasting和stacking都可以并行，随机森林算bagging</p>
<p>boosting是序列学习技术，不能并行。</p>
</blockquote>
</li>
<li><p>out-of-bag 评价的好处是什么？</p>
<blockquote>
<p>包外集成中的每个预测器都使用它没有经过训练的实例进行评估，不需要额外的验证集。</p>
</blockquote>
</li>
<li><p>是什么使 Extra-Tree 比规则随机森林更随机呢？这个额外的随机有什么帮助呢？那这个 Extra-Tree 比规则随机森林谁更快呢？</p>
<blockquote>
<p>Extra-Tree在随机森林上生长树时，在每个结点分裂时只考虑随机特征集上的特征，额不是在每个节点上找到每个特征的最佳阈值，所以训练时 <em>Extra-Tree</em> 比规则的随机森林更快。</p>
</blockquote>
</li>
<li><p>如果你的 Adaboost 模型欠拟合，那么你需要怎么调整超参数？</p>
<blockquote>
<p>如果 Adaboost 集成<strong>过拟合</strong>，可以尝试<strong>减少基分类器的数量</strong>或者<strong>对基分类器使用更强的正则化</strong>。</p>
</blockquote>
</li>
<li><p>如果你的梯度提升过拟合，那么你应该调高还是调低学习率呢？</p>
<blockquote>
<p>降低学习率，或使用早停的方法来寻找正确数量的基学习器。</p>
</blockquote>
</li>
<li><p>导入 MNIST 数据（第三章中介绍），把它切分进一个训练集，一个验证集，和一个测试集（例如 40000 个实例进行训练，10000 个进行验证，10000 个进行测试）。然后训练多个分类器，例如一个随机森林分类器，一个 Extra-Tree 分类器和一个 SVM。接下来，尝试将它们组合成集成，使用软或硬投票分类器来胜过验证集上的所有集合。一旦找到了，就在测试集上实验。与单个分类器相比，它的性能有多好？</p>
</li>
<li><p>从练习 8 中运行个体分类器来对验证集进行预测，并创建一个新的训练集并生成预测：每个训练实例是一个向量，包含来自所有分类器的图像的预测集，目标是图像类别。祝贺你，你刚刚训练了一个 <em>blender</em> ，和分类器一起组成了一个叠加组合！现在让我们来评估测试集上的集合。对于测试集中的每个图像，用所有分类器进行预测，然后将预测馈送到 <em>blender</em> 以获得集合的预测。它与你早期训练过的投票分类器相比如何？</p>
</li>
</ol>
<hr>
<h2 id="第08章-降维"><a href="#第08章-降维" class="headerlink" title="第08章 降维"></a>第08章 降维</h2><blockquote>
<p>警告：降维会丢失一些信息，因此即使这种方法可以加快训练的速度，同时也会让系统表现的稍微差一点。降维会让工作流水线更复杂因而更难维护。所有应该先尝试使用原始的数据来训练，如果训练速度太慢的话再考虑使用降维。在某些情况下，降低训练集数据的维度可能会筛选掉一些噪音和不必要的细节，这可能会让结果比降维之前更好（这种情况通常不会发生；它只会加快训练的速度）。</p>
</blockquote>
<p>降维除了可以加快训练速度外，在数据可视化方面（或者 DataViz）也十分有用。降低特征维度到 2（或者 3）维从而可以在图中画出一个高维度的训练集，让我们可以通过视觉直观的发现一些非常重要的信息，比如聚类。</p>
<p><strong>两种主要的降维方法：投影（projection）和流形学习（Manifold Learning），三种流行的降维技术：主成分分析（PCA），核主成分分析（Kernel PCA）和局部线性嵌入（LLE）。</strong></p>
<h3 id="维数灾难（curse-of-dimentionality）"><a href="#维数灾难（curse-of-dimentionality）" class="headerlink" title="维数灾难（curse of dimentionality）"></a>维数灾难（curse of dimentionality）</h3><p>一个 1,0000 维的单位超正方体中，随机选的点离所有边界大于 0.001（靠近中间位置）的概率（$1-0.998^{10000}$），近似于1，在高维超正方体中，大多数点都分布在边界处。</p>
<p>在一个 1,000,000 维超立方体中随机抽取两点的平均距离，大概为 408.25（大致 <a href="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-50eeccb6ef846e2d0af5daef5cab1fa0.gif" target="_blank" rel="noopener"><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/tex-50eeccb6ef846e2d0af5daef5cab1fa0.gif" alt="\sqrt{1,000,000/6}"></a>）</p>
<p>表明高维数据集有很大风险分布的非常稀疏：大多数训练实例可能彼此远离。也意味着一个新实例可能远离任何训练实例，使得预测的可靠性远低于较低维度数据的预测，因为它们将基于更大的推测（extrapolations）。简而言之，训练集的维度越高，过拟合的风险就越大。</p>
<p>理论上来说，维数爆炸的一个解决方案是增加训练集的大小从而达到拥有足够密度的训练集。</p>
<h3 id="降维的主要方法"><a href="#降维的主要方法" class="headerlink" title="降维的主要方法"></a>降维的主要方法</h3><h4 id="投影（Projection）"><a href="#投影（Projection）" class="headerlink" title="投影（Projection）"></a>投影（Projection）</h4><p>大多数现实生活的问题中，训练实例并不是在所有维度上均匀分布的，许多特征几乎是常数，而其他特征则高度相关（如前面讨论的 MNIST）。<strong>所有训练实例实际上位于（或接近）高维空间的低维子空间内。</strong></p>
<p>投影并不总是降维的最佳方法。在很多情况下，子空间可能会扭曲和转动。</p>
<h4 id="流形学习（Manifold-Learning）"><a href="#流形学习（Manifold-Learning）" class="headerlink" title="流形学习（Manifold Learning）"></a>流形学习（Manifold Learning）</h4><p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_8/8-4.jpeg" alt="img"></p>
<p>瑞士卷一个是二维流形的例子。简而言之，二维流形是一种二维形状，它可以在更高维空间中弯曲或扭曲。一个<code>d</code>维流形是类似于<code>d</code>维超平面的<code>n</code>维空间（其中<code>d &lt; n</code>）的一部分。瑞士卷有些像 2D 平面，但是它实际上是在第三维中卷曲。</p>
<p><strong>通过对训练实例所在的流形进行建模从而达到降维目的，叫做流形学习。</strong>它依赖于流形猜想（manifold assumption），也被称为流形假设（manifold hypothesis），认为大多数现实世界的高维数据集大都靠近一个更低维的流形。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_8/8-6.jpeg" alt="img"></p>
<p>如果在训练模型之前降低训练集的维数，那训练速度肯定会加快，但并不总是会得出更好的训练效果；这一切都取决于数据集。</p>
<h3 id="降维技术"><a href="#降维技术" class="headerlink" title="降维技术"></a>降维技术</h3><h4 id="主成分分析（PCA）"><a href="#主成分分析（PCA）" class="headerlink" title="主成分分析（PCA）"></a>主成分分析（PCA）</h4><p>主成分分析（Principal Component Analysis）是目前为止最流行的降维算法。首先它找到接近数据集分布的超平面，然后将所有的数据都投影到这个超平面上。</p>
<h5 id="保留最大方差"><a href="#保留最大方差" class="headerlink" title="保留最大方差"></a>保留最大方差</h5><p>选择保持最大方差的轴将原始数据集投影到该轴上的均方距离最小，损失更少的信息。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_8/8-7.jpeg" alt="img"></p>
<h5 id="主成分（Principle-Componets）"><a href="#主成分（Principle-Componets）" class="headerlink" title="主成分（Principle Componets）"></a>主成分（Principle Componets）</h5><p> 定义第<code>i</code>个轴的单位矢量被称为第<code>i</code>个主成分（PC）。</p>
<p><strong>奇异值分解（SVD）</strong>的标准矩阵分解：将训练集矩阵<code>X</code>分解为三个矩阵<code>U·Σ·V^T</code>的点积，其中<code>V^T</code>包含我们想要的所有主成分，</p>
<blockquote>
<p>PCA 假定数据集以原点为中心。Scikit-Learn 的<code>PCA</code>类负责数据集中心化处理。但是，如果自己实现 PCA，或者使用其他库，首先要先对数据做中心化处理。</p>
</blockquote>
<h5 id="投影到d维空间"><a href="#投影到d维空间" class="headerlink" title="投影到d维空间"></a>投影到<code>d</code>维空间</h5><script type="math/tex; mode=display">
X_{d-proj} = X\cdot W_d</script><p>$W_d$定义为包含前<code>d</code>个主成分的矩阵（即由<code>V^T</code>的前<code>d</code>列组成的矩阵）</p>
<h5 id="方差解释率（Explained-Variance-Ratio）"><a href="#方差解释率（Explained-Variance-Ratio）" class="headerlink" title="方差解释率（Explained Variance Ratio）"></a>方差解释率（Explained Variance Ratio）</h5><p>每个主成分的方差解释率，可通过<code>explained_variance_ratio_</code>变量获得。它表示位于每个主成分轴上的数据集方差的比例。</p>
<h5 id="选择正确的维度"><a href="#选择正确的维度" class="headerlink" title="选择正确的维度"></a>选择正确的维度</h5><p>倾向于选择加起来到方差解释率能够达到足够占比（例如 95%）的维度的数量，而不是任意选择要降低到的维度数量。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_8/8-8.jpeg" alt="img"></p>
<h5 id="PCA压缩"><a href="#PCA压缩" class="headerlink" title="PCA压缩"></a>PCA压缩</h5><p>原始数据和重构数据之间的均方距离（压缩然后解压缩）被称为重构误差（reconstruction error）。</p>
<p>PCA逆变换</p>
<script type="math/tex; mode=display">
X_{recovered} = X_{d-proj}\cdot W_d^T</script><h5 id="增量-PCA（Incremental-PCA）"><a href="#增量-PCA（Incremental-PCA）" class="headerlink" title="增量 PCA（Incremental PCA）"></a>增量 PCA（Incremental PCA）</h5><p>有些算法如SVD需要在内存中处理整个训练集。可以将训练集分批，一次只对一个批量使用 IPCA 算法。这对大型训练集非常有用，并且可以在线应用 PCA（即在新实例到达时即时运行）。</p>
<h5 id="随机-PCA（Randomized-PCA）"><a href="#随机-PCA（Randomized-PCA）" class="headerlink" title="随机 PCA（Randomized PCA）"></a>随机 PCA（Randomized PCA）</h5><p>这是一种随机算法，可以快速找到前d个主成分的近似值。它的计算复杂度是<code>O(m × d^2) + O(d^3)</code>，而不是<code>O(m × n^2) + O(n^3)</code>，所以当<code>d</code>远小于<code>n</code>时，它比之前的算法快得多。</p>
<h4 id="核-PCA（Kernel-PCA）"><a href="#核-PCA（Kernel-PCA）" class="headerlink" title="核 PCA（Kernel PCA）"></a>核 PCA（Kernel PCA）</h4><p>核技巧，一种将实例隐式映射到非常高维空间（称为特征空间）的数学技术，让支持向量机可以应用于非线性分类和回归。高维特征空间中的线性决策边界对应于原始空间中的复杂非线性决策边界。</p>
<p>同样的技巧可以应用于 PCA，从而可以执行复杂的非线性投影来降低维度。这就是所谓的核 PCA（kPCA）。它通常能够很好地保留投影后的簇，有时甚至可以展开分布近似于扭曲流形的数据集。</p>
<p><strong>如何选择一种核并调整参数</strong></p>
<blockquote>
<ol>
<li>网格搜索</li>
<li>非监督学习</li>
</ol>
</blockquote>
<h4 id="局部线性嵌入（LLE）"><a href="#局部线性嵌入（LLE）" class="headerlink" title="局部线性嵌入（LLE）"></a>局部线性嵌入（LLE）</h4><p>局部线性嵌入（Locally Linear Embedding）是一种非线性降维（NLDR）方法。这是一种流形学习技术。</p>
<p>LLE 首先测量每个训练实例与其最近邻（c.n.）之间的线性关系，然后寻找能最好地保留这些局部关系的训练集的低维表示。</p>
<blockquote>
<p>擅长展开没有太多噪音的扭曲的流形。</p>
</blockquote>
<h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>对于每个训练实例 $x^{(i)}$，该算法识别其最近的<code>k</code>个邻居，然后尝试将 $x^{(i)}$重构为这些邻居的线性函数。找到权重 $w_{i,j}$从而使  $x^{(i)}$和 $\sum_{j=1}^{m}w_{i,j} x^{(j)}$之间的平方距离尽可能的小，假设如果 $x^{(j)}$不是 $x^{(i)}$的<code>k</code>个最近邻时 $w_{i,j}=0$。</p>
<p>第一步：对局部关系进行线性建模 </p>
<p>$W=argmin_w\ \sum_{i=1}^m | x^{(i)}-\sum_{j=1}^m w_{i,j}x^{(j)}| ^2 \\ subject \ to \ \left \{  \begin{array}{cc} w_{i,j}=0&amp;\ \ if \ x^{j} \  is \ not \ one \ of \ the \ k \ c.n. \ of \ x^{i} \\ \sum_{j=1}^m w_{i,j}=1&amp; for\ i=1,2, \cdots ,m\end{array}\right.$</p>
<p>第二个约束简单地对每个训练实例 $x^{(i)}$的权重进行归一化。</p>
<p>权重矩阵 $\widehat{W}$包含权重 $\hat{w_{i,j}}$]对训练实例的线形关系进行编码。第二步是将训练实例投影到一个<code>d</code>维空间（<code>d &lt; n</code>）中去，同时尽可能的保留这些局部关系。如果 $z^{(i)}$是 $x^{(i)}$]在这个<code>d</code>维空间的图像，那么需要 $z^{(i)}$和 $\sum_{j=1}^{m}\hat{w_{i,j}}\ z^{(j)}$之间的平方距离尽可能的小。看起来与第一步非常相似，但不是保持实例固定并找到最佳权重，而是<strong>保持权重不变，并在低维空间中找到实例图像的最佳位置</strong>。<code>Z</code>是包含所有 $z^{(i)}$]的矩阵。</p>
<p>第二步：保持关系的同时进行降维</p>
<p>$W=argmin_z\ \sum_{i=1}^m | z^{(i)}-\sum_{j=1}^m w_{i,j}z^{(j)}| ^2 $</p>
<p>Scikit-Learn 的 LLE 实现具有如下的计算复杂度：查找<code>k</code>个最近邻为<code>O(m log(m) n log(k))</code>，优化权重为<code>O(m n k^3)</code>，建立低维表示为<code>O(d m^2)</code>。</p>
<h4 id="其他降维方法"><a href="#其他降维方法" class="headerlink" title="其他降维方法"></a>其他降维方法</h4><ul>
<li>多维缩放（MDS）在尝试保持实例之间距离的同时降低了维度</li>
<li>Isomap 通过将每个实例连接到最近的邻居来创建图形，然后在尝试保持实例之间的测地距离时降低维度。</li>
<li>t-分布随机邻域嵌入（t-Distributed Stochastic Neighbor Embedding，<strong>t-SNE</strong>）可以用于降低维度，同时试图保持相似的实例临近并将不相似的实例分开。它主要用于可视化，尤其是用于可视化高维空间中的实例（例如，可以将MNIST图像降维到 2D 可视化）。</li>
<li>线性判别分析（Linear Discriminant Analysis，LDA）实际上是一种分类算法，但在训练过程中，它会学习类之间最有区别的轴，然后使用这些轴来定义用于投影数据的超平面。LDA 的好处是投影会尽可能地保持各个类之间距离，所以在运行另一种分类算法（如 SVM 分类器）之前，LDA 是很好的降维技术。</li>
</ul>
<h3 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h3><ol>
<li><p>减少数据集维度的主要动机是什么？主要缺点是什么？</p>
<blockquote>
<p>动机：</p>
<ol>
<li>加快训练速度(筛选掉一些噪音和不必要的细节，可能会让结果比降维之前更好)</li>
<li>数据可视化方面：降低特征维度到 2（或者 3）维从而可以在图中画出一个高维度的训练集，可以通过视觉直观的发现一些非常重要的信息</li>
<li>节省空间</li>
</ol>
<p>缺点：</p>
<ol>
<li>丢失一些信息，降低算法后续性能</li>
<li>使工作流水线更复杂因而更难维护</li>
<li>降低可解释性</li>
</ol>
</blockquote>
</li>
<li><p>什么是维度爆炸？</p>
<blockquote>
<p>维度爆炸是指高维空间中出现了许多低维空间不存在的问题，在机器学习中，一个常见的表现是，随机采样的高维向量通常非常稀疏，增加了过度拟合的风险，使得在没有大量训练数据的情况下很难识别数据中的模式。</p>
</blockquote>
</li>
<li><p>一旦对某数据集降维，我们可能恢复它吗？如果可以，怎样做才能恢复？如果不可以，为什么？</p>
<blockquote>
<p>一旦数据集通过降维降到了一个较小的维度，就几乎不会完全复现，因为在维度减小的过程中，损失了一部分信息，PCA有逆过程，可以重构一个和原始数据集比较相似的数据集，但是t-SNE没有。</p>
</blockquote>
</li>
<li><p>PCA 可以用于降低一个高度非线性对数据集吗？</p>
<blockquote>
<p>PCA可以显著降低大多数数据集的维数，即使他们是高度非线性的，因为它至少可以消除无用的维度，然而如果没有无用的维度，例如”瑞士卷”，使用PCA降维将会损失许多信息。</p>
</blockquote>
</li>
<li><p>假设你对一个 1000 维的数据集应用 PCA，同时设置方差解释率为 95%，你的最终数据集将会有多少维？</p>
<blockquote>
<p>取决于数据集</p>
<p>如果数据集由几乎完全对齐的点组成，该情况下，PCA可以把数据降到一维，并保持95%的方差结实率</p>
<p>如果数据集中的点完全随机，则该情况下，需要降到所有维度，并且每一维度都有95%的方差。</p>
<p><img src="https://img.cntofu.com/book/hands_on_Ml_with_Sklearn_and_TF/images/chapter_8/8-8.jpeg" alt="img"></p>
</blockquote>
</li>
<li><p>在什么情况下你会使用普通的 PCA，增量 PCA，随机 PCA 和核 PCA？</p>
<blockquote>
<p>一般默认使用普通的PCA，但它只在数据集适合内存的情况下工作。</p>
<p>增量PCA对于不适合内存的大型数据集有用，可以分批训练，一次只对一个批量使用 IPCA 算法。但它比常规PCA要慢，所以如果数据集适合内存应该选择常规的PCA。增量PCA也适用于在线任务，当不断有新实例到达，需要动态应用PCA时。</p>
<p>随机PCA：当想要大大减少维度并且数据集适合时，它比普通PCA快得多。</p>
<p>数据呈现复杂的高维非线性时，使用核PCA</p>
</blockquote>
</li>
<li><p>你该如何评价你的降维算法在你数据集上的表现？</p>
<blockquote>
<p>一个降维算法在不丢失太多信息的情况下从数据集中消除了大量的维数，那么它的性能就会很好。</p>
<p>一种测量方法是应用反向变换并测量重构误差。然而，并不是所有的降维算法都提供了反向转换。</p>
<p>如果将降维作为另一种机器学习算法前的预处理步骤，那么可以简单地测量第二种算法的性能;如果降维不会丢失太多信息，那么算法的性能应该与使用原始数据集时一样好。</p>
</blockquote>
</li>
<li><p>将两个不同的降维算法串联使用有意义吗？</p>
<blockquote>
<p>有</p>
<p>一个常见的例子是使用PCA快速摆脱大量无用的维数，然后应用另一种慢得多的降维算法，如LLE。这种分两步的方法可能会产生与仅使用LLE相同的性能，但大大缩短了时间。</p>
</blockquote>
</li>
<li><p>加载 MNIST 数据集（在第 3 章中介绍），并将其分成一个训练集和一个测试集（将前 60,000 个实例用于训练，其余 10,000 个用于测试）。在数据集上训练一个随机森林分类器，并记录了花费多长时间，然后在测试集上评估模型。接下来，使用 PCA 降低数据集的维度，设置方差解释率为 95%。在降维后的数据集上训练一个新的随机森林分类器，并查看需要多长时间。训练速度更快？接下来评估测试集上的分类器：它与以前的分类器比较起来如何？</p>
</li>
<li><p>使用 t-SNE 将 MNIST 数据集缩减到二维，并使用 Matplotlib 绘制结果图。您可以使用 10 种不同颜色的散点图来表示每个图像的目标类别。或者，您可以在每个实例的位置写入彩色数字，甚至可以绘制数字图像本身的降维版本（如果绘制所有数字，则可视化可能会过于混乱，因此您应该绘制随机样本或只在周围没有其他实例被绘制的情况下绘制）。你将会得到一个分隔良好的的可视化数字集群。尝试使用其他降维算法，如 PCA，LLE 或 MDS，并比较可视化结果。</p>
</li>
</ol>
<hr>
<h2 id="第09章-非监督学习"><a href="#第09章-非监督学习" class="headerlink" title="第09章 非监督学习"></a>第09章 非监督学习</h2><p>降维就是最常用的非监督机器学习方法之一。</p>
<h3 id="聚类（clustering）"><a href="#聚类（clustering）" class="headerlink" title="聚类（clustering）"></a>聚类（clustering）</h3><p>将相似的实例聚集在一起</p>
<p><strong>和分类的区别：分类问题有标签，而聚类问题没有标签。</strong></p>
<p><strong>应用场景：</strong></p>
<p>降维，半监督学习，图像分类，推荐系统，搜索引擎，客户细分等</p>
<p>也可以用于异常检测：数据聚类后，和所有cluster相聚很远的数据点可能是有问题的。</p>
<p>半监督学习：只有若干数据有标签，可以聚类后将标签传递给同一cluster</p>
<p>搜索引擎：例如搜索图片，将所有图片聚类，然后根据用户上传的图片，判断在哪一个cluster。</p>
<p>image segmentation：数据监测，追踪，监测物体的边界</p>
<blockquote>
<p> 参考：<a href="https://www.cnblogs.com/LittleHann/p/6595148.html" target="_blank" rel="noopener">https://www.cnblogs.com/LittleHann/p/6595148.html</a></p>
<p>​            <a href="https://zhuanlan.zhihu.com/p/150333968" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/150333968</a></p>
</blockquote>
<p>一些算法有中心：centroid （K-Means）</p>
<p>一些算法分层：hierarchical</p>
<p>一些算法基于密度：DBSCAN</p>
<p>一些算法基于概率：GMM（高斯混合模型）</p>
<h4 id="K-Means"><a href="#K-Means" class="headerlink" title="K-Means"></a>K-Means</h4><p>1957年，Stuart Lloyd在Bell Labs提出。该算法一般是最快的聚类方法，且一定会收敛，不会永远震荡。</p>
<p><strong>计算复杂度</strong>：一般情况下（数据具有clustering structure）和实例的个数m以及类的个数k呈线性关系。否则，最坏的情况，指数增长（一般很少发生）。</p>
<p><strong>算法：</strong></p>
<ol>
<li>初始化中心，然后将数据分到最近邻的类中。</li>
<li>把所有实例分到相应的类中，计算数据中心</li>
<li>按照新的中心，重新将实例分到相应的类中，计算数据中心</li>
<li>重复2,3，知道中心不发生变化</li>
</ol>
<p><strong>hard-clustering和soft-clustering</strong></p>
<p>hard-clustering将实例分到一个cluster中</p>
<p>soft-clustering给出每个实例在每一个cluster中的评分，可以是距离，或者RBF等等</p>
<p><strong>缺点：</strong></p>
<p>虽然K-Means一定会收敛，但是可能会收敛到局部最优解，和初始中心的设置有很大的关系。</p>
<p><strong>解决办法：</strong></p>
<p>初始化聚类中心的方法：</p>
<ol>
<li><p>提前知道大概的中心位置，可以用<code>init</code>参数传递给KMeans</p>
</li>
<li><p>多次运行kmeans，保留最好的结果。<code>n_init，</code>sklearn中默认为10，用intertia（所有实例距离其最近邻聚类中心的距离的平方和）判定好坏（越小越好）</p>
<blockquote>
<p>sklearn中的score遵循“greater is better”的准则，所以score是intertia的负数。</p>
</blockquote>
</li>
<li><p>改进算法：<strong>K-Means++</strong>（2006年，由David Arthur and Sergei Vassilvitskii提出）</p>
<blockquote>
<p>初始化聚类中心尽可能彼此远离，可以有效避免局部最优解。</p>
<ol>
<li>随机选取第一个中心$c^{(1)}$</li>
<li>以概率$D(x^{(i)})^2/\sum_{j=1}^m D(x^{(j)})^2$ 选取实例作为新的中心$c^{(i)}$，$D(x^{(i)})$表示实例距离已经选定的中心的距离。</li>
<li>重复2直到确定所有中心</li>
</ol>
</blockquote>
<p>sklearn中默认使用这种算法，可以通过设置<code>init=random</code>使用原生K-Means</p>
</li>
</ol>
<h4 id="加速K-Means算法"><a href="#加速K-Means算法" class="headerlink" title="加速K-Means算法"></a>加速K-Means算法</h4><blockquote>
<p>由Charles Elkan于2003年提出。利用<strong>三角不等式的性质（triangle inequality），记录实例和聚类中心距离的上限和下限（lower and upper bounds）加速K-Means，</strong>避免许多无用的距离计算.</p>
<p>sklearn中默认使用这种算法。</p>
</blockquote>
<h4 id="mini-batch-K-Means算法"><a href="#mini-batch-K-Means算法" class="headerlink" title="mini-batch K-Means算法"></a>mini-batch K-Means算法</h4><blockquote>
<p>2000年由David Sculley提出，可以处理内存处理不下的数据（也可以memmap），与regular K-Means相比，快3-4倍，但intertia较差。</p>
<p>sklearn中有MiniBatchKMeans类。</p>
</blockquote>
<h4 id="确定最佳类的个数"><a href="#确定最佳类的个数" class="headerlink" title="确定最佳类的个数"></a>确定最佳类的个数</h4><p>不能用intertia，因为类越多，intertia越小。选取intertia-k的肘部点。</p>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0908.png" alt="mls2 0908"></p>
<h4 id="silhouette-score（平均轮廓系数）"><a href="#silhouette-score（平均轮廓系数）" class="headerlink" title="silhouette score（平均轮廓系数）"></a><em>silhouette score（平均轮廓系数）</em></h4><p>silhouette score：所有实例silhouette efficient（轮廓系数）的平均。</p>
<p>轮廓系数（-1~1）：(b – a) / max(a, b)，a是同类中其他实例距离的平均（the mean intra-cluster distance），b是到最近邻类中其他实例的平均距离（the mean nearest-cluster distance ），接近+1,意味着实例都处于当前类中，接近-1，意味着实例被分类到了错误的类，接近0，意味着数据点在边界。</p>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0909.png" alt="mls2 0909"></p>
<p>还可以画出silhouette diagram：算出每个实例的轮廓系数，并将它们分到相应的类里：</p>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0910.png" alt="mls2 0910"></p>
<p>红色虚线表示silhouette score，凡是处于虚线左侧的刀型图，表示该类的实例和其他类距离过近。</p>
<p>k=4和5中类的大小不一样，4中橙色的类明显更大，而5中类更均匀，所以即使4的silhouette score更大，看上去5的表现更好。</p>
<h4 id="K-Means的局限性"><a href="#K-Means的局限性" class="headerlink" title="K-Means的局限性"></a>K-Means的局限性</h4><ol>
<li><p>需要提前跑几次，防止陷入过拟合</p>
</li>
<li><p>需要自己确定类的个数</p>
</li>
<li><p>当类的大小不均一，或者密度不一，或者分布不是球形时，表现不好</p>
<blockquote>
<p>椭圆分布（elliptical clusters），Gaussian mixture model表现更好</p>
<p>运行K-Means之前，scale the feature</p>
</blockquote>
</li>
</ol>
<h4 id="K-Means的具体应用"><a href="#K-Means的具体应用" class="headerlink" title="K-Means的具体应用"></a>K-Means的具体应用</h4><p><strong>图像分割</strong> <em>Image segmentation</em> ：将图像分成若干部分。</p>
<blockquote>
<ol>
<li>语义分割（semantic segmentation）</li>
<li>实例分割（instance segmentation）</li>
</ol>
<p>一般基于CNN实现。</p>
</blockquote>
<p>颜色分割（color segmentation）：应用场景：从卫星图计算森林面积的大小。</p>
<p><strong>数据预处理</strong></p>
<p>监督学习前使用K-Means对数据进行聚类。降低了数据的维度，更重要的是聚类得到的特征更加线性可分。</p>
<p><strong>用于半监督学习</strong></p>
<p>当有很多没有标签的数据时，可以使用K-Means对有标签的数据进行聚类，将最接近中心的图片（或其他）（representative image）表示出来。将标签传递给类中其他数据，这个过程叫做label  propagation。</p>
<blockquote>
<p>注意：边界上的数据点可能被错误的分类了，所以标签传递最好传递给距离聚类中心最近的一部分数据（比如20%）</p>
</blockquote>
<h4 id="主动学习-active-learning"><a href="#主动学习-active-learning" class="headerlink" title="主动学习(active learning)"></a>主动学习(active learning)</h4><p>不确定度采样<code>Uncertainty Sampling</code></p>
<ol>
<li>用仅有的有标签数据训练模型，用该模型预测所有无标签数据</li>
<li>将预测结果中最不准确（概率最低）的实例拿出来给专家贴标签</li>
<li>重复上述过程</li>
</ol>
<p>更深入了解可以参考：<a href="https://blog.csdn.net/qq_39856931/article/details/106433187" target="_blank" rel="noopener">https://blog.csdn.net/qq_39856931/article/details/106433187</a></p>
<h4 id="KNN和K-Means的区别"><a href="#KNN和K-Means的区别" class="headerlink" title="KNN和K-Means的区别"></a>KNN和K-Means的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>KNN</strong></th>
<th><strong>K-Means</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>1.KNN是分类算法  2.监督学习 3.喂给它的数据集是带label的数据，已经是完全正确的数据</td>
<td>1.K-Means是聚类算法  2.非监督学习 3.喂给它的数据集是无label的数据，是杂乱无章的，经过聚类后才变得有点顺序，先无序，后有序</td>
</tr>
<tr>
<td>没有明显的前期训练过程，属于memory-based learning</td>
<td>有明显的前期训练过程</td>
</tr>
<tr>
<td>K的含义：来了一个样本x，要给它分类，即求出它的y，就从数据集中，在x附近找离它最近的K个数据点，这K个数据点，类别c占的个数最多，就把x的label设为c</td>
<td>K的含义：K是人工固定好的数字，假设数据集合可以分为K个簇，由于是依靠人工定好，需要一点先验知识</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>相似点：都包含这样的过程，给定一个点，在数据集中找离它最近的点。即二者都用到了NN(Nears Neighbor)算法，一般用KD树来实现NN。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="DBSCAN（Density-Based-Spatial-Clustering-of-Applications-with-Noise）"><a href="#DBSCAN（Density-Based-Spatial-Clustering-of-Applications-with-Noise）" class="headerlink" title="DBSCAN（Density-Based Spatial Clustering of Applications with Noise）"></a>DBSCAN（Density-Based Spatial Clustering of Applications with Noise）</h4><p>基于局部密度估计（local density estimation），该算法允许对任意形状的数据进行聚类。</p>
<ol>
<li>对于每一个实例，算法计算一个小范围$\epsilon$ 内有多少实例，该范围叫做：实例的$\epsilon$-neighborhood</li>
<li>如果一个实例的$\epsilon$-neighborhood中有超过min_samples个实例，则该实例为core instance</li>
<li>所有在同一个core instance周围的实例属于同一个类，有可能一个core instance的周围有其他core instance。因此，一系列相邻的core instance形成一个cluster</li>
<li>任何实例，如果不是core instance，其相邻范围内也没有core instance，会被认为是异常数据</li>
</ol>
<p>当数据的可以被低密度区域分开时，DBSCAN变现得很好。</p>
<blockquote>
<p>sklearn中的DBSCAN没有predict方法，可以用DBSCAN的聚类中心（或者全部数据，或者除了异常数据的其他数据）训练其他算法（例如KNN），再预测新的数据。</p>
</blockquote>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0915.png" alt="mls2 0915"></p>
<p>其实有两个数据需要被判定为异常值。</p>
<p>DBSCAN是一个简单但是强大的聚类算法，可以对不规则形状分布的数据进行聚类，并且只有两个超参数eps和min_samples，但如果类中密度变化很大，DBSCAN的表现可能没有那么好。</p>
<p><strong>计算复杂度</strong>：O(m log m)</p>
<h4 id="其他聚类算法"><a href="#其他聚类算法" class="headerlink" title="其他聚类算法"></a>其他聚类算法</h4><h5 id="层次聚类-Agglomerative-clustering"><a href="#层次聚类-Agglomerative-clustering" class="headerlink" title="层次聚类(Agglomerative clustering)"></a>层次聚类(Agglomerative clustering)</h5><p>是一种自底而上的层次聚类方法，它能够根据指定的相似度或距离定义计算出类之间的距离。</p>
<ol>
<li>将每一个元素单独定为一类</li>
<li>重复：每一轮都合并指定距离(对指定距离的理解很重要)最小的类</li>
<li>直到所有的元素都归为同一类</li>
</ol>
<blockquote>
<p>类似水面上的泡泡，会与相邻的泡泡合并</p>
</blockquote>
<p>依据对相似度（距离）的不同定义，将Agglomerative Clustering的聚类方法分为三种：Single-linkage, Complete-linkage和Group average.<br><strong>Single-linkage</strong>:要比较的距离为元素对之间的最小距离<br><strong>Complete-linkage</strong>:要比较的距离为元素对之间的最大距离<br><strong>Group average</strong>：要比较的距离为类之间的平均距离（平均距离的定义与计算：假设有A，B两个类，A中有n个元素，B中有m个元素。在A与B中各取一个元素，可得到他们之间的距离。将nm个这样的距离相加，得到距离和。最后距离和除以nm得到A，B两个类的平均距离。）</p>
<h5 id="BIRCH"><a href="#BIRCH" class="headerlink" title="BIRCH"></a>BIRCH</h5><p>Balanced Iterative Reducing and Clustering using Hierarchies，利用层次方法的平衡迭代规约和聚类，针对large database，并且比batch-K Means快</p>
<p>BIRCH算法利用了一个树结构来帮助我们快速的聚类，这个数结构类似于平衡B+树，一般将它称之为聚类特征树(Clustering Feature Tree，简称CF Tree)。这颗树的每一个节点是由若干个聚类特征(Clustering Feature，简称CF)组成。</p>
<p>可参考：<a href="https://www.cnblogs.com/pinard/p/6179132.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6179132.html</a></p>
<h5 id="Mean-Shift"><a href="#Mean-Shift" class="headerlink" title="Mean-Shift"></a>Mean-Shift</h5><p>也叫做均值漂移，在目标追踪中应用广泛。本身其实是一种<strong>基于密度</strong>的聚类算法。</p>
<p>主要思路是：中心向着密度高的地方移动，直到移动到local density maximum</p>
<ol>
<li>计算某一实例(A)与其周围半径R内的向量距离的平均值M，计算出该点下一步漂移（移动）的方向（A=M+A）。</li>
<li>重复上述过程，直到所有的点不再移动时，其与周围点形成一个类簇，</li>
<li>计算这个类簇与历史类簇的距离，满足小于阈值D即合并为同一个类簇，不满足则自身形成一个类簇。直到所有的数据点选取完毕。</li>
</ol>
<blockquote>
<p>当簇的内部具有密度不均匀时，Mean-shift倾向于将该簇分为几片</p>
<p>计算复杂度：$O(m^2)$,不适合大的数据集</p>
</blockquote>
<h5 id="Affinity-propagation"><a href="#Affinity-propagation" class="headerlink" title="Affinity propagation"></a>Affinity propagation</h5><p>AP(Affinity Propagation)通常被翻译为近邻传播算法或者亲和力传播算法。</p>
<p><strong>一种投票机制</strong>，每个实例对相似的实例投票，选出代表（representatives）一旦算法收敛，每个代表和其投票者聚成一簇。</p>
<blockquote>
<p>计算复杂度：$O(m^2)$,不适合大的数据集</p>
<p>AP算法的基本思想是将全部数据点都当作潜在的聚类中心(称之为exemplar)，然后数据点两两之间连线构成一个网络(相似度矩阵)，再通过网络中各条边的消息(responsibility和availability)传递计算出各样本的聚类中心。</p>
<p>聚类过程中，共有两种消息在各节点间传递，分别是吸引度（responsibility）和归属度（availability）。</p>
<p>AP算法通过迭代过程不断更新每一个点的吸引度和归属度，直到产生m个高质量的Exemplar（相当于质心），同时将其余的数据点分配到相应的聚类中。</p>
<p>可参考：<a href="https://www.biaodianfu.com/affinity-propagation.html" target="_blank" rel="noopener">https://www.biaodianfu.com/affinity-propagation.html</a></p>
</blockquote>
<h5 id="谱聚类"><a href="#谱聚类" class="headerlink" title="谱聚类"></a>谱聚类</h5><p>Spectral clustering，它的主要思想是把所有的数据看做空间中的点，这些点之间可以用边连接起来。距离较远的两个点之间的边权重值较低，而距离较近的两个点之间的边权重值较高，通过对所有数据点组成的图进行切图，让切图后不同的子图间边权重和尽可能的低，而子图内的边权重和尽可能的高，从而达到聚类的目的。</p>
<h3 id="高斯混合模型-Gaussian-mixtures"><a href="#高斯混合模型-Gaussian-mixtures" class="headerlink" title="高斯混合模型 Gaussian mixtures"></a>高斯混合模型 Gaussian mixtures</h3><p><em>Gaussian mixture model</em> (GMM)：多个高斯分布的线性叠加能拟合非常复杂的密度函数；通过足够多的高斯分布叠加，并调节它们的均值，协方差矩阵，以及线性组合的系数，可以精确地逼近任意连续密度。</p>
<p> <code>GaussianMixture</code> class: 需要确定数据有几个高斯分布生成</p>
<blockquote>
<ol>
<li>对于每一个实例，从k个高斯分布（代表着k个簇）中随机选择，选择第j个高斯分布的概率$\phi^{(j)}$, 第i个实例选择的高斯分布记作$z^{(i)}$</li>
<li>如果$z^{(i)}=j$意味着第i个实例被分到了第j个簇中，实例$x^{(i)}~ N(\mu^{(j)},\sum^{(j)})$</li>
</ol>
</blockquote>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0916.png" alt="mls2 0916"></p>
<h4 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h4><p>sklearn中的类<code>GaussianMixture</code>依据的是EM算法。</p>
<blockquote>
<p>和K-Means算法类似</p>
<ol>
<li>expectation step</li>
</ol>
<p>计算每个实例属于各个簇的概率（软分类）</p>
<ol>
<li>maximization step</li>
</ol>
<p>迭代</p>
<p>EM同样会收敛到不好的结果，所以需要多跑几次，保存最好的结果，<code>n_init=10</code></p>
</blockquote>
<p>GMM是一个生成模型，可以用来生成新的实例。</p>
<p>还可以预测每个实例周围的密度，<code>score_samples()</code>方法，计算实例的PDF（probability density function）的l对数。</p>
<p>对于高维数据，GMM可能陷入困难，需要对模型加以限制（减少自由度，限制分布的形状，大小和取向），通过超参数<code>`covariance_type</code> `</p>
<blockquote>
<p>取值可以是：sphere，diag，tied default：full</p>
</blockquote>
<p><strong>计算复杂度</strong>：取决于实例的个数m，数据的维度n，以及簇的个数k，还有对协方差矩阵的限制。</p>
<blockquote>
<p>diag or spherical：$O(kmn)$</p>
<p>tied or full: $O()kmn^2+kn^3$</p>
</blockquote>
<h4 id="异常值检测"><a href="#异常值检测" class="headerlink" title="异常值检测"></a>异常值检测</h4><p>GMM用于异常值检测（anomaly detection）也叫做outlier detection。</p>
<blockquote>
<p>处在GMM低密度区域的实例可以被认为是异常值。可以自己规定阈值。</p>
</blockquote>
<p>观察学习“正常（normal）”的数据是什么样子的，来检测出异常数据（应用场景：生产线产品部件的检测&amp;异常访问）</p>
<h4 id="新颖性检测"><a href="#新颖性检测" class="headerlink" title="新颖性检测"></a>新颖性检测</h4><p>novelty detection：检测新观察是否是异常值。 在这种情况下，异常值也被称为新颖点（a novelty）。是一种半监督的异常检测方法，在新颖性检测的背景下，新颖点可以形成密集的簇，只要它们处于训练数据的低密度区域中。</p>
<p>GMM尝试fit所有的数据，包括异常值，如果异常点过多，可以</p>
<blockquote>
<ol>
<li>去除最外侧的异常值，在cleaned-up的数据集上再次训练模型</li>
<li>使用更鲁棒的算法：EllipticEnvelope （适合于对数据的鲁棒协方差估计，从而将椭圆适配到中央数据点，忽略中央模式之外的点。）</li>
</ol>
</blockquote>
<h4 id="如何确定cluster的个数"><a href="#如何确定cluster的个数" class="headerlink" title="如何确定cluster的个数"></a>如何确定cluster的个数</h4><p>对于大小不一致或者非球型分布的数据，K-Means中用来确定cluster数目的inertia和轮廓系数都不可行。</p>
<p>我们通过<strong>最小化理论信息标准（theoretical information criterion），如赤池信息量（<em>Akaike information criterion</em> ，AIC）,贝叶斯信息量（BIC，<em>Bayesian information criterion</em>）</strong></p>
<p>定义：(m是实例的个数，p是模型的参数，$\hat L$ 是模型似然函数（likelihood function）的最大值)</p>
<p>$BIC\ = \ \log(m)p-2\ \log(\hat L) \\ AIC  \ = 2p-2\ \log(\hat L)$</p>
<p>BIC和AIC对参数多模型加上penalty，一般情况下，BIC选择的模型比AIC简单，但是不如AIC的模型和数据吻合得好。</p>
<p><strong>似然函数</strong></p>
<p>概率（probability）是指：给定模型的参数，输出x的可信程度。（下图水平黑线，和PDF图）</p>
<p>似然（likelihood）是指：一直输出x的前提下，模型的参数有多可信。（下图垂直蓝色线，和似然函数图）</p>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0920.png" alt="mls2 0920"></p>
<h4 id="Bayesian-Gaussian-Mixture-Models"><a href="#Bayesian-Gaussian-Mixture-Models" class="headerlink" title="Bayesian Gaussian Mixture Models"></a>Bayesian Gaussian Mixture Models</h4><p>可以赋予不重要的簇权重0，可以通过n_components预设簇的最大值。</p>
<p><img src="https://learning.oreilly.com/library/view/hands-on-machine-learning/9781492032632/assets/mls2_0922.png" alt="mls2 0922"></p>
<p>Stick-Breaking Process (SBP)</p>
<p>Wishart distribution</p>
<p><strong>贝叶斯定理</strong></p>
<p>$p(z|X)=posterior=\frac{likelihood\times prior}{evidence}=\frac{p(X|z)p(z)}{p(X)}$</p>
<p>$p(X)=\int p(X|z)p(z)dz$</p>
<h3 id="其他处理异常值和新颖性检测的算法"><a href="#其他处理异常值和新颖性检测的算法" class="headerlink" title="其他处理异常值和新颖性检测的算法"></a>其他处理异常值和新颖性检测的算法</h3><h4 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h4><p>数据重建，正常值重建后与原始数据差距小，而异常值重建后与异常值差距大</p>
<h4 id="Fast-MCD"><a href="#Fast-MCD" class="headerlink" title="Fast-MCD"></a>Fast-MCD</h4><p>minimum covariance determinant，</p>
<p>认为正常值（inliers）是由单一的高斯模型产生的，不是由该单一高斯模型产生的数据点被认为是outliers</p>
<h4 id="Isolation-Forest"><a href="#Isolation-Forest" class="headerlink" title="Isolation Forest"></a>Isolation Forest</h4><p>孤立森林： 是一个基于Ensemble的快速异常检测方法，具有线性时间复杂度和高精准度，是符合大数据处理要求的state-of-the-art算法。适用于<strong>连续数据（Continuous numerical data）的异常检测</strong>，将异常定义为“容易被孤立的离群点 (more likely to be separated)”——可以理解为分布稀疏且离密度高的群体较远的点。</p>
<p>构建随机森林，其中每一个决策树都是随机的，在每个节点，随机的选择特征和阈值，将数据分为两个部分。</p>
<p>适用于高维数据</p>
<h4 id="Local-Outlier-Factoer（LOF）"><a href="#Local-Outlier-Factoer（LOF）" class="headerlink" title="Local Outlier Factoer（LOF）"></a>Local Outlier Factoer（LOF）</h4><p>一个样本点周围的样本点所处位置的平均密度比上该样本点所在位置的密度。比值越大于1，则该点所在位置的密度越小于其周围样本所在位置的密度，这个点就越有可能是异常点。</p>
<h4 id="One-class-SVM"><a href="#One-class-SVM" class="headerlink" title="One-class SVM"></a>One-class SVM</h4><p>单分类算法，寻找一个超平面将样本中的正例圈出来，预测就是用这个超平面做决策，在圈内的样本就认为是正样本。由于<strong>核函数</strong>计算比较耗时，在海量数据的场景用的并不多；</p>
<p><strong>适用于新颖性检测</strong></p>
<p><img src="https://img2018.cnblogs.com/blog/1226410/201904/1226410-20190424112057869-1957699378.png" alt="img"></p>
<h3 id="密度估计（density-estimation）"><a href="#密度估计（density-estimation）" class="headerlink" title="密度估计（density estimation）"></a>密度估计（density estimation）</h3><p>用来估计随机过程的概率密度函数（probability density function（PDF））（应用场景：异常检测（密度低的地方异常的概率大），数据分析和可视化）</p>
<h3 id="练习-3"><a href="#练习-3" class="headerlink" title="练习"></a>练习</h3><ol>
<li><p>How would you define clustering? Can you name a few clustering algorithms?</p>
<blockquote>
<p>聚类是一种无监督学习，将具有相似特征的实例聚集在一起。</p>
<p>K-Means, DBSCAN，层次聚类，BRICH，Mean-shift，Affinity propagation和谱聚类</p>
</blockquote>
</li>
<li><p>What are some of the main applications of clustering algorithms?</p>
<blockquote>
<p>半监督学习</p>
<p>图像分割</p>
<p>数据预处理</p>
<p>异常值检测</p>
<p>新颖性检测</p>
</blockquote>
</li>
<li><p>Describe two techniques to select the right number of clusters when using K-Means.</p>
<blockquote>
<ol>
<li>画出k-inertia图像，选择肘部</li>
<li>画出k-轮廓系数图像，选择最高点</li>
</ol>
</blockquote>
</li>
<li><p>What is label propagation? Why would you implement it, and how?</p>
<blockquote>
<p>因为打标签是非常耗时的，所以实际情况下，数据集中可能只有很少一部分有标签，大部分数据都没有标签，标签传递可以得到更多的带标签的数据，可以进行监督学习（这个过程就是非监督学习）</p>
<p>当数据中仅有少部分具有标签的数据时，可以先进行聚类，然后将标签打到具有相似特征的实例上（离聚类中心最近的有标签数据）。</p>
</blockquote>
</li>
<li><p>Can you name two clustering algorithms that can scale to large datasets? And two that look for regions of high density?</p>
<blockquote>
<p>K-Means和BRICH可以用于大的数据集</p>
<p>DBSCAN和Mean-shift（中心向着密度高的方向移动）寻找区域内高密度的位置</p>
</blockquote>
</li>
<li><p>Can you think of a use case where active learning would be useful? How would you implement it?</p>
<blockquote>
<p>不是随机的选择数据打标签，而是人类专家参与算法的学习，为特定的实例提供标签。</p>
<p>不确定采样</p>
</blockquote>
</li>
<li><p>What is the difference between anomaly detection and novelty detection?</p>
<blockquote>
<p>异常值检测中：模型在包含异常值的数据集上训练，（孤立森林）</p>
<p>新颖性检测中：模型在一个clean的数据及上训练，（单分类-SVM）</p>
</blockquote>
</li>
<li><p>What is a Gaussian mixture? What tasks can you use it for?</p>
<blockquote>
<p>GMM是一种概率模型，假设实例是由若干个高斯模型混合生成的。换句话说，假设数据属于若干椭圆类，但大小，方向，形状和密度都不确定。</p>
<p>可以用来密度检测，异常值检测，聚类。</p>
</blockquote>
</li>
<li><p>Can you name two techniques to find the right number of clusters when using a Gaussian mixture model?</p>
<blockquote>
<p>画出k-AIC或者k-BIC的图像，选择使AIC或者BIC数值最小的聚类个数。</p>
</blockquote>
</li>
<li><p>The classic Olivetti faces dataset contains 400 grayscale 64 × 64–pixel images of faces. Each image is flattened to a 1D vector of size 4,096. 40 different people were photographed (10 times each), and the usual task is to train a model that can predict which person is represented in each picture. Load the dataset using the <code>sklearn.datasets.fetch_olivetti_faces()</code> function, then split it into a training set, a validation set, and a test set (note that the dataset is already scaled between 0 and 1). Since the dataset is quite small, you probably want to use stratified sampling to ensure that there are the same number of images per person in each set. Next, cluster the images using K-Means, and ensure that you have a good number of clusters (using one of the techniques discussed in this chapter). Visualize the clusters: do you see similar faces in each cluster?</p>
</li>
<li><p>Continuing with the Olivetti faces dataset, train a classifier to predict which person is represented in each picture, and evaluate it on the validation set. Next, use K-Means as a dimensionality reduction tool, and train a classifier on the reduced set. Search for the number of clusters that allows the classifier to get the best performance: what performance can you reach? What if you append the features from the reduced set to the original features (again, searching for the best number of clusters)?</p>
</li>
<li><p>Train a Gaussian mixture model on the Olivetti faces dataset. To speed up the algorithm, you should probably reduce the dataset’s dimensionality (e.g., use PCA, preserving 99% of the variance). Use the model to generate some new faces (using the <code>sample()</code> method), and visualize them (if you used PCA, you will need to use its <code>inverse_transform()</code> method). Try to modify some images (e.g., rotate, flip, darken) and see if the model can detect the anomalies (i.e., compare the output of the <code>score_samples()</code> method for normal images and for anomalies).</p>
</li>
<li><p>Some dimensionality reduction techniques can also be used for anomaly detection. For example, take the Olivetti faces dataset and reduce it with PCA, preserving 99% of the variance. Then compute the reconstruction error for each image. Next, take some of the modified images you built in the previous exercise, and look at their reconstruction error: notice how much larger the reconstruction error is. If you plot a reconstructed image, you will see why: it tries to reconstruct a normal face.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>《利用Python进行数据分析》学习</title>
    <url>/2020/08/23/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>简书： <a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">https://www.jianshu.com/p/04d180d90a3f</a></p>
<p>github： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fiamseancheney%2Fpython_for_data_analysis_2nd_chinese_version" target="_blank" rel="noopener">https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version</a></p>
<p>gitbook： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseancheney.gitbook.io%2Fpython-for-data-analysis-2nd%2F" target="_blank" rel="noopener">https://seancheney.gitbook.io/python-for-data-analysis-2nd/</a></p>
<p>[TOC]</p>
<h2 id="第2章-Python语法基础，IPython和Jupyter-Notebooks"><a href="#第2章-Python语法基础，IPython和Jupyter-Notebooks" class="headerlink" title="第2章 Python语法基础，IPython和Jupyter Notebooks"></a>第2章 Python语法基础，IPython和Jupyter Notebooks</h2><h3 id="IPython键盘快捷键"><a href="#IPython键盘快捷键" class="headerlink" title="IPython键盘快捷键"></a>IPython键盘快捷键</h3><a id="more"></a>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e179f5ea00e50691.png?imageMogr2/auto-orient/strip|imageView2/2/w/491/format/webp" alt="img"></p>
<h3 id="IPython魔术命令"><a href="#IPython魔术命令" class="headerlink" title="IPython魔术命令"></a>IPython魔术命令</h3><p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。</p>
<p>line magic %</p>
<p>cell magic %%</p>
<p><code>%timeit</code>可以测量任何Python语句的执行时间：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">20.9</span> µs per loop</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c72b11add9b8ccf8.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp" alt="img"></p>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>IPython中集成了数据可视化和其它用户界面库，比如matplotlib。</p>
<p><code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。</p>
<p>在JUpyter中，命令有所不同：<code>%matplotlib inline</code></p>
<h3 id="Python语法基础"><a href="#Python语法基础" class="headerlink" title="Python语法基础"></a>Python语法基础</h3><h4 id="使用缩进"><a href="#使用缩进" class="headerlink" title="使用缩进"></a>使用缩进</h4><p>建议使用四个空格作为默认的缩进，可以使用tab代替四个空格。</p>
<h4 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h4><h4 id="位置和关键词参数"><a href="#位置和关键词参数" class="headerlink" title="位置和关键词参数"></a>位置和关键词参数</h4><p><code>result = f(a, b, c, d=5, e=&#39;foo&#39;)</code></p>
<h4 id="变量和参数传递："><a href="#变量和参数传递：" class="headerlink" title="变量和参数传递："></a>变量和参数传递：</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3e3a8c6b9c5040fc.png?imageMogr2/auto-orient/strip|imageView2/2/w/892/format/webp" alt="img"></p>
<p>在Python中，a和b实际上是同一个对象.赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
<p>将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。</p>
<h4 id="强类型化语言"><a href="#强类型化语言" class="headerlink" title="强类型化语言"></a>强类型化语言</h4><p><code>&#39;5&#39; + 5</code> 会报错，即每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">17</span>]: a = <span class="number">4.5</span></span><br><span class="line">In [<span class="number">18</span>]: b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># String formatting, to be visited later</span></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'a is &#123;0&#125;, b is &#123;1&#125;'</span>.format(type(a), type(b)))</span><br><span class="line">a is &lt;class 'float'&gt;, b is &lt;class 'int'&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a / b</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">2.25</span></span><br></pre></td></tr></table></figure>
<p>可以用<code>isinstance</code>函数检查对象是某个类型的实例。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">isinstance(a, int) <span class="comment">#检查对象是否是某个类型的实例</span></span><br><span class="line">isinstance(a, (int, float)) <span class="comment">#检查对象的类型是否在元组中</span></span><br></pre></td></tr></table></figure>
<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）</p>
<p>可以用<code>obj.attribute_name</code>访问属性和方法，也可以用<code>getattr</code>函数，通过名字访问属性和方法。</p>
<h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。</p>
<p>通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isiterable</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        iter(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>可以用这个功能编写可以接受多种输入类型的函数。例如编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。先检验对象是否是列表（或是NUmPy数组），如果不是，将其转变成列表：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法，<code>is not</code>可以判断两个对象是不同的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">35</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: c = list(a) <span class="comment"># 因为list总是创建一个新的Python列表（即复制）</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br><span class="line">       </span><br><span class="line">In [<span class="number">40</span>]: a == c</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9fb5f25b33166acf.png?imageMogr2/auto-orient/strip|imageView2/2/w/811/format/webp" alt="img"></p>
<h4 id="可变与不可变对象"><a href="#可变与不可变对象" class="headerlink" title="可变与不可变对象"></a>可变与不可变对象</h4><p>Python中的大多数对象，如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的，意味着这些对象或包含的值可以被修改。其它例如<strong>字符串和元组</strong> ，是不可变的。</p>
<h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型。</p>
<p>日期和时间处理会是由标准库的<code>datetime</code>模块提供的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-27a30ac3e7d262a1.png?imageMogr2/auto-orient/strip|imageView2/2/w/808/format/webp" alt="img"></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p>Python的主要数值类型是<code>int</code>和<code>float</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>反斜杠是转义字符，意思是它被用来表示特殊字符。</p>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，可以在字符串前面加一个r，表明字符就是它自身。</p>
<p>字符串的模板化或格式化：</p>
<ol>
<li><p><code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">74</span>]: template = <span class="string">'&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;'</span></span><br><span class="line">In [<span class="number">75</span>]: template.format(<span class="number">4.5560</span>, <span class="string">'Argentine Pesos'</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">'4.56 Argentine Pesos are worth US$1'</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="字节和Unicode"><a href="#字节和Unicode" class="headerlink" title="字节和Unicode"></a>字节和Unicode</h4><p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。</p>
<p>可以用<code>encode</code>将Unicode字符串编码为UTF-8，<code>decode</code> 将UTF-8解码为Unicode编码。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">76</span>]: val = <span class="string">"español"</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: val</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">'español'</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">78</span>]: val_utf8 = val.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">b'espa\xc3\xb1ol'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: type(val_utf8)</span><br><span class="line">Out[<span class="number">80</span>]: bytes</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: val_utf8.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">Out[<span class="number">81</span>]: <span class="string">'español'</span></span><br></pre></td></tr></table></figure>
<p><strong>可以在字节文本前加上b</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">85</span>]: bytes_val = <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: decoded = bytes_val.decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: decoded  <span class="comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">'this is bytes'</span></span><br></pre></td></tr></table></figure>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None，None也常常作为函数的默认参数。</p>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: dt.day</span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="number">105</span>]: <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="number">106</span>]: datetime.date(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="number">107</span>]: datetime.time(<span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>
<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">108</span>]: dt.strftime(<span class="string">'%m/%d/%Y %H:%M'</span>)</span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'10/29/2011 20:30'</span></span><br></pre></td></tr></table></figure>
<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">109</span>]: datetime.strptime(<span class="string">'20091031'</span>, <span class="string">'%Y%m%d'</span>)</span><br><span class="line">Out[<span class="number">109</span>]: datetime.datetime(<span class="number">2009</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-100f9a20c1536553.png?imageMogr2/auto-orient/strip|imageView2/2/w/692/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># repalce进行替换</span></span><br><span class="line">In [<span class="number">110</span>]: dt.replace(minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">110</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 两个datetime对象的差会产生一个datetime.timedelta类型：</span></span><br><span class="line">In [<span class="number">111</span>]: dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line">In [<span class="number">112</span>]: delta = dt2 - dt</span><br><span class="line">In [<span class="number">113</span>]: delta</span><br><span class="line">Out[<span class="number">113</span>]: datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>) <span class="comment"># 17天、7179秒</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: type(delta)</span><br><span class="line">Out[<span class="number">114</span>]: datetime.timedelta</span><br><span class="line"><span class="comment"># 可以将timedelta添加到datetime，产生一个新的偏移datetime </span></span><br><span class="line">In [<span class="number">115</span>]: dt</span><br><span class="line">Out[<span class="number">115</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="number">116</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>
<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><h5 id="if语句："><a href="#if语句：" class="headerlink" title="if语句："></a>if语句：</h5><p>if elif else</p>
<h5 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h5><p>可以用continue使for循环提前，跳过剩下的部分；可以用<code>break</code>跳出for循环，break只中断for循环的最内层，其余的for循环仍会运行。</p>
<h5 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h5><h5 id="pass："><a href="#pass：" class="headerlink" title="pass："></a>pass：</h5><p>Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass。</p>
<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p>Python中的三元表达式可以将if-else语句放到一行里，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>
<h2 id="第3章-Python的数据结构、函数和文件"><a href="#第3章-Python的数据结构、函数和文件" class="headerlink" title="第3章 Python的数据结构、函数和文件"></a>第3章 Python的数据结构、函数和文件</h2><h3 id="数据结构和序列"><a href="#数据结构和序列" class="headerlink" title="数据结构和序列"></a>数据结构和序列</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是一个固定长度，不可改变的Python序列对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建元组</span></span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="comment"># 当用复杂的表达式定义元组，最好将值放到圆括号内</span></span><br><span class="line">nested_tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 用tuple可以将任意序列或迭代器转换成元组</span></span><br><span class="line">tuple([<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>]) <span class="comment"># (4, 0, 2)</span></span><br><span class="line">tup = tuple(<span class="string">'string'</span>) <span class="comment"># ('s', 't', 'r', 'i', 'n', 'g')</span></span><br><span class="line"><span class="comment"># 可以用方括号访问元组中的元素，序列是从0开始</span></span><br><span class="line">tup[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改</span></span><br><span class="line">tup = tuple([<span class="string">'foo'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="literal">True</span>])</span><br><span class="line">tup[<span class="number">2</span>] = <span class="literal">False</span>  <span class="comment"># 会报错</span></span><br><span class="line"><span class="comment"># 如果元组中的某个对象是可变的，比如列表，可以在原位进行修改</span></span><br><span class="line">tup[<span class="number">1</span>].append(<span class="number">3</span>) <span class="comment"># ('foo', [1, 2, 3], True)</span></span><br><span class="line"><span class="comment"># 可以用加号运算符将元组串联起来</span></span><br><span class="line">(<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>) + (<span class="number">6</span>, <span class="number">0</span>) + (<span class="string">'bar'</span>,) <span class="comment"># (4, None, 'foo', 6, 0, 'bar')</span></span><br><span class="line"><span class="comment"># 元组乘以一个整数，像列表一样，会将几个元组的复制串联起来</span></span><br><span class="line">(<span class="string">'foo'</span>, <span class="string">'bar'</span>) * <span class="number">4</span> <span class="comment"># ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')</span></span><br><span class="line"><span class="comment"># 对象本身并没有被复制，只是引用了它</span></span><br></pre></td></tr></table></figure>
<h5 id="拆分元组"><a href="#拆分元组" class="headerlink" title="拆分元组"></a>拆分元组</h5><p>将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">a,b,c = tup</span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">a, b, (c, d) = tup</span><br><span class="line"><span class="comment"># 变量拆分常用来迭代元组或列表序列</span></span><br><span class="line">seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 另一个常见用法是从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级的元组拆分功能，例如，从元组的开头“摘取”几个元素。它使用了特殊的语法*rest</span></span><br><span class="line">values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, *rest = values</span><br><span class="line">rest <span class="comment"># [3, 4, 5]</span></span><br><span class="line"><span class="comment"># rest的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</span></span><br><span class="line">a, b, *_ = values</span><br></pre></td></tr></table></figure>
<p>在Python中，替换可以这样做:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure>
<h5 id="tuple方法"><a href="#tuple方法" class="headerlink" title="tuple方法"></a>tuple方法</h5><p>元组的大小和内容不能修改，所以其实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>
<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表的长度可变、内容可以被修改。可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">None</span>]</span><br><span class="line">tup = (<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>)</span><br><span class="line">b_list = list(tup) <span class="comment"># ['foo', 'bar', 'baz']</span></span><br></pre></td></tr></table></figure>
<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gen = range(<span class="number">10</span>)</span><br><span class="line">list(gen) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>
<p><code>append</code>在列表末尾添加元素</p>
<p><code>insert</code>在特定的位置插入元素，插入的序号必须在0和列表长度之间</p>
<p><strong>注意：</strong> 警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为需要对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，可以使用双尾部队列<code>collections.deque</code>。</p>
<p><code>pop</code>, <code>insert</code>的逆运算，移除并返回指定位置的元素</p>
<p><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去</p>
<p><strong>注意：</strong> 如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p><code>in</code> 和<code>not in</code>检查列表是否包含某个值， </p>
<p><strong>注意：</strong> 在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）</p>
<h5 id="串联和组合列表"><a href="#串联和组合列表" class="headerlink" title="串联和组合列表"></a>串联和组合列表</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用加号将两个列表串联起来</span></span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>] + [<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 用extend方法可以追加多个元素</span></span><br><span class="line">x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>]</span><br><span class="line">x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment">## 通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用extend追加元素，尤其是到一个大列表中，更为可取。</span></span><br></pre></td></tr></table></figure>
<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用sort函数将一个列表原地排序（不创建新的对象）</span></span><br><span class="line">a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment"># sort 二级排序key</span></span><br><span class="line">b = [<span class="string">'saw'</span>, <span class="string">'small'</span>, <span class="string">'He'</span>, <span class="string">'foxes'</span>, <span class="string">'six'</span>]</span><br><span class="line">b.sort(key=len)</span><br><span class="line"><span class="comment"># sorted函数，它可以产生一个排好序的序列副本</span></span><br></pre></td></tr></table></figure>
<h5 id="二分搜索和维护已排序的列表"><a href="#二分搜索和维护已排序的列表" class="headerlink" title="二分搜索和维护已排序的列表"></a>二分搜索和维护已排序的列表</h5><p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># bisect.bisect可以找到插入值后仍保证排序的位置</span></span><br><span class="line">bisect.bisect(c, <span class="number">5</span>) <span class="comment"># 6</span></span><br><span class="line"><span class="comment"># bisect.insort向这个位置插入值</span></span><br><span class="line">bisect.insort(c, <span class="number">6</span>)</span><br><span class="line"><span class="comment">##  bisect模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用bisect不会产生错误，但结果不一定正确。</span></span><br></pre></td></tr></table></figure>
<h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">seq[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># [2, 3, 7, 5]</span></span><br><span class="line"><span class="comment"># 切片也可以被序列赋值</span></span><br><span class="line">seq[<span class="number">3</span>:<span class="number">4</span>] = [<span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># start或stop都可以被省略，省略之后，分别默认序列的开头和结尾</span></span><br><span class="line">seq[<span class="number">3</span>:] </span><br><span class="line"><span class="comment"># 负数表明从后向前切片</span></span><br><span class="line">seq[<span class="number">-4</span>:]  <span class="comment"># [5, 6, 0, 1]</span></span><br><span class="line"><span class="comment"># 第二个冒号后面使用step，可以隔几个取一个元素</span></span><br><span class="line">seq[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用-1，它可以将列表或元组颠倒过来</span></span><br><span class="line">seq[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-522e2b688b755ff3.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h4><p>Python有一些有用的序列函数。</p>
<h5 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h5><p>迭代一个序列时，想要跟踪当前项的序号，可以使用Python内建的<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">some_list = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">mapping <span class="comment">#  &#123;'bar': 1, 'baz': 2, 'foo': 0&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h5><p>返回一个<strong>新的</strong> 排好序的列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">b = sorted(a)</span><br><span class="line">b <span class="comment"># [0, 1, 2, 2, 3, 6, 7]</span></span><br><span class="line">a <span class="comment"># [7, 1, 2, 6, 0, 3, 2]</span></span><br></pre></td></tr></table></figure>
<h5 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h5><p>将多个列表、元组或其它序列成对组合成一个元组列表。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">seq1 = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">seq2 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">zipped = zip(seq1, seq2)</span><br><span class="line">list(zipped) <span class="comment"># [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]</span></span><br><span class="line"><span class="comment"># zip可以处理任意多的序列，元素的个数取决于最短的序列</span></span><br><span class="line">seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line">list(zip(seq1, seq2, seq3)) <span class="comment">#  [('foo', 'one', False), ('bar', 'two', True)]</span></span><br></pre></td></tr></table></figure>
<p><code>zip</code>可以被用来解压序列</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pitchers = [(<span class="string">'Nolan'</span>, <span class="string">'Ryan'</span>), (<span class="string">'Roger'</span>, <span class="string">'Clemens'</span>), (<span class="string">'Schilling'</span>, <span class="string">'Curt'</span>)]</span><br><span class="line">first_names, last_names = zip(*pitchers)</span><br><span class="line">first_names  <span class="comment"># ('Nolan', 'Roger', 'Schilling')</span></span><br><span class="line">last_names   <span class="comment"># ('Ryan', 'Clemens', 'Curt')</span></span><br></pre></td></tr></table></figure>
<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(seq1, seq2)):     </span><br><span class="line">    print(<span class="string">'&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'</span>.format(i, a, b))</span><br><span class="line"><span class="number">0</span>: foo, one</span><br><span class="line"><span class="number">1</span>: bar, two</span><br><span class="line"><span class="number">2</span>: baz, three</span><br></pre></td></tr></table></figure>
<h5 id="reversed函数"><a href="#reversed函数" class="headerlink" title="reversed函数"></a>reversed函数</h5><p><code>reversed</code>是一个生成器（zip也是），可以从后向前迭代一个序列。注意：只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list(reversed(range(<span class="number">10</span>))) <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>也称为：哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由&#123;&#125;定义</span></span><br><span class="line">d1 = &#123;<span class="string">'a'</span> : <span class="string">'some value'</span>, <span class="string">'b'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">d1[<span class="number">7</span>] = <span class="string">'an integer'</span></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">d1[<span class="string">'b'</span>]  <span class="comment"># [1,2,3,4]</span></span><br><span class="line"><span class="comment"># 检查字典中是否包含某个键</span></span><br><span class="line"><span class="string">'b'</span> <span class="keyword">in</span> d1</span><br><span class="line"><span class="comment"># 用del关键字或pop方法（返回值的同时删除键）删除值</span></span><br><span class="line"><span class="keyword">del</span> d1[<span class="string">'b'</span>]</span><br><span class="line">ret = d1.pop(<span class="string">'b'</span>)  <span class="comment"># ret: [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># keys和values是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</span></span><br><span class="line">list(d1.keys()) <span class="comment"># ['a', 'b', 7]</span></span><br><span class="line">list(d1.values()) <span class="comment"># ['some value', [1, 2, 3, 4], 'an integer']</span></span><br><span class="line"><span class="comment"># update方法可以将一个字典与另一个融合</span></span><br><span class="line">d1.update(&#123;<span class="string">'b'</span> : <span class="string">'foo'</span>, <span class="string">'c'</span> : <span class="number">12</span>&#125;) <span class="comment"># 键'b'对应的值会改变</span></span><br><span class="line"><span class="comment"># update方法是原地改变字典，任何传递给update的键的旧的值都会被舍弃。</span></span><br></pre></td></tr></table></figure>
<h5 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h5><p>将两个序列配对组合成字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zip(key_list, value_list):</span><br><span class="line">    mapping[key] = val</span><br></pre></td></tr></table></figure>
<p>字典本质上是2元元组的集合，所以dict可以接受2元元组的列表</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">mapping = dict(zip(range(<span class="number">5</span>), reversed(range(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>
<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>dict的方法get和pop可以取默认值进行返回。get默认会返回None，如果不存在键，pop会抛出一个例外。</p>
<p><code>value = some_dict.get(key, default_value)</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">words = [<span class="string">'apple'</span>, <span class="string">'bat'</span>, <span class="string">'bar'</span>, <span class="string">'atom'</span>, <span class="string">'book'</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure>
<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure>
<h5 id="有效的键对类型"><a href="#有效的键对类型" class="headerlink" title="有效的键对类型"></a>有效的键对类型</h5><p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为<strong>“可哈希性”</strong> 。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>无序的不可重复的元素的集合。可看成只有键没有值的字典。可以通过set函数或使用尖括号set语句创建集合：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">set([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]) <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125; <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>
<p>集合支持合并、交集、差分和对称差等数学集合运算。</p>
<h5 id="合并（union方法，或者-运算符）"><a href="#合并（union方法，或者-运算符）" class="headerlink" title="合并（union方法，或者|运算符）"></a>合并（<code>union</code>方法，或者<code>|</code>运算符）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.union(b) <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">a | b <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br></pre></td></tr></table></figure>
<h5 id="交集（intersection或-amp-运算符）"><a href="#交集（intersection或-amp-运算符）" class="headerlink" title="交集（intersection或&amp;运算符）"></a>交集（<code>intersection</code>或<code>&amp;</code>运算符）</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a.intersection(b) <span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">a &amp; b <span class="comment"># &#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-980efe5d98ecc4d6.png?imageMogr2/auto-orient/strip|imageView2/2/w/695/format/webp" alt="img"></p>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容，对于大的集合，这么做效率更高：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">c = a.copy()  <span class="comment"># 硬copy</span></span><br><span class="line">c |= b</span><br><span class="line">d = a.copy()</span><br><span class="line">d &amp;= b</span><br></pre></td></tr></table></figure>
<p>与字典的键类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">my_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_set = &#123;tuple(my_data)&#125;</span><br><span class="line"><span class="comment"># 直接 my_set = &#123;[1, 2, 3, 4]&#125; 会报错</span></span><br></pre></td></tr></table></figure>
<h5 id="列表，集合和字典推导式"><a href="#列表，集合和字典推导式" class="headerlink" title="列表，集合和字典推导式"></a>列表，集合和字典推导式</h5><p>该特性允许用户从一个集合过滤元素，形成列表，集合或字典，在传递参数的过程中还可以修改元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">[expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict_comp = &#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">loc_mapping = &#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(strings)&#125;</span><br><span class="line"><span class="comment"># 集合推导式</span></span><br><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># map函数</span></span><br><span class="line">strings = [<span class="string">'a'</span>, <span class="string">'as'</span>, <span class="string">'bat'</span>, <span class="string">'car'</span>, <span class="string">'dove'</span>, <span class="string">'python'</span>]</span><br><span class="line">unique_lengths = &#123;len(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line">set(map(len, strings)) <span class="comment"># map 返回可迭代器，也可以list(map(len,strings))</span></span><br></pre></td></tr></table></figure>
<h5 id="嵌套列表推导式"><a href="#嵌套列表推导式" class="headerlink" title="嵌套列表推导式"></a>嵌套列表推导式</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">all_data = [[<span class="string">'John'</span>, <span class="string">'Emily'</span>, <span class="string">'Michael'</span>, <span class="string">'Mary'</span>, <span class="string">'Steven'</span>],[<span class="string">'Maria'</span>, <span class="string">'Juan'</span>, <span class="string">'Javier'</span>, <span class="string">'Natalia'</span>, <span class="string">'Pilar'</span>]]</span><br><span class="line">result = [name <span class="keyword">for</span> names <span class="keyword">in</span> all_data <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> name.count(<span class="string">'e'</span>) &gt;= <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将一个整数元组的列表扁平化成了一个整数列表</span></span><br><span class="line">some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line">[[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples] <span class="comment"># 这样产生一个列表</span></span><br><span class="line"><span class="comment"># for表达式的顺序是与嵌套for循环的顺序一样</span></span><br><span class="line">flattened = []</span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是Python中最主要也是最重要的<strong>代码组织和复用手段</strong> 。如果要<strong>重复使用相同或非常类似的代码</strong>，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：可以同时拥有多条return语句。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(x, y, z=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br><span class="line"><span class="comment"># z是关键字参数</span></span><br><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 关键字参数必须位于位置参数（如果有的话）之后，关键字参数顺序可以随便</span></span><br></pre></td></tr></table></figure>
<h4 id="命名空间、作用域和局部函数"><a href="#命名空间、作用域和局部函数" class="headerlink" title="命名空间、作用域和局部函数"></a>命名空间、作用域和局部函数</h4><p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）</p>
<p>Python中命名空间（namespace）用于描述变量作用域的名称。任何在函数中赋值的变量默认都被分配到局部命名空间（local namespace）中。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line">    <span class="comment">#return &#123;'a' : a, 'b' : b, 'c' : c&#125; #也可以返回字典</span></span><br></pre></td></tr></table></figure>
<p>该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。</p>
<h4 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h4><p>数据清洗：</p>
<p>为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">clean_strings(states)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line">clean_strings(states, clean_ops)</span><br></pre></td></tr></table></figure>
<h4 id="匿名（lambda）函数"><a href="#匿名（lambda）函数" class="headerlink" title="匿名（lambda）函数"></a>匿名（lambda）函数</h4><p>Python支持一种被称为匿名函数（lambda函数，这种函数对象本身是没有提供名称<strong>name</strong>属性）。仅由单条语句组成，该语句的结果就是返回值。通过lambda关键字定义的，该关键字没有含义，仅仅表明“正在声明的是一个匿名函数”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h4><p>柯里化（currying）是一个计算机科学术语，是指通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有一个执行两数相加的简单函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 通过这个函数，可以派生出一个新的只有一个参数的函数</span></span><br><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br><span class="line"><span class="comment"># add_numbers的第二个参数称为“柯里化的”（curried）</span></span><br></pre></td></tr></table></figure>
<p>本质上是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>
<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>Python可以以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，是一个原生的使对象可迭代的方法。</p>
<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器。</p>
<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squares</span><span class="params">(n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Generating squares from 1 to &#123;0&#125;'</span>.format(n ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">              </span><br><span class="line"><span class="comment"># 调用该生成器时，没有任何代码会被立即执行</span></span><br><span class="line">gen = squares()</span><br><span class="line"><span class="comment"># 直到从该生成器中请求元素时，它才会开始执行其代码</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">    print(x,end=<span class="string">' '</span> )</span><br></pre></td></tr></table></figure>
<h5 id="生成器表达式（generator-expression）"><a href="#生成器表达式（generator-expression）" class="headerlink" title="生成器表达式（generator expression）"></a>生成器表达式（generator expression）</h5><p>另一种更简洁的构造生成器的方法。类似于列表、字典、集合推导式的生成器。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其创建方式为，把列表推导式两端的方括号改成圆括号</span></span><br><span class="line">gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = _make_gen()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成器表达式也可以取代列表推导式，作为函数参数</span></span><br><span class="line">sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line">dict((i, i **<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>
<h5 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h5><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的<strong>连续元素进行分组</strong> 。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">'Alan'</span>, <span class="string">'Adam'</span>, <span class="string">'Wes'</span>, <span class="string">'Will'</span>, <span class="string">'Albert'</span>, <span class="string">'Steven'</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    print(letter, list(names)) <span class="comment"># names is a generator</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-111823d8767a104d.png?imageMogr2/auto-orient/strip|imageView2/2/w/696/format/webp" alt="img"></p>
<h4 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 只想处理ValueError，其他错误可能是合理的bug    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="comment"># another thing  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以用元组包含多个异常    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##  不想抑制异常，无论try部分的代码是否成功，都执行一段代码   </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子</span></span><br><span class="line">f = open(path, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Succeeded'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>
<h4 id="IPython的异常"><a href="#IPython的异常" class="headerlink" title="IPython的异常"></a>IPython的异常</h4><p>在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文。</p>
<p>IPython中以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h3 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">path = <span class="string">'examples/segismundo.txt'</span></span><br><span class="line">f = open(path)</span><br></pre></td></tr></table></figure>
<p>默认情况下，文件是以只读模式（’r’）打开的。然后，可以像处理列表那样来处理文件句柄f，比如对行进行迭代：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 还可以</span></span><br><span class="line">lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> open(path)]</span><br></pre></td></tr></table></figure>
<p>从文件中取出的行都带有完整的行结束符（EOL）。</p>
<p>使用open创建文件对象，一定要用close关闭。关闭文件可以返回操作系统资源。</p>
<p>用with语句可以在退出代码块时，自动关闭文件，更容易地清理打开的文件：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-28274484129f0ea7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="常用方法-read、seek、tell"><a href="#常用方法-read、seek、tell" class="headerlink" title="常用方法 read、seek、tell"></a>常用方法 read、seek、tell</h4><p>read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = open(path)</span><br><span class="line">f.read(<span class="number">10</span>) <span class="comment"># 'Sueña el r'</span></span><br><span class="line"></span><br><span class="line">f2 = open(path, <span class="string">'rb'</span>)  <span class="comment"># Binary mode</span></span><br><span class="line">f2.read(<span class="number">10</span>) <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</span></span><br><span class="line">f.tell() <span class="comment"># 11</span></span><br><span class="line">f2.tell() <span class="comment"># 10</span></span><br><span class="line"><span class="comment"># seek将文件位置更改为文件中的指定字节</span></span><br><span class="line">f.seek(<span class="number">3</span>) <span class="comment"># 3</span></span><br><span class="line">f.read(<span class="number">1</span>) <span class="comment"># ñ</span></span><br></pre></td></tr></table></figure>
<p>向文件写入，可以使用文件的write或writelines方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'tmp.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    handle.writelines(x <span class="keyword">for</span> x <span class="keyword">in</span> open(path) <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建一个无空行版文件</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d25bd6e730afeb39.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="文件的字节和Unicode"><a href="#文件的字节和Unicode" class="headerlink" title="文件的字节和Unicode"></a>文件的字节和Unicode</h4><p>Python文件的默认操作是“文本模式”，即处理Python的字符串（即Unicode）。二进制模式需要在文件模式后加一个b。</p>
<p>UTF-8是长度可变的Unicode编码，当从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    chars = f.read(<span class="number">10</span>)  <span class="comment"># 'Sueña el r'</span></span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read(<span class="number">10</span>)   <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"><span class="comment"># 可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</span></span><br><span class="line">    data.decode(<span class="string">'utf8'</span>) <span class="comment"># 'Sueña el '</span></span><br><span class="line"><span class="comment"># 不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</span></span><br></pre></td></tr></table></figure>
<h2 id="第4章-NumPy基础：数组和矢量计算"><a href="#第4章-NumPy基础：数组和矢量计算" class="headerlink" title="第4章 NumPy基础：数组和矢量计算"></a>第4章 NumPy基础：数组和矢量计算</h2><p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<h3 id="多维数组对象ndarray"><a href="#多维数组对象ndarray" class="headerlink" title="多维数组对象ndarray"></a>多维数组对象ndarray</h3><p>ndarray是一个通用的同构数据多维容器，所有元素必须是相同类型的。</p>
<h4 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用np.array函数创建。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组</span></span><br><span class="line">data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line"><span class="comment"># 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</span></span><br><span class="line">data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line"><span class="comment"># 属性：dtype，shape，ndim</span></span><br></pre></td></tr></table></figure>
<p>zeros, ones和empty可以创建指定长度或形状的全0，全1或者一个没有任何具体值的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>)</span><br><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>
<p>arange是Python内置函数range的数组版</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip|imageView2/2/w/696/format/webp" alt="img"></p>
<p>如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<h4 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h4><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line">arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以通过ndarray的<code>astype</code>方法将一个数组从一个dtype转换成另一个dtype</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype('int64')</span></span><br><span class="line">float_arr = arr.astype(np.float64) <span class="comment"># 也可以写float，NumPy会将Python类型映射到等价的dtype上。也可用简洁类型代码表示dtype，f4</span></span><br><span class="line"><span class="comment"># 如果将浮点数转换成整数，则小数部分将会被截取删除</span></span><br><span class="line"><span class="comment"># 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式</span></span><br><span class="line">numeric_strings = np.array([<span class="string">'1.25'</span>, <span class="string">'-9.6'</span>, <span class="string">'42'</span>], dtype=np.string_)</span><br><span class="line">numeric_strings.astype(float)</span><br></pre></td></tr></table></figure>
<h4 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h4><p>不编写循环，使用数组即可对数据执行批量运算。NumPy用户称其为<strong>矢量化（vectorization）</strong> </p>
<ul>
<li>大小相等的数组之间的任何算术运算都会将运算应用到元素级</li>
<li>数组与标量的算术运算会将标量值传播到各个元素</li>
<li>大小相同的数组之间的比较会生成布尔值数组</li>
<li>不同大小的数组之间的运算叫做<strong>广播（broadcasting）</strong> </li>
</ul>
<h4 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>一维数组和列表最重要的区别在于：数组切片是原始数组的视图，即数据不会被复制，视图上的任何修改都会直接反映到源数组上。这是因为NumPy的设计目的是处理大数据，假如NumPy坚持要将数据复制会产生性能和内存问题。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 将一个标量值赋值给一个切片时，该值会自动传播（即“广播”）到整个选区</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span>  <span class="comment"># array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span></span><br><span class="line"><span class="comment"># 切片[ : ]会给数组中的所有值赋值</span></span><br><span class="line"><span class="comment"># 数组切片是原始数组的视图</span></span><br><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice[<span class="number">1</span>] = <span class="number">12345</span> <span class="comment"># arr也会发生变化</span></span><br><span class="line"><span class="comment"># 如果想要得到ndarray切片的副本而非视图</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>].copy()</span><br></pre></td></tr></table></figure>
<h5 id="高维度数组"><a href="#高维度数组" class="headerlink" title="高维度数组"></a>高维度数组</h5><p><strong>二维数组</strong> 中，各索引位置上的元素不是标量而是一维数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 对各个元素进行递归访问</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 传入一个以逗号隔开的索引列表来选取单个元素</span></span><br><span class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip|imageView2/2/w/745/format/webp" alt="img"></p>
<p>在<strong>多维数组</strong> 中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"><span class="comment"># 标量值和数组都可以被赋值给arr3d[0]：</span></span><br><span class="line">old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line">arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr3d[<span class="number">0</span>] = old_values</span><br></pre></td></tr></table></figure>
<h5 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h5><p>一维ndarray的切片语法跟Python列表差不多。</p>
<p>二维ndarray的切片方式稍显不同。切片是沿着一个轴向选取元素。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([[1, 2, 3],   # 第一个轴切片，取了前两行</span></span><br><span class="line"><span class="comment">#       [4, 5, 6]])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># array([[2, 3],   # 第一个轴切片，再第二个轴切片</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>
<p>这样切片只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[<span class="number">1</span>, :<span class="number">2</span>]  <span class="comment"># array([4, 5])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">2</span>]  <span class="comment"># array([3, 6])</span></span><br></pre></td></tr></table></figure>
<p><strong>“只有冒号”表示选取整个轴</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line"><span class="comment"># array([[1],</span></span><br><span class="line"><span class="comment">#       [4],</span></span><br><span class="line"><span class="comment">#       [7]])</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip|imageView2/2/w/867/format/webp" alt="img"></p>
<p><strong>对切片表达式的赋值操作也会被扩散到整个选区</strong></p>
<h5 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h5><p>布尔型数组的长度必须跟被索引的轴长度一致</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line">data[names == <span class="string">'Bob'</span>]  <span class="comment"># 可以选出对名字"Bob"对应的所有行</span></span><br><span class="line"><span class="comment"># 布尔型数组可以和切片、整数（或整数序列）混合使用</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]  <span class="comment"># array([[ 0.769 ,  1.2464], [-0.5397,  0.477 ]])</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">3</span>]   <span class="comment"># array([ 1.2464,  0.477 ])</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以使用不等于符号（!=），或通过~对条件进行否定</span></span><br><span class="line">data[~(names == <span class="string">'Bob'</span>)]</span><br><span class="line">data[names != <span class="string">'Bob'</span>]</span><br><span class="line"><span class="comment"># 使用&amp;（和）、|（或）之类的布尔算术运算符</span></span><br><span class="line">data[mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)]</span><br><span class="line"><span class="comment"># 通过布尔型数组设置值。例如将data中的所有负值都设置为0</span></span><br><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>布尔型索引选取数组中的数据，总是创建数据的副本。</li>
<li>Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</li>
<li>这类二维数据的操作也可以用pandas</li>
</ul>
<h5 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h5><p>花式索引（Fancy indexing）是一个NumPy术语，是指利用整数数组进行索引。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">     arr[i] = i</span><br><span class="line"><span class="comment"># 可以传入一个用于指定顺序的整数列表或ndarray，特定顺序选取行子集</span></span><br><span class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="comment"># 使用负数索引将会从末尾开始选取行</span></span><br><span class="line">arr[[<span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]]</span><br></pre></td></tr></table></figure>
<ul>
<li>无论数组是多少维的，花式索引总是一维的</li>
<li>花式索引总是将数据复制到新数组中</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一次传入多个索引数组的返回是一个一维数组</span></span><br><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># array([ 4, 23, 29, 10])</span></span><br><span class="line"><span class="comment"># 要想的到矩阵</span></span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>
<h4 id="数组转置和轴兑换"><a href="#数组转置和轴兑换" class="headerlink" title="数组转置和轴兑换"></a>数组转置和轴兑换</h4><ul>
<li>转置是重塑的一种特殊形式，返回源数据的视图（不会进行任何复制操作）。</li>
</ul>
<p>数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr.T</span><br><span class="line">arr.transpose()</span><br></pre></td></tr></table></figure>
<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变</span></span><br><span class="line">arr.swapaxes(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># swapaxes方法，它需要接受一对轴编号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>swapaxes也是返回源数据的视图（不会进行任何复制操作）</li>
</ul>
<h3 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h3><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。可以看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的<strong>矢量化包装器</strong>。</p>
<ul>
<li><p>一元（unary）ufunc,如sqrt和exp,返回一个结果数组</p>
</li>
<li><p>二元（binary）ufunc，如add或maximum接受2个数组,并返回一个结果数组</p>
</li>
<li><p>有些ufunc可以返回多个数组，例如mod（Python内置函数divmod的矢量化版本），返回浮点数数组的小数和整数部分</p>
</li>
<li><p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作。</p>
</li>
<li><p>```python<br>arr = array([-3.2623, -6.0915, -6.663 ,  5.3731,  3.6182,  3.45  ,  5.0077])<br>np.sqrt(arr)</p>
<h1 id="array-nan-nan-nan-2-318-1-9022-1-8574-2-2378"><a href="#array-nan-nan-nan-2-318-1-9022-1-8574-2-2378" class="headerlink" title="array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])"></a>array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-1d494e73b61c7ced.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-2be79faf68ab6ff8.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-4e38d02a66481530.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-eff1e61e5464159f.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-236dba83b6a420cc.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">### 利用数组进行数据处理</span><br><span class="line"></span><br><span class="line">用数组表达式代替循环的做法，通常被称为**矢量化**。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多）。</span><br><span class="line"></span><br><span class="line">#### 将条件逻辑表述为数组运算</span><br><span class="line"></span><br><span class="line">&#96;numpy.where&#96;函数是三元表达式&#96;x if condition else y&#96;的矢量化版本</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">xarr &#x3D; np.array([1.1, 1.2, 1.3, 1.4, 1.5])</span><br><span class="line">yarr &#x3D; np.array([2.1, 2.2, 2.3, 2.4, 2.5])</span><br><span class="line">cond &#x3D; np.array([True, False, True, True, False])</span><br><span class="line"># 根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。</span><br><span class="line"># 列表推导式的写法  缺点：1, 对大数组的处理速度不是很快。2,无法用于多维数组</span><br><span class="line">result &#x3D; [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]</span><br><span class="line">#</span><br><span class="line">result &#x3D; np.where(cond, xarr, yarr)</span><br><span class="line"># 第二个和第三个参数也可以是标量值</span><br><span class="line">arr &#x3D; np.random.randn(4, 4)</span><br><span class="line">np.where(arr &gt; 0, 2, -2) # set positive values to 2, negative values to -2.</span><br><span class="line"># 可以将标量和数组结合起来</span><br><span class="line">np.where(arr &gt; 0, 2, arr) # set only positive values to 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h4><p>通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算</p>
<p>sum、mean, 标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">arr.mean()</span><br><span class="line">np.mean(arr)</span><br><span class="line"><span class="comment"># mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个低一维的数组</span></span><br><span class="line">arr.mean(axis=<span class="number">1</span>) <span class="comment"># 算行的平均值</span></span><br><span class="line">arr.sum(axis=<span class="number">0</span>) <span class="comment"># 计算每列的和</span></span><br></pre></td></tr></table></figure>
<p>其他如cumsum（累加）和cumprod（累乘）之类的方法则不聚合，而是产生一个由中间结果组成的数组。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">arr.cumsum()  <span class="comment"># array([ 0,  1,  3,  6, 10, 15, 21, 28])</span></span><br><span class="line"><span class="comment"># 多维数组，返回同样大小的数组，每个低维的切片沿着标记轴计算部分聚类</span></span><br><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>) <span class="comment"># 列上累加</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>) <span class="comment"># 行上累乘</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h4><p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）</p>
<ul>
<li><p>sum经常被用来对布尔型数组中的True值计数：</p>
</li>
<li><p>```python<br>arr = np.random.randn(100)<br>(arr &gt; 0).sum()</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">+ any用于测试数组中是否存在一个或多个True</span><br><span class="line"></span><br><span class="line">+ all则检查数组中所有值是否都是True</span><br><span class="line"></span><br><span class="line">+ any,all 用于非布尔型数组时，所有非0元素将会被当做True</span><br><span class="line"></span><br><span class="line">#### 排序</span><br><span class="line"></span><br><span class="line">多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">arr &#x3D; np.random.randn(5, 3)</span><br><span class="line">arr.sort(1)  # 安行排序，地排序则会修改数组本身</span><br><span class="line">np.sum(arr,1) # 返回的是数组的已排序副本</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h4><p>NumPy提供了一些针对一维ndarray的基本集合运算。</p>
<ul>
<li>np.unique用于找出数组中的唯一值并返回已排序的结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">np.unique(names)  <span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')</span></span><br><span class="line"><span class="comment"># 纯python代码也可以</span></span><br><span class="line">sorted(set(names)) <span class="comment"># ['Bob', 'Joe', 'Will']</span></span><br></pre></td></tr></table></figure>
<ul>
<li>np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]) <span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="用于数组的文件输入输出"><a href="#用于数组的文件输入输出" class="headerlink" title="用于数组的文件输入输出"></a>用于数组的文件输入输出</h3><p>NumPy的内置二进制格式，使用pandas或其它工具加载文本或表格数据</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 保存，default：数组以未压缩的原始二进制格式保存在扩展名为.npy的文件中，如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"><span class="comment"># 将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br><span class="line"><span class="comment"># 加载.npz文件时，得到一个类似字典的对象</span></span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>] <span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 数据压缩</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>
<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。</p>
<p>点积np.dot(a,y)或者x.dot(y)，@符用作中缀运算符，进行矩阵乘法</p>
<p><strong>numpy.linalg模块</strong> ：标准的矩阵分解运算包括求逆和行列式之类，使用行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于NumPy版本）等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h3><p><strong>numpy.random模块</strong>:对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数</p>
<p>都是通过算法基于随机数生成器种子，在确定性的条件下生成的伪随机数。可以用NumPy的np.random.seed更改随机数生成种子</p>
<p>numpy.random的数据生成函数使用全局随机种子。使用numpy.random.RandomState 创建一个与其它隔离的随机数生成器,避免全局状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="示例：随机漫步"><a href="#示例：随机漫步" class="headerlink" title="示例：随机漫步"></a>示例：随机漫步</h3><p>简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用一个数组运算来实现</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line">walk.min()</span><br><span class="line">walk.max()</span><br></pre></td></tr></table></figure>
<p>统计首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。</p>
<p>np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。</p>
<p>可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：<code>(np.abs(walk) &gt;= 10).argmax()</code></p>
<ul>
<li>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</li>
</ul>
<h4 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟5000个随机漫步过程</span></span><br><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算30或－30的最小穿越时间</span></span><br><span class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>)  <span class="comment"># 按照行来查询，一行中只要有一个true，则为true</span></span><br><span class="line">hits30.sum()  <span class="comment"># 5000个随机过程中，有多少个达到30，sum布尔值时，True为1</span></span><br><span class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="第5章-pandas入门"><a href="#第5章-pandas入门" class="headerlink" title="第5章 pandas入门"></a>第5章 pandas入门</h2><p>pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>
<h3 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h3><h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成</p>
<p>可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 可以通过Series 的values和index属性获取其数组表示形式和索引对象</span></span><br><span class="line">obj.values <span class="comment"># array([ 4,  7, -5,  3])</span></span><br><span class="line">obj.index  <span class="comment"># like range(4)  RangeIndex(start=0, stop=4, step=1)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 直接通过这个字典来创建Series</span></span><br><span class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line">obj3 = pd.Series(sdata)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</span><br><span class="line">obj4 = pd.Series(sdata, index=states)</span><br><span class="line"><span class="comment"># sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</span></span><br><span class="line">pd.isnull(obj4)  <span class="comment"># pandas的isnull和notnull函数可用于检测缺失数据</span></span><br><span class="line">pd.notnull(obj4)</span><br><span class="line">obj4.isnull()   <span class="comment"># Series也有类似的实例方法</span></span><br></pre></td></tr></table></figure>
<p>Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据，类似数据库的join的操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line"><span class="comment"># Series对象本身及其索引都有一个name属性</span></span><br><span class="line">obj4.name = <span class="string">'population'</span></span><br><span class="line">obj4.index.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>
<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>一个<strong>表格型的数据结构</strong>，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，可以看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<p>pandas中许多高级数据处理功能的关键要素，<strong>层次化索引的表格型结构</strong>  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 按照指定顺序进行排列</span></span><br><span class="line">pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>]) </span><br><span class="line"><span class="comment"># 传入的列在数据中找不到，就会在结果中产生缺失值</span></span><br><span class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>,<span class="string">'five'</span>, <span class="string">'six'</span>])</span><br><span class="line"><span class="comment"># 通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series</span></span><br><span class="line">frame2[<span class="string">'state'</span>]</span><br><span class="line">frame2.year</span><br><span class="line"><span class="comment"># 行也可以通过位置或名称的方式进行获取，比如用loc属性</span></span><br><span class="line">frame2.loc[<span class="string">'three'</span>]</span><br><span class="line"><span class="comment"># 列可以通过赋值的方式进行修改</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line">frame2[<span class="string">'debt'</span>] = val</span><br><span class="line"><span class="comment"># 根据state是否为'Ohio'，添加一个新的布尔值的列</span></span><br><span class="line">frame2[<span class="string">'eastern'</span>] = frame2.state == <span class="string">'Ohio'</span></span><br><span class="line"><span class="comment"># 关键字del用于删除列</span></span><br><span class="line"><span class="keyword">del</span> frame2[<span class="string">'eastern'</span>] </span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">frame.head() <span class="comment"># 前五行</span></span><br></pre></td></tr></table></figure>
<ul>
<li>frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 嵌套字典</span></span><br><span class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,<span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">frame3 = pd.DataFrame(pop)</span><br><span class="line"><span class="comment"># 对DataFrame进行转置（交换行和列）</span></span><br><span class="line">frame3.T</span><br><span class="line"><span class="comment"># 由Series组成的字典</span></span><br><span class="line">pdata = &#123;<span class="string">'Ohio'</span>: frame3[<span class="string">'Ohio'</span>][:<span class="number">-1</span>],<span class="string">'Nevada'</span>: frame3[<span class="string">'Nevada'</span>][:<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1075/format/webp" alt="img"></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame3.index.name = <span class="string">'year'</span>; frame3.columns.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>
<h4 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h4><h4 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h4><p>在对Series或DataFrame重新索引时，也可以指定一个填充值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认删除行（index）</span></span><br><span class="line">data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="comment"># 通过传递axis=1或axis='columns'可以删除列的值</span></span><br><span class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 就地修改对象，不会返回新的对象</span></span><br><span class="line">obj.drop(<span class="string">'c'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h4><p>Series：利用标签的切片运算与普通的Python切片运算不同，其末端是包含的。</p>
<p>DataFrame：默认列标签的索引</p>
<h4 id="用loc和iloc进行选取"><a href="#用loc和iloc进行选取" class="headerlink" title="用loc和iloc进行选取"></a>用loc和iloc进行选取</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先行后列</span></span><br><span class="line">data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]] <span class="comment">#行是必须的</span></span><br><span class="line">data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">data.loc[:<span class="string">'Utah'</span>, <span class="string">'two'</span>]</span><br><span class="line">data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip|imageView2/2/w/929/format/webp" alt="img"></p>
<h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h4><p>loc和iloc</p>
<h4 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h4><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。</p>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播</p>
<h4 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h4><p>两个DataFrame相加时，没有重叠的位置就会产生NA值，可以使用add方法填充一个特殊值（比如0）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1.add(df2, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip|imageView2/2/w/388/format/webp" alt="img"></p>
<ul>
<li>以字母r开头，它会翻转参数。</li>
</ul>
<h4 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h4><p>广播（broadcasting）</p>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">series = frame.iloc[<span class="number">0</span>]</span><br><span class="line">frame - series</span><br><span class="line"><span class="string">""" output</span></span><br><span class="line"><span class="string">          b    d    e</span></span><br><span class="line"><span class="string">Utah    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">Ohio    3.0  3.0  3.0</span></span><br><span class="line"><span class="string">Texas   6.0  6.0  6.0</span></span><br><span class="line"><span class="string">Oregon  9.0  9.0  9.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>
<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line">frame + series2</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">          b   d     e   f</span></span><br><span class="line"><span class="string">Utah    0.0 NaN   3.0 NaN</span></span><br><span class="line"><span class="string">Ohio    3.0 NaN   6.0 NaN</span></span><br><span class="line"><span class="string">Texas   6.0 NaN   9.0 NaN</span></span><br><span class="line"><span class="string">Oregon  9.0 NaN  12.0 NaN</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>可以使用算术运算方法匹配行且在列上广播。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.sub(series3, axis=<span class="string">'index'</span>) <span class="comment"># 或者 axis=0</span></span><br></pre></td></tr></table></figure>
<h4 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h4><p>DataFrame的apply方法可以将函数应用到由各列或行所形成的一维数组上。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line">frame.apply(f) <span class="comment"># 每列</span></span><br><span class="line">frame.apply(f, axis=<span class="string">'columns'</span>) <span class="comment"># 每行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line">frame.apply(f)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            b         d         e</span></span><br><span class="line"><span class="string">min -0.555730  0.281746 -1.296221</span></span><br><span class="line"><span class="string">max  1.246435  1.965781  1.393406</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>
<p>DataFrame的applymap方法可以使用元素级的Python函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</span><br><span class="line">frame.applymap(format)</span><br></pre></td></tr></table></figure>
<p>Series有一个用于应用元素级函数的map方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame[<span class="string">'e'</span>].map(format)</span><br></pre></td></tr></table></figure>
<h4 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h4><p>DataFrame和Series中的sort_index方法对行或列索引进行排序（按字典顺序，默认升序），返回一个已排序的新对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj.sort_index()</span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),index=[<span class="string">'three'</span>, <span class="string">'one'</span>], columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">frame.sort_index()  <span class="comment"># index</span></span><br><span class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>) <span class="comment"># columns</span></span><br></pre></td></tr></table></figure>
<p>若要按值对Series进行排序，可使用其sort_values方法,任何缺失值默认都会被放到Series的末尾。</p>
<p>DataFrame排序时，可以根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">frame.sort_values(by=<span class="string">'b'</span>)</span><br><span class="line">frame.sort_values(by=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>
<p><strong>Series和DataFrame的rank方法</strong></p>
<p>默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">obj.rank() <span class="comment"># 排名并列会平均</span></span><br><span class="line">obj.rank(method=<span class="string">'first'</span>) <span class="comment"># 排名并列会选择小的数值</span></span><br><span class="line">obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">'max'</span>) <span class="comment"># 排名并列选择大的数值</span></span><br><span class="line"></span><br><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;) </span><br><span class="line">frame.rank(axis=<span class="string">'columns'</span>) <span class="comment"># 即axis=1， 默认axis=0</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip|imageView2/2/w/653/format/webp" alt="img"></p>
<h4 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h4><p>pandas函数（如reindex）都要求标签唯一，但这不是强制性的。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 检查标签是否唯一</span></span><br><span class="line">obj.index.is_unique</span><br><span class="line"><span class="comment"># 如果某个索引对应多个值，则返回一个Series</span></span><br><span class="line"><span class="comment"># 对DataFrame的行进行索引时，返回DataFrame</span></span><br></pre></td></tr></table></figure>
<h3 id="汇总和计算描述统计"><a href="#汇总和计算描述统计" class="headerlink" title="汇总和计算描述统计"></a>汇总和计算描述统计</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引），另一些方法则是累计型的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h4><h4 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">obj = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</span><br><span class="line">uniques = obj.unique()</span><br><span class="line">obj.value_counts()</span><br><span class="line"><span class="comment"># isin用于判断矢量化集合的成员资格</span></span><br><span class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip|imageView2/2/w/848/format/webp" alt="img"></p>
<h2 id="第6章-数据加载、存储与文件格式"><a href="#第6章-数据加载、存储与文件格式" class="headerlink" title="第6章 数据加载、存储与文件格式"></a>第6章 数据加载、存储与文件格式</h2><h3 id="读写文本格式的数据"><a href="#读写文本格式的数据" class="headerlink" title="读写文本格式的数据"></a>读写文本格式的数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip|imageView2/2/w/778/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'examples/ex1.csv'</span>)</span><br><span class="line">pd.read_table(<span class="string">'examples/ex1.csv'</span>, sep=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 如果文件没有标题行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, header=<span class="literal">None</span>)</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>])</span><br><span class="line"><span class="comment"># 将某列设置为索引</span></span><br><span class="line">names = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>]</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=names, index_col=<span class="string">'message'</span>)</span><br><span class="line"><span class="comment"># 层次化索引</span></span><br><span class="line">parsed = pd.read_csv(<span class="string">'examples/csv_mindex.csv'</span>, index_col=[<span class="string">'key1'</span>, <span class="string">'key2'</span>])</span><br><span class="line"><span class="comment"># 正则表达式作为分隔</span></span><br><span class="line">result = pd.read_table(<span class="string">'examples/ex3.txt'</span>, sep=<span class="string">'\s+'</span>)</span><br><span class="line"><span class="comment"># 用skiprows跳过文件的指定行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex4.csv'</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>
<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># na_values可以用一个列表或集合的字符串表示缺失值</span></span><br><span class="line">result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>, na_values=[<span class="string">'NULL'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置pandas显示地更紧些</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"><span class="comment"># 只读取几行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex6.csv'</span>, nrows=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 要逐块读取文件</span></span><br><span class="line">chunker = pd.read_csv(<span class="string">'ch06/ex6.csv'</span>, chunksize=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
<p>返回可迭代的TextParser对象</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">'key'</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>
<h4 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.to_csv(<span class="string">'examples/out.csv'</span>)</span><br><span class="line">data.to_csv(sys.stdout, sep=<span class="string">'|'</span>) <span class="comment"># 写出到sys.stdout，仅仅打印出文本结果</span></span><br><span class="line"><span class="comment"># 默认缺失值在输出结果中会被表示为空字符串</span></span><br><span class="line">data.to_csv(sys.stdout, na_rep=<span class="string">'NULL'</span>)</span><br><span class="line"><span class="comment"># 默认写出行和列的标签</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 只写出一部分</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># Series也有一个to_csv方法</span></span><br><span class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">7</span>)</span><br><span class="line">ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line">ts.to_csv(<span class="string">'examples/tseries.csv'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="处理分隔符格式"><a href="#处理分隔符格式" class="headerlink" title="处理分隔符格式"></a>处理分隔符格式</h4><p>手动处理：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用Python内置的csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = open(<span class="string">'examples/ex7.csv'</span>)</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    print(line)</span><br><span class="line"><span class="comment"># 读取文件到一个多行的列表中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'examples/ex7.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = list(csv.reader(f))</span><br><span class="line"><span class="comment"># 将这些行分为标题行和数据行    </span></span><br><span class="line">header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典</span></span><br><span class="line">data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> zip(header, zip(*values))&#125;</span><br></pre></td></tr></table></figure>
<p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_dialect</span><span class="params">(csv.Dialect)</span>:</span></span><br><span class="line">    lineterminator = <span class="string">'\n'</span></span><br><span class="line">    delimiter = <span class="string">';'</span></span><br><span class="line">    quotechar = <span class="string">'"'</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip|imageView2/2/w/1187/format/webp" alt="img"></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>通过json.loads即可将JSON字符串转换成Python形式</p>
<p>json.dumps则将Python对象转换成JSON格式</p>
<p>JSON对象转换为DataFrame：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = json.loads(obj)</span><br><span class="line">siblings = pd.DataFrame(result[<span class="string">'siblings'</span>], columns=[<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br></pre></td></tr></table></figure>
<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame</p>
<p>将数据从pandas输出到JSON，可以使用to_json方法</p>
<h4 id="XML和HTML：Web信息收集"><a href="#XML和HTML：Web信息收集" class="headerlink" title="XML和HTML：Web信息收集"></a>XML和HTML：Web信息收集</h4><p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。</p>
<h3 id="二进制数据格式"><a href="#二进制数据格式" class="headerlink" title="二进制数据格式"></a>二进制数据格式</h3><p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化</p>
<p>read_pickle和to_pickle</p>
<ul>
<li>pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的</li>
</ul>
<p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。</p>
<p>pandas或NumPy数据的其它存储格式有：</p>
<ul>
<li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li>
<li>Feather：一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li>
</ul>
<h4 id="HDF5格式"><a href="#HDF5格式" class="headerlink" title="HDF5格式"></a>HDF5格式</h4><p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。</p>
<p>HDF5可以高效地分块读写</p>
<p>可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line">store[<span class="string">'obj1'</span>] = frame</span><br><span class="line">store[<span class="string">'obj1_col'</span>] = frame[<span class="string">'a'</span>]</span><br><span class="line">store = pd.HDFStore(<span class="string">'mydata.h5'</span>)</span><br><span class="line"><span class="comment"># HDFStore支持两种存储模式，'fixed'和'table'。后者通常会更慢，但是支持使用特殊语法进行查询操作：</span></span><br><span class="line">store.put(<span class="string">'obj2'</span>, frame, format=<span class="string">'table'</span>)</span><br><span class="line">store.select(<span class="string">'obj2'</span>, where=[<span class="string">'index &gt;= 10 and index &lt;= 15'</span>])</span><br><span class="line"></span><br><span class="line">frame.to_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, format=<span class="string">'table'</span>)</span><br><span class="line">pd.read_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, where=[<span class="string">'index &lt; 5'</span>])</span><br></pre></td></tr></table></figure>
<h4 id="读取Microsoft-Excel文件"><a href="#读取Microsoft-Excel文件" class="headerlink" title="读取Microsoft Excel文件"></a>读取Microsoft Excel文件</h4><p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line">xlsx = pd.ExcelFile(<span class="string">'examples/ex1.xlsx'</span>)</span><br><span class="line">pd.read_excel(xlsx, <span class="string">'Sheet1'</span>)</span><br><span class="line">frame = pd.read_excel(<span class="string">'examples/ex1.xlsx'</span>, <span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'examples/ex2.xlsx'</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">'Sheet1'</span>)</span><br><span class="line">writer.save()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">frame.to_excel(<span class="string">'examples/ex2.xlsx'</span>)</span><br></pre></td></tr></table></figure>
<h3 id="Web-APIs交互"><a href="#Web-APIs交互" class="headerlink" title="Web APIs交互"></a>Web APIs交互</h3><h3 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h3><p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）</p>
<p>。<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。</p>
<h2 id="第7章-数据清洗和准备"><a href="#第7章-数据清洗和准备" class="headerlink" title="第7章 数据清洗和准备"></a>第7章 数据清洗和准备</h2><h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据，称其为哨兵值，可以方便的检测出来。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">string_data = pd.Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="string">'avocado'</span>])</span><br><span class="line">string_data.isnull()</span><br><span class="line">string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line">string_data.isnull()</span><br></pre></td></tr></table></figure>
<p>pandas采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="滤除缺失数据"><a href="#滤除缺失数据" class="headerlink" title="滤除缺失数据"></a>滤除缺失数据</h4><p>通过pandas.isnull或布尔索引的手工方法，或者dropna。对于一个Series，dropna返回一个仅含非空数据和索引值的Series</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>]) </span><br><span class="line">data.dropna()</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">data[data.notnull()]</span><br></pre></td></tr></table></figure>
<p>对于DataFrame对象，dropna默认丢弃任何含有缺失值的行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line">cleaned = data.dropna()</span><br><span class="line"><span class="comment"># 丢弃全为NA的那些行</span></span><br><span class="line">data.dropna(how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 丢弃列</span></span><br><span class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 滤除DataFrame行的问题涉及时间序列数据，至滤除符合条件的前两行</span></span><br><span class="line">df.dropna(thresh=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
<h4 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h4><p>fillna函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 实现对不同的列填充不同的值</span></span><br><span class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment"># 对现有对象进行就地修改</span></span><br><span class="line"> _ = df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#对reindexing有效的那些插值方法也可用于fillna    </span></span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 传入平均值</span></span><br><span class="line">data.fillna(data.mean())</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><h4 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'k1'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>] * <span class="number">3</span> + [<span class="string">'two'</span>],<span class="string">'k2'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="comment"># duplicated方法返回一个布尔型Series，表示各行是否和前面出现过的行重复</span></span><br><span class="line">data.duplicated()</span><br><span class="line"><span class="comment"># drop_duplicates方法，返回一个DataFrame，重复的数组会标为False</span></span><br><span class="line">data.drop_duplicates()</span><br><span class="line"><span class="comment"># 指定部分列进行重复项判断</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>])</span><br><span class="line"><span class="comment"># duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>, <span class="string">'k2'</span>], keep=<span class="string">'last'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="利用函数或映射进行数据转换"><a href="#利用函数或映射进行数据转换" class="headerlink" title="利用函数或映射进行数据转换"></a>利用函数或映射进行数据转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>,</span><br><span class="line"><span class="string">'Pastrami'</span>, <span class="string">'corned beef'</span>, <span class="string">'Bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>, <span class="string">'nova lox'</span>],<span class="string">'ounces'</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="comment"># 添加一列表示该肉类食物来源的动物类型</span></span><br><span class="line"><span class="comment"># 编写一个不同肉类到动物的映射</span></span><br><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">'bacon'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 先将字母转换为小写</span></span><br><span class="line">lowercased = data[<span class="string">'food'</span>].str.lower()</span><br><span class="line">data[<span class="string">'animal'</span>] = lowercased.map(meat_to_animal)</span><br><span class="line"><span class="comment"># 传入一个能够完成全部这些工作的函数：</span></span><br><span class="line">data[<span class="string">'food'</span>].map(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>
<h4 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a>替换值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1.</span>, <span class="number">-999.</span>, <span class="number">2.</span>, <span class="number">-999.</span>, <span class="number">-1000.</span>, <span class="number">3.</span>])</span><br><span class="line">data.replace(<span class="number">-999</span>, np.nan)</span><br><span class="line"><span class="comment"># 传入多个值</span></span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], np.nan)</span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 也可以传入字典</span></span><br><span class="line">data.replace(&#123;<span class="number">-999</span>: np.nan, <span class="number">-1000</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换</li>
</ul>
<h4 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h4><p>轴标签可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line">data.index.map(transform)</span><br><span class="line"><span class="comment"># 对DataFrame就地修改</span></span><br><span class="line">data.index = data.index.map(transform)</span><br><span class="line"><span class="comment"># 用rename方法创建数据集的转换版（而不是修改原始数据）</span></span><br><span class="line">data.rename(index=str.title, columns=str.upper)</span><br><span class="line"><span class="comment"># rename可以结合字典型对象实现对部分轴标签的更新</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;,columns=&#123;<span class="string">'three'</span>: <span class="string">'peekaboo'</span>&#125;)</span><br><span class="line"><span class="comment"># 就地修改</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h4><p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。</p>
<p>cut函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 年龄分组</span></span><br><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br><span class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line">cats = pd.cut(ages, bins)</span><br><span class="line"><span class="comment"># 返回的是一个特殊的Categorical对象</span></span><br><span class="line">cats.codes <span class="comment"># array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)</span></span><br><span class="line">cats.categories </span><br><span class="line"><span class="string">""" IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]]</span></span><br><span class="line"><span class="string">              closed='right',</span></span><br><span class="line"><span class="string">              dtype='interval[int64]')"""</span></span><br><span class="line"><span class="comment"># pd.value_counts(cats)是pandas.cut结果的面元计数</span></span><br><span class="line">pd.value_counts(cats)</span><br><span class="line"></span><br><span class="line">pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 可以通过传递一个列表或数组到labels，设置面元名称</span></span><br><span class="line">group_names = [<span class="string">'Youth'</span>, <span class="string">'YoungAdult'</span>, <span class="string">'MiddleAged'</span>, <span class="string">'Senior'</span>]</span><br><span class="line">pd.cut(ages, bins, labels=group_names)</span><br><span class="line"><span class="comment"># 向cut传入的是面元的数量</span></span><br><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line">pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>) <span class="comment"># 选项precision=2，限定小数只有两位</span></span><br></pre></td></tr></table></figure>
<p>qcut非常类似cut，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">cats = pd.qcut(data, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以传递自定义的分位数（0到1之间的数值，包含端点）</span></span><br><span class="line">pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>
<h4 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h4><p>过滤或变换异常值（outlier）在很大程度上就是运用数组运算。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line">data.describe()</span><br><span class="line"><span class="comment"># 找出某列中绝对值大小超过3的值</span></span><br><span class="line">col = data[<span class="number">2</span>] <span class="comment"># 第二列</span></span><br><span class="line">col[np.abs(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 选出全部含有“超过3或－3的值”的行</span></span><br><span class="line">data[(np.abs(data) &gt; <span class="number">3</span>).any(<span class="number">1</span>)]</span><br><span class="line">data[np.abs(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"><span class="comment"># 根据数据的值是正还是负，np.sign(data)可以生成1和-1：</span></span><br><span class="line">np.sign(data).head()</span><br></pre></td></tr></table></figure>
<h4 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h4><p>利用numpy.random.permutation函数可以实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line">df.take(sampler)</span><br><span class="line"><span class="comment"># 可以在Series和DataFrame上使用sample方法</span></span><br><span class="line">df.sample(n=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 要通过替换的方式产生样本（允许重复选择），可以传递replace=True到sample</span></span><br><span class="line">choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h4><p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line"><span class="comment"># 给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并</span></span><br><span class="line">dummies = pd.get_dummies(df[<span class="string">'key'</span>], prefix=<span class="string">'key'</span>)</span><br><span class="line">df_with_dummy = df[[<span class="string">'data1'</span>]].join(dummies)</span><br><span class="line"><span class="comment"># 如果DataFrame中的某行同属于多个分类，则事情就会有点复杂</span></span><br></pre></td></tr></table></figure>
<p>另一个例子</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>
<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">val = <span class="string">'a,b,  guido'</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">','</span>)]</span><br><span class="line"><span class="string">'::'</span>.join(pieces) <span class="comment"># 等价于 first + '::' + second + '::' + third</span></span><br><span class="line"><span class="comment"># 子串定位</span></span><br><span class="line"><span class="string">'guido'</span> <span class="keyword">in</span> val</span><br><span class="line">val.index(<span class="string">','</span>) <span class="comment"># 找不到字符串，index将会引发一个异常</span></span><br><span class="line">val.find(<span class="string">':'</span>)  <span class="comment"># 找不到返回-1</span></span><br><span class="line">val.count(<span class="string">','</span>)</span><br><span class="line">val.replace(<span class="string">','</span>, <span class="string">'::'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-087fe67bf6db0701.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d1f0d4ed3e895016.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"foo    bar\t baz  \tqux"</span></span><br><span class="line">re.split(<span class="string">'\s+'</span>, text)</span><br><span class="line"><span class="comment"># 调用re.split('\s+',text)时，正则表达式会先被编译，然后再在text上调用其split方法。</span></span><br><span class="line"><span class="comment"># 如果打算对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建regex对象。这样将可以节省大量的CPU时间。</span></span><br><span class="line">regex = re.compile(<span class="string">'\s+'</span>)</span><br><span class="line">regex.split(text)</span><br><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># findall返回字符串中所有的匹配项，search返回第一个匹配项。match只匹配字符串的首部</span></span><br><span class="line">text = <span class="string">"""Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pattern = <span class="string">r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;'</span></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.compile(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">regex.findall(text)</span><br><span class="line">m = regex.search(text)</span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(5, 20), match='dave@google.com'&gt;</span></span><br><span class="line">text[m.start():m.end()]</span><br><span class="line">regex.match(text) <span class="comment"># 结果为None,只匹配出现在字符串开头的模式</span></span><br><span class="line">regex.sub(<span class="string">'REDACTED'</span>, text)</span><br><span class="line"><span class="comment"># 分段的模式</span></span><br><span class="line">pattern = <span class="string">r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)'</span></span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line">m.groups()</span><br><span class="line"><span class="comment"># ('wesm', 'bright', 'net')</span></span><br><span class="line">regex.findall(text) <span class="comment"># 对于带有分组功能的模式，findall返回一个元组列表</span></span><br><span class="line"><span class="comment"># sub能通过诸如\1、\2之类的特殊符号访问各匹配项中的分组</span></span><br><span class="line">regex.sub(<span class="string">r'Username: \1, Domain: \2, Suffix: \3'</span>, text)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-efbb80a793759fc0.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="pandas的矢量化字符串函数"><a href="#pandas的矢量化字符串函数" class="headerlink" title="pandas的矢量化字符串函数"></a>pandas的矢量化字符串函数</h4><p>通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。</p>
<p>含有字符串的列有时还含有缺失数据,为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data.str.contains(<span class="string">'gmail'</span>)</span><br><span class="line">data.str.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line">matches = data.str.match(pattern, flags=re.IGNORECASE)</span><br><span class="line">data.str[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/870/format/webp" alt="img"></p>
<h2 id="第8章-数据规整：聚合、合并和重塑"><a href="#第8章-数据规整：聚合、合并和重塑" class="headerlink" title="第8章 数据规整：聚合、合并和重塑"></a>第8章 数据规整：聚合、合并和重塑</h2><h3 id="层次化索引"><a href="#层次化索引" class="headerlink" title="层次化索引"></a>层次化索引</h3><p>层次化索引（hierarchical indexing）是pandas的一项重要功能，在一个轴上拥有多个（两个以上）索引级别，以低维度形式处理高维度数据。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">data = pd.Series(np.random.randn(<span class="number">9</span>),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 外层操作</span></span><br><span class="line">data[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment"># 内层操作</span></span><br><span class="line">data.loc[:, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过unstack方法将这段数据重新安排到一个DataFrame中</span></span><br><span class="line">data.unstack()</span><br><span class="line">data.unstack().stack()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对于一个DataFrame，每条轴都可以有分层索引：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],columns=[[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>],[<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]])</span><br><span class="line"><span class="comment"># 各层都可以有名字</span></span><br><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">frame[<span class="string">'Ohio'</span>]</span><br><span class="line">frame.loc[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>
<h4 id="重排与分级排序"><a href="#重排与分级排序" class="headerlink" title="重排与分级排序"></a>重排与分级排序</h4><p>swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># sort_index则根据单个级别中的值对数据进行排序</span></span><br><span class="line">frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<h4 id="根据级别汇总统计"><a href="#根据级别汇总统计" class="headerlink" title="根据级别汇总统计"></a>根据级别汇总统计</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据行或列上的级别来进行求和</span></span><br><span class="line">frame.sum(level=<span class="string">'key2'</span>)</span><br><span class="line">frame.sum(level=<span class="string">'color'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h4 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h4><p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>),<span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">frame2 = frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="comment"># 默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来</span></span><br><span class="line">frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>], drop=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面</span></span><br><span class="line">frame2.reset_index()</span><br></pre></td></tr></table></figure>
<h3 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h3><p>pandas对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<h4 id="数据库风格的DataFrame合并"><a href="#数据库风格的DataFrame合并" class="headerlink" title="数据库风格的DataFrame合并"></a>数据库风格的DataFrame合并</h4><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="comment"># 多对一的合并</span></span><br><span class="line"><span class="comment"># 默认情况下，merge会将重叠列的列名当做键</span></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line"><span class="comment"># 列名可以指定</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment">#如果两个对象的列名不同，也可以分别进行指定</span></span><br><span class="line">pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br><span class="line"><span class="comment"># 默认情况下，merge做的是“内连接”；结果中的键是交集</span></span><br><span class="line"><span class="comment"># 他方式还有"left"、"right"以及"outer"。外连接求取的是键的并集，组合了左连接和右连接的效果</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip|imageView2/2/w/739/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多对多的合并</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">5</span>)&#125;)</span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>, how=<span class="string">'left'</span>)</span><br><span class="line"><span class="comment"># 多对多连接产生的是行的笛卡尔积</span></span><br><span class="line"><span class="comment"># 由于左边的DataFrame有3个"b"行，右边的有2个，所以最终结果中就有6个"b"行。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据多个键进行合并，传入一个由列名组成的列表</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>], <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],<span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],<span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line">pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<p>合并运算对重复列名的处理：merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>)</span><br><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>, suffixes=(<span class="string">'_left'</span>, <span class="string">'_right'</span>))</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip|imageView2/2/w/1180/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip|imageView2/2/w/1180/format/webp" alt="img"></p>
<h4 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h4><p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index=True或right_index=True（或两个都传）以说明索引应该被用作连接键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],<span class="string">'value'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'group_val'</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>对于层次化索引的数据，索引的合并默认是多键合并</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">lefth = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],<span class="string">'key2'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'data'</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line">righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),index=[[<span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>,<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>],[<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],  columns=[<span class="string">'event1'</span>, <span class="string">'event2'</span>])</span><br><span class="line"><span class="comment"># 以列表的形式指明用作合并键的多个列</span></span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 同时使用合并双方的索引</span></span><br><span class="line">pd.merge(left2, right2, how=<span class="string">'outer'</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># join默认使用的是左连接，保留左边表的行索引</span></span><br><span class="line">left2.join(right2, how=<span class="string">'outer'</span>)</span><br><span class="line"><span class="comment"># 支持在调用的DataFrame的列上，连接传递的DataFrame索引</span></span><br><span class="line">left1.join(right1, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">pd.merge(left1,right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h4><p>连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>对于pandas对象（如Series和DataFrame），还需要考虑以下这些情况：</p>
<ul>
<li>如果对象在其它轴上的索引不同，应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li>
</ul>
<p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line"><span class="comment"># 默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）</span></span><br><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]])</span><br><span class="line"><span class="comment"># 在连接轴上创建一个层次化索引</span></span><br><span class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line"><span class="comment"># 如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值</span></span><br><span class="line">pd.concat(&#123;<span class="string">'level1'</span>: df1, <span class="string">'level2'</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可以用names参数命名创建的轴级别</span></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">'level1'</span>, <span class="string">'level2'</span>],names=[<span class="string">'upper'</span>, <span class="string">'lower'</span>])</span><br><span class="line"><span class="comment"># DataFrame的行索引不包含任何相关数据，直接合并index</span></span><br><span class="line">pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip|imageView2/2/w/1167/format/webp" alt="img"></p>
<h4 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan], index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br><span class="line">b = pd.Series(np.arange(len(a), dtype=np.float64), index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br></pre></td></tr></table></figure>
<h2 id="第11章-时间序列"><a href="#第11章-时间序列" class="headerlink" title="第11章 时间序列"></a>第11章 时间序列</h2><p>时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（timestamp），特定的时刻。</li>
<li>固定时期（period），如2007年1月或2010年全年。</li>
<li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li>
<li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li>
</ul>
<h3 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 以毫秒形式存储日期和时间</span></span><br><span class="line">now = datetime.now() <span class="comment"># datetime.datetime(2017, 9, 25, 14, 5, 52, 72973)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>) <span class="comment"># day and second</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h4><p><code>datetime.strptime</code>是通过已知格式进行日期解析的最佳方式，但是每次都要编写格式定义。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">str(stamp) <span class="comment"># '2011-01-03 00:00:00'</span></span><br><span class="line">stamp.strftime(<span class="string">'%Y-%m-%d'</span>) <span class="comment">#'2011-01-03'</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">value = <span class="string">'2011-01-03'</span></span><br><span class="line">datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">parse(<span class="string">'2011-01-03'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br><span class="line">parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</span><br><span class="line">parse(<span class="string">'6/12/2011'</span>, dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p>一些常见的日期格式可以用dateutil这个第三方包中的parser.parse方法。</p>
<p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">datestrs = [<span class="string">'2011-07-06 12:00:00'</span>, <span class="string">'2011-08-06 00:00:00'</span>]</span><br><span class="line">pd.to_datetime(datestrs) <span class="comment"># DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)</span></span><br></pre></td></tr></table></figure>
<p>NaT（Not a Time）是pandas中时间戳数据的null值。</p>
<ul>
<li><p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如”42”会被解析为2042年的今天）。</p>
<p>特定于当前环境（位于不同国家或使用不同语言的系统）的日期格式</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<h3 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h3><p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳。</p>
<p>datetime对象用作index时，实际上被放在一个DatetimeIndex中，其中的各个标量值是pandas的Timestamp对象。</p>
<h4 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h4><p>根据标签索引选取数据时，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">stamp = ts.index[<span class="number">2</span>] </span><br><span class="line">ts[stamp]</span><br><span class="line"><span class="comment"># 下面这种格式也可以</span></span><br><span class="line">ts[<span class="string">'1/10/2011'</span>]</span><br><span class="line">ts[<span class="string">'20110110'</span>]</span><br><span class="line"><span class="comment"># 对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片</span></span><br><span class="line">longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>))</span><br><span class="line">longer_ts[<span class="string">'2001'</span>]</span><br><span class="line">longer_ts[<span class="string">'2001-05'</span>]</span><br><span class="line"><span class="comment"># 使用datetime对象进行切片</span></span><br><span class="line">ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line"><span class="comment"># 也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）</span></span><br><span class="line">ts[<span class="string">'1/6/2011'</span>:<span class="string">'1/11/2011'</span>] <span class="comment"># 产生的是原时间序列的视图</span></span><br><span class="line">ts.truncate(after=<span class="string">'1/9/2011'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h4><p>多个观测数据落在同一个时间点上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>,<span class="string">'1/2/2000'</span>, <span class="string">'1/3/2000'</span>])</span><br><span class="line">dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line">dup_ts.index.is_unique</span><br><span class="line"><span class="comment"># 对具有非唯一时间戳的数据进行聚合</span></span><br><span class="line">grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line">grouped.mean()</span><br><span class="line">grouped.count()</span><br></pre></td></tr></table></figure>
<h3 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h3><p>pandas中的原生时间序列没有固定的频率,一般被认为是不规则的。但pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">resampler = ts.resample(<span class="string">'D'</span>)</span><br><span class="line"><span class="comment"># 字符串“D”是每天的意思</span></span><br></pre></td></tr></table></figure>
<h4 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h4><p><code>pandas.date_range</code>可用于根据指定的频率生成指定长度的DatetimeIndex.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-04-01'</span>, <span class="string">'2012-06-01'</span>)</span><br><span class="line">pd.date_range(start=<span class="string">'2012-04-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line">pd.date_range(end=<span class="string">'2012-06-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 生成一个由每月最后一个工作日组成的日期索引</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-12-01'</span>, freq=<span class="string">'BM'</span>) <span class="comment">#"BM"频率business end of month</span></span><br></pre></td></tr></table></figure>
<p>date_range默认会保留起始和结束时间戳的时间信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 每个日期都有12:56:31,可以关掉</span></span><br><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h4 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h4><p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line">hour = Hour()</span><br><span class="line">four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以使用别名"H"或"4H"</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-01-03 23:59'</span>, freq=<span class="string">'4h'</span>)</span><br><span class="line"><span class="comment"># 偏移量对象都可通过加法进行连接</span></span><br><span class="line">Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>) <span class="comment"># &lt;150 * Minutes&gt;</span></span><br><span class="line"><span class="comment"># 传入频率字符串</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1h30min'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="WOM日期"><a href="#WOM日期" class="headerlink" title="WOM日期"></a>WOM日期</h4><p>WOM（Week Of Month）是一种非常实用的频率类，获得诸如“每月第3个星期五”之类的日期。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'2012-01-01'</span>, <span class="string">'2012-09-01'</span>, freq=<span class="string">'WOM-3FRI'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="移动（超前和滞后）数据"><a href="#移动（超前和滞后）数据" class="headerlink" title="移动（超前和滞后）数据"></a>移动（超前和滞后）数据</h4><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有shift方法用于执行单纯的前移或后移操作，<strong>保持索引不变</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">4</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">4</span>, freq=<span class="string">'M'</span>))</span><br><span class="line"><span class="comment"># 数据位移，会在时间序列的前面或后面产生缺失数据</span></span><br><span class="line">ts.shift(<span class="number">2</span>)</span><br><span class="line">ts.shift(<span class="number">-2</span>)</span><br><span class="line"><span class="comment"># 实现对时间戳进行位移而不是对数据进行简单位移</span></span><br><span class="line">ts.shift(<span class="number">2</span>, freq=<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h4><p>pandas的日期偏移量还可以用在datetime或Timestamp对象上</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line">now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line">now + <span class="number">3</span> * Day() <span class="comment"># Timestamp('2011-11-20 00:00:00')</span></span><br><span class="line"><span class="comment"># 使用锚点偏移量</span></span><br><span class="line">now + MonthEnd() <span class="comment"># Timestamp('2011-12-31 00:00:00')</span></span><br><span class="line"><span class="comment"># 通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”</span></span><br><span class="line">offset = MonthEnd()</span><br><span class="line">offset.rollforward(now) <span class="comment"># Timestamp('2011-11-30 00:00:00')</span></span><br><span class="line">offset.rollback(now) <span class="comment"># Timestamp('2011-10-31 00:00:00')</span></span><br></pre></td></tr></table></figure>
<h3 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h3><h4 id="时区本地化和转换"><a href="#时区本地化和转换" class="headerlink" title="时区本地化和转换"></a>时区本地化和转换</h4><p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。pandas包装了pytz的功能。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">pytz.common_timezones[<span class="number">-5</span>:]<span class="comment"># ['US/Eastern', 'US/Hawaii', 'US/Mountain', 'US/Pacific', 'UTC']</span></span><br><span class="line">tz = pytz.timezone(<span class="string">'America/New_York'</span>) <span class="comment"># &lt;DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD&gt;</span></span><br></pre></td></tr></table></figure>
<p>默认情况下，pandas中的时间序列是单纯（naive）的时区,其索引的tz字段为None。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">print(ts.index.tz) <span class="comment"># None</span></span><br><span class="line"><span class="comment"># 可以指定时区</span></span><br><span class="line">pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'D'</span>, tz=<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 通过tz_localize方法从单纯转换到本地化</span></span><br><span class="line">ts_utc = ts.tz_localize(<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区</span></span><br><span class="line">ts_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br><span class="line"><span class="comment"># 独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware）</span></span><br><span class="line">stamp = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>)</span><br><span class="line">stamp_utc = stamp.tz_localize(<span class="string">'utc'</span>)</span><br><span class="line">stamp_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br></pre></td></tr></table></figure>
<p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/7/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'B'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">'Europe/London'</span>)</span><br><span class="line">ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">'Europe/Moscow'</span>)</span><br><span class="line">result = ts1 + ts2</span><br></pre></td></tr></table></figure>
<h3 id="时期及其算术运算"><a href="#时期及其算术运算" class="headerlink" title="时期及其算术运算"></a>时期及其算术运算</h3><p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及频率符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = pd.Period(<span class="number">2007</span>, freq=<span class="string">'A-DEC'</span>) <span class="comment">#表示的是从2007年1月1日到2007年12月31日之间的整段时间</span></span><br><span class="line"><span class="comment"># 对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果</span></span><br><span class="line">p + <span class="number">5</span>  <span class="comment"># Period('2012', 'A-DEC')</span></span><br><span class="line"><span class="comment"># period_range函数可用于创建规则的时期范围</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-06-30'</span>, freq=<span class="string">'M'</span>) <span class="comment"># 返回PeriodIndex对象</span></span><br><span class="line"><span class="comment"># 字符串数组，可以使用PeriodIndex类：</span></span><br><span class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</span><br><span class="line">index = pd.PeriodIndex(values, freq=<span class="string">'Q-DEC'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h4><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-DEC'</span>)<span class="comment"># Period('2007', 'A-DEC')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)<span class="comment"># Period('2007-01', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'end'</span>)<span class="comment">#  Period('2007-12', 'M')</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-JUN'</span>)</span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'start'</span>)  <span class="comment"># Period('2006-07', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2007-06', 'M')</span></span><br><span class="line"><span class="comment"># 完整的PeriodIndex或TimeSeries的频率转换方式也是如此</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq=<span class="string">'A-DEC'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h4><p>时期”2012Q4”根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）</span></span><br><span class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>) <span class="comment"># Period('2012Q4', 'Q-JAN')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>) <span class="comment"># Period('2011-11-01', 'D')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2012-01-31', 'D')</span></span><br><span class="line"><span class="comment"># 获取该季度倒数第二个工作日下午4点的时间戳</span></span><br><span class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span> <span class="comment"># Period('2012-01-30 16:00', 'T')</span></span><br><span class="line">p4pm.to_timestamp() <span class="comment"># Timestamp('2012-01-30 16:00:00')</span></span><br></pre></td></tr></table></figure>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="将Timestamp转换为Period（及其反向过程）"><a href="#将Timestamp转换为Period（及其反向过程）" class="headerlink" title="将Timestamp转换为Period（及其反向过程）"></a>将Timestamp转换为Period（及其反向过程）</h4><p>to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引，要转换回时间戳，使用to_timestamp》</p>
<h4 id="通过数组创建PeriodIndex"><a href="#通过数组创建PeriodIndex" class="headerlink" title="通过数组创建PeriodIndex"></a>通过数组创建PeriodIndex</h4>]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>pandas</tag>
      </tags>
  </entry>
</search>
