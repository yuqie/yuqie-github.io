<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="简书： https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;04d180d90a3f github： https:&#x2F;&#x2F;github.com&#x2F;iamseancheney&#x2F;python_for_data_analysis_2nd_chinese_version gitbook： https:&#x2F;&#x2F;seancheney.gitbook.io&#x2F;python-for-data-analysis-2nd&#x2F; 第2">
<meta property="og:type" content="article">
<meta property="og:title" content="《利用Python进行数据分析》学习">
<meta property="og:url" content="http://yoursite.com/2020/08/23/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Ringinmay&#39;s Blog">
<meta property="og:description" content="简书： https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;04d180d90a3f github： https:&#x2F;&#x2F;github.com&#x2F;iamseancheney&#x2F;python_for_data_analysis_2nd_chinese_version gitbook： https:&#x2F;&#x2F;seancheney.gitbook.io&#x2F;python-for-data-analysis-2nd&#x2F; 第2">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-e179f5ea00e50691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-c72b11add9b8ccf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-3e3a8c6b9c5040fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/892/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-9fb5f25b33166acf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-27a30ac3e7d262a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-100f9a20c1536553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-522e2b688b755ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-980efe5d98ecc4d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-111823d8767a104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-28274484129f0ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-d25bd6e730afeb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/867/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1075/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/929/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1187/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-087fe67bf6db0701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-d1f0d4ed3e895016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-efbb80a793759fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/739/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1167/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="og:image" content="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">
<meta property="article:published_time" content="2020-08-23T15:27:15.000Z">
<meta property="article:modified_time" content="2020-08-26T11:26:55.494Z">
<meta property="article:author" content="QQAI">
<meta property="article:tag" content="python">
<meta property="article:tag" content="numpy">
<meta property="article:tag" content="pandas">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp">

<link rel="canonical" href="http://yoursite.com/2020/08/23/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>《利用Python进行数据分析》学习 | Ringinmay's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ringinmay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Home is behind, the world ahead</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/08/23/%E3%80%8A%E5%88%A9%E7%94%A8Python%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E3%80%8B%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《利用Python进行数据分析》学习
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-08-23 23:27:15" itemprop="dateCreated datePublished" datetime="2020-08-23T23:27:15+08:00">2020-08-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-08-26 19:26:55" itemprop="dateModified" datetime="2020-08-26T19:26:55+08:00">2020-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">数据分析</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>简书： <a href="https://www.jianshu.com/p/04d180d90a3f" target="_blank" rel="noopener">https://www.jianshu.com/p/04d180d90a3f</a></p>
<p>github： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fiamseancheney%2Fpython_for_data_analysis_2nd_chinese_version" target="_blank" rel="noopener">https://github.com/iamseancheney/python_for_data_analysis_2nd_chinese_version</a></p>
<p>gitbook： <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fseancheney.gitbook.io%2Fpython-for-data-analysis-2nd%2F" target="_blank" rel="noopener">https://seancheney.gitbook.io/python-for-data-analysis-2nd/</a></p>
<h2 id="第2章-Python语法基础，IPython和Jupyter-Notebooks"><a href="#第2章-Python语法基础，IPython和Jupyter-Notebooks" class="headerlink" title="第2章 Python语法基础，IPython和Jupyter Notebooks"></a>第2章 Python语法基础，IPython和Jupyter Notebooks</h2><h3 id="IPython键盘快捷键"><a href="#IPython键盘快捷键" class="headerlink" title="IPython键盘快捷键"></a>IPython键盘快捷键</h3><a id="more"></a>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9ed3866ea25c11f8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e179f5ea00e50691.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/491/format/webp" alt="img"></p>
<h3 id="IPython魔术命令"><a href="#IPython魔术命令" class="headerlink" title="IPython魔术命令"></a>IPython魔术命令</h3><p>IPython中特殊的命令（Python中没有）被称作“魔术”命令。</p>
<p>line magic %</p>
<p>cell magic %%</p>
<p><code>%timeit</code>可以测量任何Python语句的执行时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">20</span>]: a = np.random.randn(<span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: %timeit np.dot(a, a)</span><br><span class="line"><span class="number">10000</span> loops, best of <span class="number">3</span>: <span class="number">20.9</span> µs per loop</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c72b11add9b8ccf8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp" alt="img"></p>
<h3 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h3><p>IPython中集成了数据可视化和其它用户界面库，比如matplotlib。</p>
<p><code>%matplotlib</code>魔术函数配置了IPython shell和Jupyter notebook中的matplotlib。</p>
<p>在JUpyter中，命令有所不同：<code>%matplotlib inline</code></p>
<h3 id="Python语法基础"><a href="#Python语法基础" class="headerlink" title="Python语法基础"></a>Python语法基础</h3><h4 id="使用缩进"><a href="#使用缩进" class="headerlink" title="使用缩进"></a>使用缩进</h4><p>建议使用四个空格作为默认的缩进，可以使用tab代替四个空格。</p>
<h4 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h4><h4 id="位置和关键词参数"><a href="#位置和关键词参数" class="headerlink" title="位置和关键词参数"></a>位置和关键词参数</h4><p><code>result = f(a, b, c, d=5, e=&#39;foo&#39;)</code></p>
<h4 id="变量和参数传递："><a href="#变量和参数传递：" class="headerlink" title="变量和参数传递："></a>变量和参数传递：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = a</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3e3a8c6b9c5040fc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/892/format/webp" alt="img"></p>
<p>在Python中，a和b实际上是同一个对象.赋值也被称作绑定，我们是把一个名字绑定给一个对象。变量名有时可能被称为绑定变量。</p>
<p>将对象作为参数传递给函数时，新的局域变量创建了对原始对象的引用，而不是复制。如果在函数里绑定一个新对象到一个变量，这个变动不会反映到上一层。</p>
<h4 id="强类型化语言"><a href="#强类型化语言" class="headerlink" title="强类型化语言"></a>强类型化语言</h4><p><code>&#39;5&#39; + 5</code> 会报错，即每个对象都有明确的类型（或类），默许转换只会发生在特定的情况下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">17</span>]: a = <span class="number">4.5</span></span><br><span class="line">In [<span class="number">18</span>]: b = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># String formatting, to be visited later</span></span><br><span class="line">In [<span class="number">19</span>]: print(<span class="string">'a is &#123;0&#125;, b is &#123;1&#125;'</span>.format(type(a), type(b)))</span><br><span class="line">a is &lt;class 'float'&gt;, b is &lt;class 'int'&gt;</span><br><span class="line"></span><br><span class="line">In [<span class="number">20</span>]: a / b</span><br><span class="line">Out[<span class="number">20</span>]: <span class="number">2.25</span></span><br></pre></td></tr></table></figure>

<p>可以用<code>isinstance</code>函数检查对象是某个类型的实例。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">isinstance(a, int) <span class="comment">#检查对象是否是某个类型的实例</span></span><br><span class="line">isinstance(a, (int, float)) <span class="comment">#检查对象的类型是否在元组中</span></span><br></pre></td></tr></table></figure>

<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python的对象通常都有属性（其它存储在对象内部的Python对象）和方法（对象的附属函数可以访问对象的内部数据）</p>
<p>可以用<code>obj.attribute_name</code>访问属性和方法，也可以用<code>getattr</code>函数，通过名字访问属性和方法。</p>
<h4 id="鸭子类型"><a href="#鸭子类型" class="headerlink" title="鸭子类型"></a>鸭子类型</h4><p>不关心对象的类型，只关心对象是否有某些方法或用途。这通常被称为“鸭子类型”，来自“走起来像鸭子、叫起来像鸭子，那么它就是鸭子”的说法。</p>
<p>通过验证一个对象是否遵循迭代协议，判断它是可迭代的。对于许多对象，这意味着它有一个<code>__iter__</code>魔术方法，其它更好的判断方法是使用<code>iter</code>函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isiterable</span><span class="params">(obj)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        iter(obj)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> TypeError: <span class="comment"># not iterable</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>可以用这个功能编写可以接受多种输入类型的函数。例如编写一个函数可以接受任意类型的序列（list、tuple、ndarray）或是迭代器。先检验对象是否是列表（或是NUmPy数组），如果不是，将其转变成列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure>

<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象，可以使用<code>is</code>方法，<code>is not</code>可以判断两个对象是不同的。使用<code>is</code>比较与<code>==</code>运算符不同，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">In [<span class="number">36</span>]: b = a</span><br><span class="line"></span><br><span class="line">In [<span class="number">37</span>]: c = list(a) <span class="comment"># 因为list总是创建一个新的Python列表（即复制）</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">38</span>]: a <span class="keyword">is</span> b</span><br><span class="line">Out[<span class="number">38</span>]: <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">39</span>]: a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line">Out[<span class="number">39</span>]: <span class="literal">True</span></span><br><span class="line">       </span><br><span class="line">In [<span class="number">40</span>]: a == c</span><br><span class="line">Out[<span class="number">40</span>]: <span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9fb5f25b33166acf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/811/format/webp" alt="img"></p>
<h4 id="可变与不可变对象"><a href="#可变与不可变对象" class="headerlink" title="可变与不可变对象"></a>可变与不可变对象</h4><p>Python中的大多数对象，如列表、字典、NumPy数组，和用户定义的类型（类），都是可变的，意味着这些对象或包含的值可以被修改。其它例如<strong>字符串和元组</strong> ，是不可变的。</p>
<h4 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h4><p>Python的标准库中有一些内建的类型，用于处理数值数据、字符串、布尔值，和日期时间。这些单值类型被称为标量类型。</p>
<p>日期和时间处理会是由标准库的<code>datetime</code>模块提供的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-27a30ac3e7d262a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/808/format/webp" alt="img"></p>
<h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p>Python的主要数值类型是<code>int</code>和<code>float</code></p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>反斜杠是转义字符，意思是它被用来表示特殊字符。</p>
<p>如果字符串中包含许多反斜杠，但没有特殊字符，可以在字符串前面加一个r，表明字符就是它自身。</p>
<p>字符串的模板化或格式化：</p>
<ol>
<li><p><code>format</code>方法，可以替换格式化的参数为字符串，产生一个新的字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">74</span>]: template = <span class="string">'&#123;0:.2f&#125; &#123;1:s&#125; are worth US$&#123;2:d&#125;'</span></span><br><span class="line">In [<span class="number">75</span>]: template.format(<span class="number">4.5560</span>, <span class="string">'Argentine Pesos'</span>, <span class="number">1</span>)</span><br><span class="line">Out[<span class="number">75</span>]: <span class="string">'4.56 Argentine Pesos are worth US$1'</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="字节和Unicode"><a href="#字节和Unicode" class="headerlink" title="字节和Unicode"></a>字节和Unicode</h4><p>在Python 3及以上版本中，Unicode是一级的字符串类型，这样可以更一致的处理ASCII和Non-ASCII文本。在老的Python版本中，字符串都是字节，不使用Unicode编码。</p>
<p>可以用<code>encode</code>将Unicode字符串编码为UTF-8，<code>decode</code> 将UTF-8解码为Unicode编码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">76</span>]: val = <span class="string">"español"</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">77</span>]: val</span><br><span class="line">Out[<span class="number">77</span>]: <span class="string">'español'</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">78</span>]: val_utf8 = val.encode(<span class="string">'utf-8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">79</span>]: val_utf8</span><br><span class="line">Out[<span class="number">79</span>]: <span class="string">b'espa\xc3\xb1ol'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">80</span>]: type(val_utf8)</span><br><span class="line">Out[<span class="number">80</span>]: bytes</span><br><span class="line"></span><br><span class="line">In [<span class="number">81</span>]: val_utf8.decode(<span class="string">'utf-8'</span>)</span><br><span class="line">Out[<span class="number">81</span>]: <span class="string">'español'</span></span><br></pre></td></tr></table></figure>

<p><strong>可以在字节文本前加上b</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">85</span>]: bytes_val = <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">86</span>]: bytes_val</span><br><span class="line">Out[<span class="number">86</span>]: <span class="string">b'this is bytes'</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">87</span>]: decoded = bytes_val.decode(<span class="string">'utf8'</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">88</span>]: decoded  <span class="comment"># this is str (Unicode) now</span></span><br><span class="line">Out[<span class="number">88</span>]: <span class="string">'this is bytes'</span></span><br></pre></td></tr></table></figure>

<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>None是Python的空值类型。如果一个函数没有明确的返回值，就会默认返回None，None也常常作为函数的默认参数。</p>
<h4 id="时间和日期"><a href="#时间和日期" class="headerlink" title="时间和日期"></a>时间和日期</h4><p>Python内建的<code>datetime</code>模块提供了<code>datetime</code>、<code>date</code>和<code>time</code>类型。<code>datetime</code>类型结合了<code>date</code>和<code>time</code>，是最常使用的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">102</span>]: <span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, date, time</span><br><span class="line"></span><br><span class="line">In [<span class="number">103</span>]: dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">104</span>]: dt.day</span><br><span class="line">Out[<span class="number">104</span>]: <span class="number">29</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">105</span>]: dt.minute</span><br><span class="line">Out[<span class="number">105</span>]: <span class="number">30</span></span><br><span class="line">    </span><br><span class="line">In [<span class="number">106</span>]: dt.date()</span><br><span class="line">Out[<span class="number">106</span>]: datetime.date(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">107</span>]: dt.time()</span><br><span class="line">Out[<span class="number">107</span>]: datetime.time(<span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br></pre></td></tr></table></figure>

<p><code>strftime</code>方法可以将datetime格式化为字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">108</span>]: dt.strftime(<span class="string">'%m/%d/%Y %H:%M'</span>)</span><br><span class="line">Out[<span class="number">108</span>]: <span class="string">'10/29/2011 20:30'</span></span><br></pre></td></tr></table></figure>

<p><code>strptime</code>可以将字符串转换成<code>datetime</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">109</span>]: datetime.strptime(<span class="string">'20091031'</span>, <span class="string">'%Y%m%d'</span>)</span><br><span class="line">Out[<span class="number">109</span>]: datetime.datetime(<span class="number">2009</span>, <span class="number">10</span>, <span class="number">31</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-100f9a20c1536553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/692/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># repalce进行替换</span></span><br><span class="line">In [<span class="number">110</span>]: dt.replace(minute=<span class="number">0</span>, second=<span class="number">0</span>)</span><br><span class="line">Out[<span class="number">110</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 两个datetime对象的差会产生一个datetime.timedelta类型：</span></span><br><span class="line">In [<span class="number">111</span>]: dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line">In [<span class="number">112</span>]: delta = dt2 - dt</span><br><span class="line">In [<span class="number">113</span>]: delta</span><br><span class="line">Out[<span class="number">113</span>]: datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>) <span class="comment"># 17天、7179秒</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">114</span>]: type(delta)</span><br><span class="line">Out[<span class="number">114</span>]: datetime.timedelta</span><br><span class="line"><span class="comment"># 可以将timedelta添加到datetime，产生一个新的偏移datetime </span></span><br><span class="line">In [<span class="number">115</span>]: dt</span><br><span class="line">Out[<span class="number">115</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">In [<span class="number">116</span>]: dt + delta</span><br><span class="line">Out[<span class="number">116</span>]: datetime.datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br></pre></td></tr></table></figure>

<h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><h5 id="if语句："><a href="#if语句：" class="headerlink" title="if语句："></a>if语句：</h5><p>if elif else</p>
<h5 id="for循环："><a href="#for循环：" class="headerlink" title="for循环："></a>for循环：</h5><p>可以用continue使for循环提前，跳过剩下的部分；可以用<code>break</code>跳出for循环，break只中断for循环的最内层，其余的for循环仍会运行。</p>
<h5 id="while循环："><a href="#while循环：" class="headerlink" title="while循环："></a>while循环：</h5><h5 id="pass："><a href="#pass：" class="headerlink" title="pass："></a>pass：</h5><p>Python中的非操作语句。代码块不需要任何动作时可以使用（作为未执行代码的占位符）；因为Python需要使用空白字符划定代码块，所以需要pass。</p>
<h4 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h4><p>Python中的三元表达式可以将if-else语句放到一行里，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = true-expr <span class="keyword">if</span> condition <span class="keyword">else</span> false-expr</span><br></pre></td></tr></table></figure>

<h2 id="第3章-Python的数据结构、函数和文件"><a href="#第3章-Python的数据结构、函数和文件" class="headerlink" title="第3章 Python的数据结构、函数和文件"></a>第3章 Python的数据结构、函数和文件</h2><h3 id="数据结构和序列"><a href="#数据结构和序列" class="headerlink" title="数据结构和序列"></a>数据结构和序列</h3><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>元组是一个固定长度，不可改变的Python序列对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建元组</span></span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line"><span class="comment"># 当用复杂的表达式定义元组，最好将值放到圆括号内</span></span><br><span class="line">nested_tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment"># 用tuple可以将任意序列或迭代器转换成元组</span></span><br><span class="line">tuple([<span class="number">4</span>, <span class="number">0</span>, <span class="number">2</span>]) <span class="comment"># (4, 0, 2)</span></span><br><span class="line">tup = tuple(<span class="string">'string'</span>) <span class="comment"># ('s', 't', 'r', 'i', 'n', 'g')</span></span><br><span class="line"><span class="comment"># 可以用方括号访问元组中的元素，序列是从0开始</span></span><br><span class="line">tup[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改</span></span><br><span class="line">tup = tuple([<span class="string">'foo'</span>, [<span class="number">1</span>, <span class="number">2</span>], <span class="literal">True</span>])</span><br><span class="line">tup[<span class="number">2</span>] = <span class="literal">False</span>  <span class="comment"># 会报错</span></span><br><span class="line"><span class="comment"># 如果元组中的某个对象是可变的，比如列表，可以在原位进行修改</span></span><br><span class="line">tup[<span class="number">1</span>].append(<span class="number">3</span>) <span class="comment"># ('foo', [1, 2, 3], True)</span></span><br><span class="line"><span class="comment"># 可以用加号运算符将元组串联起来</span></span><br><span class="line">(<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>) + (<span class="number">6</span>, <span class="number">0</span>) + (<span class="string">'bar'</span>,) <span class="comment"># (4, None, 'foo', 6, 0, 'bar')</span></span><br><span class="line"><span class="comment"># 元组乘以一个整数，像列表一样，会将几个元组的复制串联起来</span></span><br><span class="line">(<span class="string">'foo'</span>, <span class="string">'bar'</span>) * <span class="number">4</span> <span class="comment"># ('foo', 'bar', 'foo', 'bar', 'foo', 'bar', 'foo', 'bar')</span></span><br><span class="line"><span class="comment"># 对象本身并没有被复制，只是引用了它</span></span><br></pre></td></tr></table></figure>

<h5 id="拆分元组"><a href="#拆分元组" class="headerlink" title="拆分元组"></a>拆分元组</h5><p>将元组赋值给类似元组的变量，Python会试图拆分等号右边的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">a,b,c = tup</span><br><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, (<span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line">a, b, (c, d) = tup</span><br><span class="line"><span class="comment"># 变量拆分常用来迭代元组或列表序列</span></span><br><span class="line">seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 另一个常见用法是从函数返回多个值</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 高级的元组拆分功能，例如，从元组的开头“摘取”几个元素。它使用了特殊的语法*rest</span></span><br><span class="line">values = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, *rest = values</span><br><span class="line">rest <span class="comment"># [3, 4, 5]</span></span><br><span class="line"><span class="comment"># rest的部分是想要舍弃的部分，rest的名字不重要。作为惯用写法，许多Python程序员会将不需要的变量使用下划线：</span></span><br><span class="line">a, b, *_ = values</span><br></pre></td></tr></table></figure>

<p>在Python中，替换可以这样做:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure>

<h5 id="tuple方法"><a href="#tuple方法" class="headerlink" title="tuple方法"></a>tuple方法</h5><p>元组的大小和内容不能修改，所以其实例方法都很轻量。其中一个很有用的就是<code>count</code>（也适用于列表），它可以统计某个值得出现频率：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>) <span class="comment"># 4</span></span><br></pre></td></tr></table></figure>

<h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><p>列表的长度可变、内容可以被修改。可以用方括号定义，或用<code>list</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_list = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="literal">None</span>]</span><br><span class="line">tup = (<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>)</span><br><span class="line">b_list = list(tup) <span class="comment"># ['foo', 'bar', 'baz']</span></span><br></pre></td></tr></table></figure>

<p><code>list</code>函数常用来在数据处理中实体化迭代器或生成器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gen = range(<span class="number">10</span>)</span><br><span class="line">list(gen) <span class="comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</span></span><br></pre></td></tr></table></figure>

<p><code>append</code>在列表末尾添加元素</p>
<p><code>insert</code>在特定的位置插入元素，插入的序号必须在0和列表长度之间</p>
<p><strong>注意：</strong> 警告：与<code>append</code>相比，<code>insert</code>耗费的计算量大，因为需要对后续元素的引用必须在内部迁移，以便为新元素提供空间。如果要在序列的头部和尾部插入元素，可以使用双尾部队列<code>collections.deque</code>。</p>
<p><code>pop</code>, <code>insert</code>的逆运算，移除并返回指定位置的元素</p>
<p><code>remove</code>去除某个值，<code>remove</code>会先寻找第一个值并除去</p>
<p><strong>注意：</strong> 如果不考虑性能，使用<code>append</code>和<code>remove</code>，可以把Python的列表当做完美的“多重集”数据结构。</p>
<p><code>in</code> 和<code>not in</code>检查列表是否包含某个值， </p>
<p><strong>注意：</strong> 在列表中检查是否存在某个值远比字典和集合速度慢，因为Python是线性搜索列表中的值，但在字典和集合中，在同样的时间内还可以检查其它项（基于哈希表）</p>
<h5 id="串联和组合列表"><a href="#串联和组合列表" class="headerlink" title="串联和组合列表"></a>串联和组合列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用加号将两个列表串联起来</span></span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>] + [<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line">[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br><span class="line"><span class="comment"># 用extend方法可以追加多个元素</span></span><br><span class="line">x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>]</span><br><span class="line">x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line"><span class="comment">## 通过加法将列表串联的计算量较大，因为要新建一个列表，并且要复制对象。用extend追加元素，尤其是到一个大列表中，更为可取。</span></span><br></pre></td></tr></table></figure>

<h5 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用sort函数将一个列表原地排序（不创建新的对象）</span></span><br><span class="line">a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">a.sort()</span><br><span class="line"><span class="comment"># sort 二级排序key</span></span><br><span class="line">b = [<span class="string">'saw'</span>, <span class="string">'small'</span>, <span class="string">'He'</span>, <span class="string">'foxes'</span>, <span class="string">'six'</span>]</span><br><span class="line">b.sort(key=len)</span><br><span class="line"><span class="comment"># sorted函数，它可以产生一个排好序的序列副本</span></span><br></pre></td></tr></table></figure>

<h5 id="二分搜索和维护已排序的列表"><a href="#二分搜索和维护已排序的列表" class="headerlink" title="二分搜索和维护已排序的列表"></a>二分搜索和维护已排序的列表</h5><p><code>bisect</code>模块支持二分查找，和向已排序的列表插入值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line">c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">7</span>]</span><br><span class="line"><span class="comment"># bisect.bisect可以找到插入值后仍保证排序的位置</span></span><br><span class="line">bisect.bisect(c, <span class="number">5</span>) <span class="comment"># 6</span></span><br><span class="line"><span class="comment"># bisect.insort向这个位置插入值</span></span><br><span class="line">bisect.insort(c, <span class="number">6</span>)</span><br><span class="line"><span class="comment">##  bisect模块不会检查列表是否已排好序，进行检查的话会耗费大量计算。因此，对未排序的列表使用bisect不会产生错误，但结果不一定正确。</span></span><br></pre></td></tr></table></figure>

<h5 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h5><p>用切边可以选取大多数序列类型的一部分，切片的基本形式是在方括号中使用<code>start:stop</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">seq[<span class="number">1</span>:<span class="number">5</span>] <span class="comment"># [2, 3, 7, 5]</span></span><br><span class="line"><span class="comment"># 切片也可以被序列赋值</span></span><br><span class="line">seq[<span class="number">3</span>:<span class="number">4</span>] = [<span class="number">6</span>, <span class="number">3</span>]</span><br><span class="line"><span class="comment"># start或stop都可以被省略，省略之后，分别默认序列的开头和结尾</span></span><br><span class="line">seq[<span class="number">3</span>:] </span><br><span class="line"><span class="comment"># 负数表明从后向前切片</span></span><br><span class="line">seq[<span class="number">-4</span>:]  <span class="comment"># [5, 6, 0, 1]</span></span><br><span class="line"><span class="comment"># 第二个冒号后面使用step，可以隔几个取一个元素</span></span><br><span class="line">seq[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 使用-1，它可以将列表或元组颠倒过来</span></span><br><span class="line">seq[::<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-522e2b688b755ff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="序列函数"><a href="#序列函数" class="headerlink" title="序列函数"></a>序列函数</h4><p>Python有一些有用的序列函数。</p>
<h5 id="enumerate函数"><a href="#enumerate函数" class="headerlink" title="enumerate函数"></a>enumerate函数</h5><p>迭代一个序列时，想要跟踪当前项的序号，可以使用Python内建的<code>enumerate</code>函数，可以返回<code>(i, value)</code>元组序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</span><br><span class="line">   <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>索引数据时，使用<code>enumerate</code>的一个好方法是计算序列（唯一的）<code>dict</code>映射到位置的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    mapping[v] = i</span><br><span class="line">mapping <span class="comment">#  &#123;'bar': 1, 'baz': 2, 'foo': 0&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="sorted函数"><a href="#sorted函数" class="headerlink" title="sorted函数"></a>sorted函数</h5><p>返回一个<strong>新的</strong> 排好序的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">b = sorted(a)</span><br><span class="line">b <span class="comment"># [0, 1, 2, 2, 3, 6, 7]</span></span><br><span class="line">a <span class="comment"># [7, 1, 2, 6, 0, 3, 2]</span></span><br></pre></td></tr></table></figure>

<h5 id="zip函数"><a href="#zip函数" class="headerlink" title="zip函数"></a>zip函数</h5><p>将多个列表、元组或其它序列成对组合成一个元组列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seq1 = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">seq2 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">zipped = zip(seq1, seq2)</span><br><span class="line">list(zipped) <span class="comment"># [('foo', 'one'), ('bar', 'two'), ('baz', 'three')]</span></span><br><span class="line"><span class="comment"># zip可以处理任意多的序列，元素的个数取决于最短的序列</span></span><br><span class="line">seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line">list(zip(seq1, seq2, seq3)) <span class="comment">#  [('foo', 'one', False), ('bar', 'two', True)]</span></span><br></pre></td></tr></table></figure>

<p><code>zip</code>可以被用来解压序列</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pitchers = [(<span class="string">'Nolan'</span>, <span class="string">'Ryan'</span>), (<span class="string">'Roger'</span>, <span class="string">'Clemens'</span>), (<span class="string">'Schilling'</span>, <span class="string">'Curt'</span>)]</span><br><span class="line">first_names, last_names = zip(*pitchers)</span><br><span class="line">first_names  <span class="comment"># ('Nolan', 'Roger', 'Schilling')</span></span><br><span class="line">last_names   <span class="comment"># ('Ryan', 'Clemens', 'Curt')</span></span><br></pre></td></tr></table></figure>

<p><code>zip</code>的常见用法之一是同时迭代多个序列，可能结合<code>enumerate</code>使用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, (a, b) <span class="keyword">in</span> enumerate(zip(seq1, seq2)):     </span><br><span class="line">    print(<span class="string">'&#123;0&#125;: &#123;1&#125;, &#123;2&#125;'</span>.format(i, a, b))</span><br><span class="line"><span class="number">0</span>: foo, one</span><br><span class="line"><span class="number">1</span>: bar, two</span><br><span class="line"><span class="number">2</span>: baz, three</span><br></pre></td></tr></table></figure>

<h5 id="reversed函数"><a href="#reversed函数" class="headerlink" title="reversed函数"></a>reversed函数</h5><p><code>reversed</code>是一个生成器（zip也是），可以从后向前迭代一个序列。注意：只有实体化（即列表或for循环）之后才能创建翻转的序列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(reversed(range(<span class="number">10</span>))) <span class="comment"># [9, 8, 7, 6, 5, 4, 3, 2, 1, 0]</span></span><br></pre></td></tr></table></figure>

<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>也称为：哈希映射或关联数组。它是键值对的大小可变集合，键和值都是Python对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由&#123;&#125;定义</span></span><br><span class="line">d1 = &#123;<span class="string">'a'</span> : <span class="string">'some value'</span>, <span class="string">'b'</span> : [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">d1[<span class="number">7</span>] = <span class="string">'an integer'</span></span><br><span class="line"><span class="comment"># 访问</span></span><br><span class="line">d1[<span class="string">'b'</span>]  <span class="comment"># [1,2,3,4]</span></span><br><span class="line"><span class="comment"># 检查字典中是否包含某个键</span></span><br><span class="line"><span class="string">'b'</span> <span class="keyword">in</span> d1</span><br><span class="line"><span class="comment"># 用del关键字或pop方法（返回值的同时删除键）删除值</span></span><br><span class="line"><span class="keyword">del</span> d1[<span class="string">'b'</span>]</span><br><span class="line">ret = d1.pop(<span class="string">'b'</span>)  <span class="comment"># ret: [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment"># keys和values是字典的键和值的迭代器方法。虽然键值对没有顺序，这两个方法可以用相同的顺序输出键和值：</span></span><br><span class="line">list(d1.keys()) <span class="comment"># ['a', 'b', 7]</span></span><br><span class="line">list(d1.values()) <span class="comment"># ['some value', [1, 2, 3, 4], 'an integer']</span></span><br><span class="line"><span class="comment"># update方法可以将一个字典与另一个融合</span></span><br><span class="line">d1.update(&#123;<span class="string">'b'</span> : <span class="string">'foo'</span>, <span class="string">'c'</span> : <span class="number">12</span>&#125;) <span class="comment"># 键'b'对应的值会改变</span></span><br><span class="line"><span class="comment"># update方法是原地改变字典，任何传递给update的键的旧的值都会被舍弃。</span></span><br></pre></td></tr></table></figure>

<h5 id="用序列创建字典"><a href="#用序列创建字典" class="headerlink" title="用序列创建字典"></a>用序列创建字典</h5><p>将两个序列配对组合成字典</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mapping = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> zip(key_list, value_list):</span><br><span class="line">    mapping[key] = val</span><br></pre></td></tr></table></figure>

<p>字典本质上是2元元组的集合，所以dict可以接受2元元组的列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mapping = dict(zip(range(<span class="number">5</span>), reversed(range(<span class="number">5</span>))))</span><br></pre></td></tr></table></figure>

<h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>dict的方法get和pop可以取默认值进行返回。get默认会返回None，如果不存在键，pop会抛出一个例外。</p>
<p><code>value = some_dict.get(key, default_value)</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">words = [<span class="string">'apple'</span>, <span class="string">'bat'</span>, <span class="string">'bar'</span>, <span class="string">'atom'</span>, <span class="string">'book'</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure>

<p><code>collections</code>模块有一个很有用的类，<code>defaultdict</code>，它可以进一步简化上面。传递类型或函数以生成每个位置的默认值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure>

<h5 id="有效的键对类型"><a href="#有效的键对类型" class="headerlink" title="有效的键对类型"></a>有效的键对类型</h5><p>字典的值可以是任意Python对象，而键通常是不可变的标量类型（整数、浮点型、字符串）或元组（元组中的对象必须是不可变的）。这被称为<strong>“可哈希性”</strong> 。可以用<code>hash</code>函数检测一个对象是否是可哈希的（可被用作字典的键）：</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>无序的不可重复的元素的集合。可看成只有键没有值的字典。可以通过set函数或使用尖括号set语句创建集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>]) <span class="comment"># &#123;1, 2, 3&#125;</span></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125; <span class="comment"># &#123;1, 2, 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>集合支持合并、交集、差分和对称差等数学集合运算。</p>
<h5 id="合并（union方法，或者-运算符）"><a href="#合并（union方法，或者-运算符）" class="headerlink" title="合并（union方法，或者|运算符）"></a>合并（<code>union</code>方法，或者<code>|</code>运算符）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.union(b) <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br><span class="line">a | b <span class="comment"># &#123;1, 2, 3, 4, 5, 6, 7, 8&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="交集（intersection或-amp-运算符）"><a href="#交集（intersection或-amp-运算符）" class="headerlink" title="交集（intersection或&amp;运算符）"></a>交集（<code>intersection</code>或<code>&amp;</code>运算符）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.intersection(b) <span class="comment"># &#123;3, 4, 5&#125;</span></span><br><span class="line">a &amp; b <span class="comment"># &#123;3, 4, 5&#125;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-980efe5d98ecc4d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/695/format/webp" alt="img"></p>
<p>所有逻辑集合操作都有另外的原地实现方法，可以直接用结果替代集合的内容，对于大的集合，这么做效率更高：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line">c = a.copy()  <span class="comment"># 硬copy</span></span><br><span class="line">c |= b</span><br><span class="line">d = a.copy()</span><br><span class="line">d &amp;= b</span><br></pre></td></tr></table></figure>

<p>与字典的键类似，集合元素通常都是不可变的。要获得类似列表的元素，必须转换成元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">my_set = &#123;tuple(my_data)&#125;</span><br><span class="line"><span class="comment"># 直接 my_set = &#123;[1, 2, 3, 4]&#125; 会报错</span></span><br></pre></td></tr></table></figure>

<h5 id="列表，集合和字典推导式"><a href="#列表，集合和字典推导式" class="headerlink" title="列表，集合和字典推导式"></a>列表，集合和字典推导式</h5><p>该特性允许用户从一个集合过滤元素，形成列表，集合或字典，在传递参数的过程中还可以修改元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">[expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br><span class="line"><span class="comment"># 字典推导式</span></span><br><span class="line">dict_comp = &#123;key-expr : value-expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># 例子</span></span><br><span class="line">loc_mapping = &#123;val : index <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(strings)&#125;</span><br><span class="line"><span class="comment"># 集合推导式</span></span><br><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br><span class="line"><span class="comment"># map函数</span></span><br><span class="line">strings = [<span class="string">'a'</span>, <span class="string">'as'</span>, <span class="string">'bat'</span>, <span class="string">'car'</span>, <span class="string">'dove'</span>, <span class="string">'python'</span>]</span><br><span class="line">unique_lengths = &#123;len(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line">set(map(len, strings)) <span class="comment"># map 返回可迭代器，也可以list(map(len,strings))</span></span><br></pre></td></tr></table></figure>

<h5 id="嵌套列表推导式"><a href="#嵌套列表推导式" class="headerlink" title="嵌套列表推导式"></a>嵌套列表推导式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">all_data = [[<span class="string">'John'</span>, <span class="string">'Emily'</span>, <span class="string">'Michael'</span>, <span class="string">'Mary'</span>, <span class="string">'Steven'</span>],[<span class="string">'Maria'</span>, <span class="string">'Juan'</span>, <span class="string">'Javier'</span>, <span class="string">'Natalia'</span>, <span class="string">'Pilar'</span>]]</span><br><span class="line">result = [name <span class="keyword">for</span> names <span class="keyword">in</span> all_data <span class="keyword">for</span> name <span class="keyword">in</span> names <span class="keyword">if</span> name.count(<span class="string">'e'</span>) &gt;= <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 将一个整数元组的列表扁平化成了一个整数列表</span></span><br><span class="line">some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line">[[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples] <span class="comment"># 这样产生一个列表</span></span><br><span class="line"><span class="comment"># for表达式的顺序是与嵌套for循环的顺序一样</span></span><br><span class="line">flattened = []</span><br><span class="line"><span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> tup:</span><br><span class="line">        flattened.append(x)</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是Python中最主要也是最重要的<strong>代码组织和复用手段</strong> 。如果要<strong>重复使用相同或非常类似的代码</strong>，就需要写一个函数。通过给函数起一个名字，还可以提高代码的可读性。</p>
<p>函数使用<code>def</code>关键字声明，用<code>return</code>关键字返回值：可以同时拥有多条return语句。如果到达函数末尾时没有遇到任何一条return语句，则返回None。</p>
<p>位置参数（positional）和一些关键字参数（keyword）。关键字参数通常用于指定默认值或可选参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(x, y, z=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br><span class="line"><span class="comment"># z是关键字参数</span></span><br><span class="line">my_function(<span class="number">5</span>, <span class="number">6</span>, z=<span class="number">0.7</span>)</span><br><span class="line">my_function(<span class="number">3.14</span>, <span class="number">7</span>, <span class="number">3.5</span>)</span><br><span class="line">my_function(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="comment"># 关键字参数必须位于位置参数（如果有的话）之后，关键字参数顺序可以随便</span></span><br></pre></td></tr></table></figure>

<h4 id="命名空间、作用域和局部函数"><a href="#命名空间、作用域和局部函数" class="headerlink" title="命名空间、作用域和局部函数"></a>命名空间、作用域和局部函数</h4><p>函数可以访问两种不同作用域中的变量：全局（global）和局部（local）</p>
<p>Python中命名空间（namespace）用于描述变量作用域的名称。任何在函数中赋值的变量默认都被分配到局部命名空间（local namespace）中。局部命名空间是在函数被调用时创建的，函数参数会立即填入该命名空间。在函数执行完毕之后，局部命名空间就会被销毁。</p>
<h4 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> a, b, c</span><br><span class="line">    <span class="comment">#return &#123;'a' : a, 'b' : b, 'c' : c&#125; #也可以返回字典</span></span><br></pre></td></tr></table></figure>

<p>该函数其实只返回了一个对象，也就是一个元组，最后该元组会被拆包到各个结果变量中。</p>
<h4 id="函数也是对象"><a href="#函数也是对象" class="headerlink" title="函数也是对象"></a>函数也是对象</h4><p>数据清洗：</p>
<p>为了得到一组能用于分析工作的格式统一的字符串，需要做很多事情：去除空白符、删除各种标点符号、正确的大写格式等。做法之一是使用内建的字符串方法和正则表达式<code>re</code>模块：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        value = value.strip()</span><br><span class="line">        value = re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line">        value = value.title()</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">clean_strings(states)</span><br><span class="line"><span class="comment"># 方法二</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line">clean_strings(states, clean_ops)</span><br></pre></td></tr></table></figure>

<h4 id="匿名（lambda）函数"><a href="#匿名（lambda）函数" class="headerlink" title="匿名（lambda）函数"></a>匿名（lambda）函数</h4><p>Python支持一种被称为匿名函数（lambda函数，这种函数对象本身是没有提供名称<strong>name</strong>属性）。仅由单条语句组成，该语句的结果就是返回值。通过lambda关键字定义的，该关键字没有含义，仅仅表明“正在声明的是一个匿名函数”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line"></span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h4><p>柯里化（currying）是一个计算机科学术语，是指通过“部分参数应用”（partial argument application）从现有函数派生出新函数的技术。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 有一个执行两数相加的简单函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"><span class="comment"># 通过这个函数，可以派生出一个新的只有一个参数的函数</span></span><br><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br><span class="line"><span class="comment"># add_numbers的第二个参数称为“柯里化的”（curried）</span></span><br></pre></td></tr></table></figure>

<p>本质上是定义了一个可以调用现有函数的新函数而已。内置的functools模块可以用partial函数将此过程简化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>Python可以以一种一致的方式对序列进行迭代（比如列表中的对象或文件中的行）。这是通过一种叫做迭代器协议（iterator protocol，它是一种使对象可迭代的通用方式）的方式实现的，是一个原生的使对象可迭代的方法。</p>
<p>迭代器是一种特殊对象，它可以在诸如for循环之类的上下文中向Python解释器输送对象。大部分能接受列表之类的对象的方法也都可以接受任何可迭代对象。比如min、max、sum等内置方法以及list、tuple等类型构造器。</p>
<p>生成器（generator）是构造新的可迭代对象的一种简单方式。一般的函数执行之后只会返回单个值，而生成器则是以延迟的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。要创建一个生成器，只需将函数中的return替换为yeild即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squares</span><span class="params">(n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    print(<span class="string">'Generating squares from 1 to &#123;0&#125;'</span>.format(n ** <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br><span class="line">              </span><br><span class="line"><span class="comment"># 调用该生成器时，没有任何代码会被立即执行</span></span><br><span class="line">gen = squares()</span><br><span class="line"><span class="comment"># 直到从该生成器中请求元素时，它才会开始执行其代码</span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">    print(x,end=<span class="string">' '</span> )</span><br></pre></td></tr></table></figure>

<h5 id="生成器表达式（generator-expression）"><a href="#生成器表达式（generator-expression）" class="headerlink" title="生成器表达式（generator expression）"></a>生成器表达式（generator expression）</h5><p>另一种更简洁的构造生成器的方法。类似于列表、字典、集合推导式的生成器。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 其创建方式为，把列表推导式两端的方括号改成圆括号</span></span><br><span class="line">gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line"><span class="comment"># 等价于：</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_make_gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = _make_gen()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成器表达式也可以取代列表推导式，作为函数参数</span></span><br><span class="line">sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">100</span>))</span><br><span class="line">dict((i, i **<span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>))</span><br></pre></td></tr></table></figure>

<h5 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h5><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如，groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的<strong>连续元素进行分组</strong> 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">'Alan'</span>, <span class="string">'Adam'</span>, <span class="string">'Wes'</span>, <span class="string">'Will'</span>, <span class="string">'Albert'</span>, <span class="string">'Steven'</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    print(letter, list(names)) <span class="comment"># names is a generator</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-111823d8767a104d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp" alt="img"></p>
<h4 id="错误和异常处理"><a href="#错误和异常处理" class="headerlink" title="错误和异常处理"></a>错误和异常处理</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 只想处理ValueError，其他错误可能是合理的bug    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> TypeError:</span><br><span class="line">    <span class="comment"># another thing  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 可以用元组包含多个异常    </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##  不想抑制异常，无论try部分的代码是否成功，都执行一段代码   </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># something</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># another thing</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 例子</span></span><br><span class="line">f = open(path, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">'Failed'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'Succeeded'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>

<h4 id="IPython的异常"><a href="#IPython的异常" class="headerlink" title="IPython的异常"></a>IPython的异常</h4><p>在%run一个脚本或一条语句时抛出异常，IPython默认会打印完整的调用栈（traceback），在栈的每个点都会有几行上下文。</p>
<p>IPython中以用魔术命令<code>%xmode</code>，从Plain（与Python标准解释器相同）到Verbose（带有函数的参数值）控制文本显示的数量。发生错误之后，（用%debug或%pdb magics）可以进入stack进行事后调试。</p>
<h3 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'examples/segismundo.txt'</span></span><br><span class="line">f = open(path)</span><br></pre></td></tr></table></figure>

<p>默认情况下，文件是以只读模式（’r’）打开的。然后，可以像处理列表那样来处理文件句柄f，比如对行进行迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 还可以</span></span><br><span class="line">lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> open(path)]</span><br></pre></td></tr></table></figure>

<p>从文件中取出的行都带有完整的行结束符（EOL）。</p>
<p>使用open创建文件对象，一定要用close关闭。关闭文件可以返回操作系统资源。</p>
<p>用with语句可以在退出代码块时，自动关闭文件，更容易地清理打开的文件：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    lines = [x.rstrip() <span class="keyword">for</span> x <span class="keyword">in</span> f]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-28274484129f0ea7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="常用方法-read、seek、tell"><a href="#常用方法-read、seek、tell" class="headerlink" title="常用方法 read、seek、tell"></a>常用方法 read、seek、tell</h4><p>read会从文件返回字符。字符的内容是由文件的编码决定的（如UTF-8），如果是二进制模式打开的就是原始字节：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f = open(path)</span><br><span class="line">f.read(<span class="number">10</span>) <span class="comment"># 'Sueña el r'</span></span><br><span class="line"></span><br><span class="line">f2 = open(path, <span class="string">'rb'</span>)  <span class="comment"># Binary mode</span></span><br><span class="line">f2.read(<span class="number">10</span>) <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#read模式会将文件句柄的位置提前，提前的数量是读取的字节数。tell可以给出当前的位置：</span></span><br><span class="line">f.tell() <span class="comment"># 11</span></span><br><span class="line">f2.tell() <span class="comment"># 10</span></span><br><span class="line"><span class="comment"># seek将文件位置更改为文件中的指定字节</span></span><br><span class="line">f.seek(<span class="number">3</span>) <span class="comment"># 3</span></span><br><span class="line">f.read(<span class="number">1</span>) <span class="comment"># ñ</span></span><br></pre></td></tr></table></figure>

<p>向文件写入，可以使用文件的write或writelines方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'tmp.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> handle:</span><br><span class="line">    handle.writelines(x <span class="keyword">for</span> x <span class="keyword">in</span> open(path) <span class="keyword">if</span> len(x) &gt; <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 创建一个无空行版文件</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d25bd6e730afeb39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="文件的字节和Unicode"><a href="#文件的字节和Unicode" class="headerlink" title="文件的字节和Unicode"></a>文件的字节和Unicode</h4><p>Python文件的默认操作是“文本模式”，即处理Python的字符串（即Unicode）。二进制模式需要在文件模式后加一个b。</p>
<p>UTF-8是长度可变的Unicode编码，当从文件请求一定数量的字符时，Python会从文件读取足够多（可能少至10或多至40字节）的字节进行解码。如果以“rb”模式打开文件，则读取确切的请求字节数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(path) <span class="keyword">as</span> f:</span><br><span class="line">    chars = f.read(<span class="number">10</span>)  <span class="comment"># 'Sueña el r'</span></span><br><span class="line"><span class="keyword">with</span> open(path, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read(<span class="number">10</span>)   <span class="comment"># b'Sue\xc3\xb1a el '</span></span><br><span class="line"><span class="comment"># 可以将字节解码为str对象，但只有当每个编码的Unicode字符都完全成形时才能这么做：</span></span><br><span class="line">    data.decode(<span class="string">'utf8'</span>) <span class="comment"># 'Sueña el '</span></span><br><span class="line"><span class="comment"># 不要在二进制模式中使用seek。如果文件位置位于定义Unicode字符的字节的中间位置，读取后面会产生错误：</span></span><br></pre></td></tr></table></figure>

<h2 id="第4章-NumPy基础：数组和矢量计算"><a href="#第4章-NumPy基础：数组和矢量计算" class="headerlink" title="第4章 NumPy基础：数组和矢量计算"></a>第4章 NumPy基础：数组和矢量计算</h2><p>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。</p>
<p>NumPy可以高效处理大数组的数据。这是因为：</p>
<ul>
<li>NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。</li>
<li>NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。</li>
</ul>
<h3 id="多维数组对象ndarray"><a href="#多维数组对象ndarray" class="headerlink" title="多维数组对象ndarray"></a>多维数组对象ndarray</h3><p>ndarray是一个通用的同构数据多维容器，所有元素必须是相同类型的。</p>
<h4 id="创建ndarray"><a href="#创建ndarray" class="headerlink" title="创建ndarray"></a>创建ndarray</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用np.array函数创建。它接受一切序列型的对象（包括其他数组），然后产生一个新的含有传入数据的NumPy数组</span></span><br><span class="line">data1 = [<span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">arr1 = np.array(data1)</span><br><span class="line"><span class="comment"># 嵌套序列（比如由一组等长列表组成的列表）将会被转换为一个多维数组：</span></span><br><span class="line">data2 = [[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]]</span><br><span class="line">arr2 = np.array(data2)</span><br><span class="line"><span class="comment"># 属性：dtype，shape，ndim</span></span><br></pre></td></tr></table></figure>

<p>zeros, ones和empty可以创建指定长度或形状的全0，全1或者一个没有任何具体值的数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.zeros(<span class="number">10</span>)</span><br><span class="line">np.zeros((<span class="number">3</span>, <span class="number">6</span>))</span><br><span class="line">np.empty((<span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>arange是Python内置函数range的数组版</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.arange(<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-78ab11f67e7077a6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/696/format/webp" alt="img"></p>
<p>如果没有特别指定，数据类型基本都是float64（浮点数）。</p>
<h4 id="ndarray的数据类型"><a href="#ndarray的数据类型" class="headerlink" title="ndarray的数据类型"></a>ndarray的数据类型</h4><p>dtype（数据类型）是一个特殊的对象，它含有ndarray将一块内存解释为特定数据类型所需的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.float64)</span><br><span class="line">arr2 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=np.int32)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-2f2d7406a8bc076c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-5cc31115615737b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>可以通过ndarray的<code>astype</code>方法将一个数组从一个dtype转换成另一个dtype</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line">arr.dtype <span class="comment"># dtype('int64')</span></span><br><span class="line">float_arr = arr.astype(np.float64) <span class="comment"># 也可以写float，NumPy会将Python类型映射到等价的dtype上。也可用简洁类型代码表示dtype，f4</span></span><br><span class="line"><span class="comment"># 如果将浮点数转换成整数，则小数部分将会被截取删除</span></span><br><span class="line"><span class="comment"># 如果某字符串数组表示的全是数字，也可以用astype将其转换为数值形式</span></span><br><span class="line">numeric_strings = np.array([<span class="string">'1.25'</span>, <span class="string">'-9.6'</span>, <span class="string">'42'</span>], dtype=np.string_)</span><br><span class="line">numeric_strings.astype(float)</span><br></pre></td></tr></table></figure>

<h4 id="NumPy数组的运算"><a href="#NumPy数组的运算" class="headerlink" title="NumPy数组的运算"></a>NumPy数组的运算</h4><p>不编写循环，使用数组即可对数据执行批量运算。NumPy用户称其为<strong>矢量化（vectorization）</strong> </p>
<ul>
<li>大小相等的数组之间的任何算术运算都会将运算应用到元素级</li>
<li>数组与标量的算术运算会将标量值传播到各个元素</li>
<li>大小相同的数组之间的比较会生成布尔值数组</li>
<li>不同大小的数组之间的运算叫做<strong>广播（broadcasting）</strong> </li>
</ul>
<h4 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h4><h5 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h5><p>一维数组和列表最重要的区别在于：数组切片是原始数组的视图，即数据不会被复制，视图上的任何修改都会直接反映到源数组上。这是因为NumPy的设计目的是处理大数据，假如NumPy坚持要将数据复制会产生性能和内存问题。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 将一个标量值赋值给一个切片时，该值会自动传播（即“广播”）到整个选区</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>] = <span class="number">12</span>  <span class="comment"># array([ 0,  1,  2,  3,  4, 12, 12, 12,  8,  9])</span></span><br><span class="line"><span class="comment"># 切片[ : ]会给数组中的所有值赋值</span></span><br><span class="line"><span class="comment"># 数组切片是原始数组的视图</span></span><br><span class="line">arr_slice = arr[<span class="number">5</span>:<span class="number">8</span>]</span><br><span class="line">arr_slice[<span class="number">1</span>] = <span class="number">12345</span> <span class="comment"># arr也会发生变化</span></span><br><span class="line"><span class="comment"># 如果想要得到ndarray切片的副本而非视图</span></span><br><span class="line">arr[<span class="number">5</span>:<span class="number">8</span>].copy()</span><br></pre></td></tr></table></figure>

<h5 id="高维度数组"><a href="#高维度数组" class="headerlink" title="高维度数组"></a>高维度数组</h5><p><strong>二维数组</strong> 中，各索引位置上的元素不是标量而是一维数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line"><span class="comment"># 对各个元素进行递归访问</span></span><br><span class="line">arr2d[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 传入一个以逗号隔开的索引列表来选取单个元素</span></span><br><span class="line">arr2d[<span class="number">0</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0a641536f73f560e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/745/format/webp" alt="img"></p>
<p>在<strong>多维数组</strong> 中，如果省略了后面的索引，则返回对象会是一个维度低一点的ndarray（它含有高一级维度上的所有数据）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr3d = np.array([[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]], [[<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]]])</span><br><span class="line"><span class="comment"># 标量值和数组都可以被赋值给arr3d[0]：</span></span><br><span class="line">old_values = arr3d[<span class="number">0</span>].copy()</span><br><span class="line">arr3d[<span class="number">0</span>] = <span class="number">42</span></span><br><span class="line">arr3d[<span class="number">0</span>] = old_values</span><br></pre></td></tr></table></figure>

<h5 id="切片索引"><a href="#切片索引" class="headerlink" title="切片索引"></a>切片索引</h5><p>一维ndarray的切片语法跟Python列表差不多。</p>
<p>二维ndarray的切片方式稍显不同。切片是沿着一个轴向选取元素。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr2d = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], [<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]])</span><br><span class="line">arr2d[:<span class="number">2</span>]</span><br><span class="line"><span class="comment"># array([[1, 2, 3],   # 第一个轴切片，取了前两行</span></span><br><span class="line"><span class="comment">#       [4, 5, 6]])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">1</span>:]</span><br><span class="line"><span class="comment"># array([[2, 3],   # 第一个轴切片，再第二个轴切片</span></span><br><span class="line"><span class="comment">#       [5, 6]])</span></span><br></pre></td></tr></table></figure>

<p>这样切片只能得到相同维数的数组视图。通过将整数索引和切片混合，可以得到低维度的切片。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2d[<span class="number">1</span>, :<span class="number">2</span>]  <span class="comment"># array([4, 5])</span></span><br><span class="line">arr2d[:<span class="number">2</span>, <span class="number">2</span>]  <span class="comment"># array([3, 6])</span></span><br></pre></td></tr></table></figure>

<p><strong>“只有冒号”表示选取整个轴</strong> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arr2d[:, :<span class="number">1</span>]</span><br><span class="line"><span class="comment"># array([[1],</span></span><br><span class="line"><span class="comment">#       [4],</span></span><br><span class="line"><span class="comment">#       [7]])</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-9da32d2f4629c304.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/867/format/webp" alt="img"></p>
<p><strong>对切片表达式的赋值操作也会被扩散到整个选区</strong></p>
<h5 id="布尔型索引"><a href="#布尔型索引" class="headerlink" title="布尔型索引"></a>布尔型索引</h5><p>布尔型数组的长度必须跟被索引的轴长度一致</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">data = np.random.randn(<span class="number">7</span>, <span class="number">4</span>)</span><br><span class="line">data[names == <span class="string">'Bob'</span>]  <span class="comment"># 可以选出对名字"Bob"对应的所有行</span></span><br><span class="line"><span class="comment"># 布尔型数组可以和切片、整数（或整数序列）混合使用</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">2</span>:]  <span class="comment"># array([[ 0.769 ,  1.2464], [-0.5397,  0.477 ]])</span></span><br><span class="line">data[names == <span class="string">'Bob'</span>, <span class="number">3</span>]   <span class="comment"># array([ 1.2464,  0.477 ])</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以使用不等于符号（!=），或通过~对条件进行否定</span></span><br><span class="line">data[~(names == <span class="string">'Bob'</span>)]</span><br><span class="line">data[names != <span class="string">'Bob'</span>]</span><br><span class="line"><span class="comment"># 使用&amp;（和）、|（或）之类的布尔算术运算符</span></span><br><span class="line">data[mask = (names == <span class="string">'Bob'</span>) | (names == <span class="string">'Will'</span>)]</span><br><span class="line"><span class="comment"># 通过布尔型数组设置值。例如将data中的所有负值都设置为0</span></span><br><span class="line">data[data &lt; <span class="number">0</span>] = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>布尔型索引选取数组中的数据，总是创建数据的副本。</li>
<li>Python关键字and和or在布尔型数组中无效。要使用&amp;与|。</li>
<li>这类二维数据的操作也可以用pandas</li>
</ul>
<h5 id="花式索引"><a href="#花式索引" class="headerlink" title="花式索引"></a>花式索引</h5><p>花式索引（Fancy indexing）是一个NumPy术语，是指利用整数数组进行索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arr = np.empty((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">     arr[i] = i</span><br><span class="line"><span class="comment"># 可以传入一个用于指定顺序的整数列表或ndarray，特定顺序选取行子集</span></span><br><span class="line">arr[[<span class="number">4</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">6</span>]]</span><br><span class="line"><span class="comment"># 使用负数索引将会从末尾开始选取行</span></span><br><span class="line">arr[[<span class="number">-3</span>, <span class="number">-5</span>, <span class="number">-7</span>]]</span><br></pre></td></tr></table></figure>

<ul>
<li>无论数组是多少维的，花式索引总是一维的</li>
<li>花式索引总是将数据复制到新数组中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一次传入多个索引数组的返回是一个一维数组</span></span><br><span class="line">arr = np.arange(<span class="number">32</span>).reshape((<span class="number">8</span>, <span class="number">4</span>))</span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]] <span class="comment"># array([ 4, 23, 29, 10])</span></span><br><span class="line"><span class="comment"># 要想的到矩阵</span></span><br><span class="line">arr[[<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">2</span>]][:, [<span class="number">0</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<h4 id="数组转置和轴兑换"><a href="#数组转置和轴兑换" class="headerlink" title="数组转置和轴兑换"></a>数组转置和轴兑换</h4><ul>
<li>转置是重塑的一种特殊形式，返回源数据的视图（不会进行任何复制操作）。</li>
</ul>
<p>数组不仅有transpose方法，还有一个特殊的T属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">15</span>).reshape((<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line">arr.T</span><br><span class="line">arr.transpose()</span><br></pre></td></tr></table></figure>

<p>对于高维数组，transpose需要得到一个由轴编号组成的元组才能对这些轴进行转置.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">16</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">arr.transpose((<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>))</span><br><span class="line"><span class="comment"># 第一个轴被换成了第二个，第二个轴被换成了第一个，最后一个轴不变</span></span><br><span class="line">arr.swapaxes(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment"># swapaxes方法，它需要接受一对轴编号</span></span><br></pre></td></tr></table></figure>

<ul>
<li>swapaxes也是返回源数据的视图（不会进行任何复制操作）</li>
</ul>
<h3 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h3><p>通用函数（即ufunc）是一种对ndarray中的数据执行元素级运算的函数。可以看做简单函数（接受一个或多个标量值，并产生一个或多个标量值）的<strong>矢量化包装器</strong>。</p>
<ul>
<li><p>一元（unary）ufunc,如sqrt和exp,返回一个结果数组</p>
</li>
<li><p>二元（binary）ufunc，如add或maximum接受2个数组,并返回一个结果数组</p>
</li>
<li><p>有些ufunc可以返回多个数组，例如mod（Python内置函数divmod的矢量化版本），返回浮点数数组的小数和整数部分</p>
</li>
<li><p>Ufuncs可以接受一个out可选参数，这样就能在数组原地进行操作。</p>
</li>
<li><pre><code class="python">arr = array([<span class="number">-3.2623</span>, <span class="number">-6.0915</span>, <span class="number">-6.663</span> ,  <span class="number">5.3731</span>,  <span class="number">3.6182</span>,  <span class="number">3.45</span>  ,  <span class="number">5.0077</span>])
np.sqrt(arr)
<span class="comment"># array([    nan,     nan,     nan,  2.318 ,  1.9022,  1.8574,  2.2378])</span>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-1d494e73b61c7ced.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-2be79faf68ab6ff8.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-4e38d02a66481530.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-eff1e61e5464159f.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">![img](https:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;7178691-236dba83b6a420cc.png?imageMogr2&#x2F;auto-orient&#x2F;strip|imageView2&#x2F;2&#x2F;w&#x2F;1200&#x2F;format&#x2F;webp)</span><br><span class="line"></span><br><span class="line">### 利用数组进行数据处理</span><br><span class="line"></span><br><span class="line">用数组表达式代替循环的做法，通常被称为**矢量化**。一般来说，矢量化数组运算要比等价的纯Python方式快上一两个数量级（甚至更多）。</span><br><span class="line"></span><br><span class="line">#### 将条件逻辑表述为数组运算</span><br><span class="line"></span><br><span class="line">&#96;numpy.where&#96;函数是三元表达式&#96;x if condition else y&#96;的矢量化版本</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">xarr &#x3D; np.array([1.1, 1.2, 1.3, 1.4, 1.5])</span><br><span class="line">yarr &#x3D; np.array([2.1, 2.2, 2.3, 2.4, 2.5])</span><br><span class="line">cond &#x3D; np.array([True, False, True, True, False])</span><br><span class="line"># 根据cond中的值选取xarr和yarr的值：当cond中的值为True时，选取xarr的值，否则从yarr中选取。</span><br><span class="line"># 列表推导式的写法  缺点：1, 对大数组的处理速度不是很快。2,无法用于多维数组</span><br><span class="line">result &#x3D; [(x if c else y) for x, y, c in zip(xarr, yarr, cond)]</span><br><span class="line">#</span><br><span class="line">result &#x3D; np.where(cond, xarr, yarr)</span><br><span class="line"># 第二个和第三个参数也可以是标量值</span><br><span class="line">arr &#x3D; np.random.randn(4, 4)</span><br><span class="line">np.where(arr &gt; 0, 2, -2) # set positive values to 2, negative values to -2.</span><br><span class="line"># 可以将标量和数组结合起来</span><br><span class="line">np.where(arr &gt; 0, 2, arr) # set only positive values to 2</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="数学和统计方法"><a href="#数学和统计方法" class="headerlink" title="数学和统计方法"></a>数学和统计方法</h4><p>通过数组上的一组数学函数对整个数组或某个轴向的数据进行统计计算</p>
<p>sum、mean, 标准差std等聚合计算（aggregation，通常叫做约简（reduction））既可以当做数组的实例方法调用，也可以当做顶级NumPy函数使用。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.random.randn(<span class="number">5</span>, <span class="number">4</span>)</span><br><span class="line">arr.mean()</span><br><span class="line">np.mean(arr)</span><br><span class="line"><span class="comment"># mean和sum这类的函数可以接受一个axis选项参数，用于计算该轴向上的统计值，最终结果是一个低一维的数组</span></span><br><span class="line">arr.mean(axis=<span class="number">1</span>) <span class="comment"># 算行的平均值</span></span><br><span class="line">arr.sum(axis=<span class="number">0</span>) <span class="comment"># 计算每列的和</span></span><br></pre></td></tr></table></figure>

<p>其他如cumsum（累加）和cumprod（累乘）之类的方法则不聚合，而是产生一个由中间结果组成的数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>])</span><br><span class="line">arr.cumsum()  <span class="comment"># array([ 0,  1,  3,  6, 10, 15, 21, 28])</span></span><br><span class="line"><span class="comment"># 多维数组，返回同样大小的数组，每个低维的切片沿着标记轴计算部分聚类</span></span><br><span class="line">arr = np.array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]])</span><br><span class="line">arr.cumsum(axis=<span class="number">0</span>) <span class="comment"># 列上累加</span></span><br><span class="line">arr.cumprod(axis=<span class="number">1</span>) <span class="comment"># 行上累乘</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a6c6df3ca8e0b98e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-866fcde885b1d357.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="用于布尔型数组的方法"><a href="#用于布尔型数组的方法" class="headerlink" title="用于布尔型数组的方法"></a>用于布尔型数组的方法</h4><p>在上面这些方法中，布尔值会被强制转换为1（True）和0（False）</p>
<ul>
<li><p>sum经常被用来对布尔型数组中的True值计数：</p>
</li>
<li><pre><code class="python">arr = np.random.randn(<span class="number">100</span>)
(arr &gt; <span class="number">0</span>).sum()
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ any用于测试数组中是否存在一个或多个True</span><br><span class="line"></span><br><span class="line">+ all则检查数组中所有值是否都是True</span><br><span class="line"></span><br><span class="line">+ any,all 用于非布尔型数组时，所有非0元素将会被当做True</span><br><span class="line"></span><br><span class="line">#### 排序</span><br><span class="line"></span><br><span class="line">多维数组可以在任何一个轴向上进行排序，只需将轴编号传给sort即可</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">arr &#x3D; np.random.randn(5, 3)</span><br><span class="line">arr.sort(1)  # 安行排序，地排序则会修改数组本身</span><br><span class="line">np.sum(arr,1) # 返回的是数组的已排序副本</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ul>
<h4 id="唯一化以及其它的集合逻辑"><a href="#唯一化以及其它的集合逻辑" class="headerlink" title="唯一化以及其它的集合逻辑"></a>唯一化以及其它的集合逻辑</h4><p>NumPy提供了一些针对一维ndarray的基本集合运算。</p>
<ul>
<li>np.unique用于找出数组中的唯一值并返回已排序的结果：</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">names = np.array([<span class="string">'Bob'</span>, <span class="string">'Joe'</span>, <span class="string">'Will'</span>, <span class="string">'Bob'</span>, <span class="string">'Will'</span>, <span class="string">'Joe'</span>, <span class="string">'Joe'</span>])</span><br><span class="line">np.unique(names)  <span class="comment"># array(['Bob', 'Joe', 'Will'], dtype='&lt;U4')</span></span><br><span class="line"><span class="comment"># 纯python代码也可以</span></span><br><span class="line">sorted(set(names)) <span class="comment"># ['Bob', 'Joe', 'Will']</span></span><br></pre></td></tr></table></figure>

<ul>
<li>np.in1d用于测试一个数组中的值在另一个数组中的成员资格，返回一个布尔型数组</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">values = np.array([<span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">np.in1d(values, [<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>]) <span class="comment"># array([ True, False, False,  True,  True, False,  True], dtype=bool)</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-80e85ae6b9c89ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="用于数组的文件输入输出"><a href="#用于数组的文件输入输出" class="headerlink" title="用于数组的文件输入输出"></a>用于数组的文件输入输出</h3><p>NumPy的内置二进制格式，使用pandas或其它工具加载文本或表格数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保存，default：数组以未压缩的原始二进制格式保存在扩展名为.npy的文件中，如果文件路径末尾没有扩展名.npy，则该扩展名会被自动加上。</span></span><br><span class="line">arr = np.arange(<span class="number">10</span>)</span><br><span class="line">np.save(<span class="string">'some_array'</span>, arr)</span><br><span class="line"><span class="comment"># 读取</span></span><br><span class="line">np.load(<span class="string">'some_array.npy'</span>)</span><br><span class="line"><span class="comment"># 将多个数组保存到一个未压缩文件中，将数组以关键字参数的形式传入</span></span><br><span class="line">np.savez(<span class="string">'array_archive.npz'</span>, a=arr, b=arr)</span><br><span class="line"><span class="comment"># 加载.npz文件时，得到一个类似字典的对象</span></span><br><span class="line">arch = np.load(<span class="string">'array_archive.npz'</span>)</span><br><span class="line">arch[<span class="string">'b'</span>] <span class="comment"># array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span></span><br><span class="line"><span class="comment"># 数据压缩</span></span><br><span class="line">np.savez_compressed(<span class="string">'arrays_compressed.npz'</span>, a=arr, b=arr)</span><br></pre></td></tr></table></figure>

<h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><p>线性代数（如矩阵乘法、矩阵分解、行列式以及其他方阵数学等）是任何数组库的重要组成部分。</p>
<p>点积np.dot(a,y)或者x.dot(y)，@符用作中缀运算符，进行矩阵乘法</p>
<p><strong>numpy.linalg模块</strong> ：标准的矩阵分解运算包括求逆和行列式之类，使用行业标准线性代数库，如BLAS、LAPACK、Intel MKL（Math Kernel Library，可能有，取决于NumPy版本）等。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-dcdb66e49e5f70ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="伪随机数生成"><a href="#伪随机数生成" class="headerlink" title="伪随机数生成"></a>伪随机数生成</h3><p><strong>numpy.random模块</strong>:对Python内置的random进行了补充，增加了一些用于高效生成多种概率分布的样本值的函数</p>
<p>都是通过算法基于随机数生成器种子，在确定性的条件下生成的伪随机数。可以用NumPy的np.random.seed更改随机数生成种子</p>
<p>numpy.random的数据生成函数使用全局随机种子。使用numpy.random.RandomState 创建一个与其它隔离的随机数生成器,避免全局状态</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-97ba09c96dab93a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-6ed04fae3d1178e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="示例：随机漫步"><a href="#示例：随机漫步" class="headerlink" title="示例：随机漫步"></a>示例：随机漫步</h3><p>简单的随机漫步的例子：从0开始，步长1和－1出现的概率相等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">position = <span class="number">0</span></span><br><span class="line">walk = [position]</span><br><span class="line">steps = <span class="number">1000</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(steps):</span><br><span class="line">    step = <span class="number">1</span> <span class="keyword">if</span> random.randint(<span class="number">0</span>, <span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    position += step</span><br><span class="line">    walk.append(position)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用一个数组运算来实现</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=nsteps)</span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walk = steps.cumsum()</span><br><span class="line">walk.min()</span><br><span class="line">walk.max()</span><br></pre></td></tr></table></figure>

<p>统计首次穿越时间，即随机漫步过程中第一次到达某个特定值的时间。假设想要知道本次随机漫步需要多久才能距离初始0点至少10步远（任一方向均可）。</p>
<p>np.abs(walk)&gt;=10可以得到一个布尔型数组，它表示的是距离是否达到或超过10，而我们想要知道的是第一个10或－10的索引。</p>
<p>可以用argmax来解决这个问题，它返回的是该布尔型数组第一个最大值的索引（True就是最大值）：<code>(np.abs(walk) &gt;= 10).argmax()</code></p>
<ul>
<li>注意，这里使用argmax并不是很高效，因为它无论如何都会对数组进行完全扫描。在本例中，只要发现了一个True，那我们就知道它是个最大值了。</li>
</ul>
<h4 id="一次模拟多个随机漫步"><a href="#一次模拟多个随机漫步" class="headerlink" title="一次模拟多个随机漫步"></a>一次模拟多个随机漫步</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 模拟5000个随机漫步过程</span></span><br><span class="line">nwalks = <span class="number">5000</span></span><br><span class="line">nsteps = <span class="number">1000</span></span><br><span class="line">draws = np.random.randint(<span class="number">0</span>, <span class="number">2</span>, size=(nwalks, nsteps)) <span class="comment"># 0 or 1</span></span><br><span class="line">steps = np.where(draws &gt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">-1</span>)</span><br><span class="line">walks = steps.cumsum(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算30或－30的最小穿越时间</span></span><br><span class="line">hits30 = (np.abs(walks) &gt;= <span class="number">30</span>).any(<span class="number">1</span>)  <span class="comment"># 按照行来查询，一行中只要有一个true，则为true</span></span><br><span class="line">hits30.sum()  <span class="comment"># 5000个随机过程中，有多少个达到30，sum布尔值时，True为1</span></span><br><span class="line">crossing_times = (np.abs(walks[hits30]) &gt;= <span class="number">30</span>).argmax(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="第5章-pandas入门"><a href="#第5章-pandas入门" class="headerlink" title="第5章 pandas入门"></a>第5章 pandas入门</h2><p>pandas是专门为处理表格和混杂数据设计的，而NumPy更适合处理统一的数值数组数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> pandas <span class="keyword">import</span> Series, DataFrame</span><br></pre></td></tr></table></figure>

<h3 id="pandas的数据结构介绍"><a href="#pandas的数据结构介绍" class="headerlink" title="pandas的数据结构介绍"></a>pandas的数据结构介绍</h3><h4 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h4><p>一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成</p>
<p>可以将Series看成是一个定长的有序字典，因为它是索引值到数据值的一个映射。它可以用在许多原本需要字典参数的函数中</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment"># 可以通过Series 的values和index属性获取其数组表示形式和索引对象</span></span><br><span class="line">obj.values <span class="comment"># array([ 4,  7, -5,  3])</span></span><br><span class="line">obj.index  <span class="comment"># like range(4)  RangeIndex(start=0, stop=4, step=1)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">obj2 = pd.Series([<span class="number">4</span>, <span class="number">7</span>, <span class="number">-5</span>, <span class="number">3</span>], index=[<span class="string">'d'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 直接通过这个字典来创建Series</span></span><br><span class="line">sdata = &#123;<span class="string">'Ohio'</span>: <span class="number">35000</span>, <span class="string">'Texas'</span>: <span class="number">71000</span>, <span class="string">'Oregon'</span>: <span class="number">16000</span>, <span class="string">'Utah'</span>: <span class="number">5000</span>&#125;</span><br><span class="line">obj3 = pd.Series(sdata)</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">states = [<span class="string">'California'</span>, <span class="string">'Ohio'</span>, <span class="string">'Oregon'</span>, <span class="string">'Texas'</span>]</span><br><span class="line">obj4 = pd.Series(sdata, index=states)</span><br><span class="line"><span class="comment"># sdata中跟states索引相匹配的那3个值会被找出来并放到相应的位置上，但由于"California"所对应的sdata值找不到，所以其结果就为NaN（即“非数字”（not a number），在pandas中，它用于表示缺失或NA值）。因为‘Utah’不在states中，它被从结果中除去。</span></span><br><span class="line">pd.isnull(obj4)  <span class="comment"># pandas的isnull和notnull函数可用于检测缺失数据</span></span><br><span class="line">pd.notnull(obj4)</span><br><span class="line">obj4.isnull()   <span class="comment"># Series也有类似的实例方法</span></span><br></pre></td></tr></table></figure>

<p>Series最重要的一个功能是，它会根据运算的索引标签自动对齐数据，类似数据库的join的操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">37</span>]: obj3 + obj4</span><br><span class="line">Out[<span class="number">37</span>]: </span><br><span class="line">California         NaN</span><br><span class="line">Ohio           <span class="number">70000.0</span></span><br><span class="line">Oregon         <span class="number">32000.0</span></span><br><span class="line">Texas         <span class="number">142000.0</span></span><br><span class="line">Utah               NaN</span><br><span class="line"><span class="comment"># Series对象本身及其索引都有一个name属性</span></span><br><span class="line">obj4.name = <span class="string">'population'</span></span><br><span class="line">obj4.index.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>

<h4 id="DataFrame"><a href="#DataFrame" class="headerlink" title="DataFrame"></a>DataFrame</h4><p>一个<strong>表格型的数据结构</strong>，含有一组有序的列，每列可以是不同的值类型（数值、字符串、布尔值等）。DataFrame既有行索引也有列索引，可以看做由Series组成的字典（共用同一个索引）。DataFrame中的数据是以一个或多个二维块存放的（而不是列表、字典或别的一维数据结构）。</p>
<p>pandas中许多高级数据处理功能的关键要素，<strong>层次化索引的表格型结构</strong>  </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建</span></span><br><span class="line">data = &#123;<span class="string">'state'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],</span><br><span class="line">        <span class="string">'year'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2003</span>],</span><br><span class="line">        <span class="string">'pop'</span>: [<span class="number">1.5</span>, <span class="number">1.7</span>, <span class="number">3.6</span>, <span class="number">2.4</span>, <span class="number">2.9</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line">frame = pd.DataFrame(data)</span><br><span class="line"><span class="comment"># 按照指定顺序进行排列</span></span><br><span class="line">pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>]) </span><br><span class="line"><span class="comment"># 传入的列在数据中找不到，就会在结果中产生缺失值</span></span><br><span class="line">frame2 = pd.DataFrame(data, columns=[<span class="string">'year'</span>, <span class="string">'state'</span>, <span class="string">'pop'</span>, <span class="string">'debt'</span>],index=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>,<span class="string">'five'</span>, <span class="string">'six'</span>])</span><br><span class="line"><span class="comment"># 通过类似字典标记的方式或属性的方式，可以将DataFrame的列获取为一个Series</span></span><br><span class="line">frame2[<span class="string">'state'</span>]</span><br><span class="line">frame2.year</span><br><span class="line"><span class="comment"># 行也可以通过位置或名称的方式进行获取，比如用loc属性</span></span><br><span class="line">frame2.loc[<span class="string">'three'</span>]</span><br><span class="line"><span class="comment"># 列可以通过赋值的方式进行修改</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = <span class="number">16.5</span></span><br><span class="line">frame2[<span class="string">'debt'</span>] = np.arange(<span class="number">6.</span>)</span><br><span class="line">val = pd.Series([<span class="number">-1.2</span>, <span class="number">-1.5</span>, <span class="number">-1.7</span>], index=[<span class="string">'two'</span>, <span class="string">'four'</span>, <span class="string">'five'</span>])</span><br><span class="line">frame2[<span class="string">'debt'</span>] = val</span><br><span class="line"><span class="comment"># 根据state是否为'Ohio'，添加一个新的布尔值的列</span></span><br><span class="line">frame2[<span class="string">'eastern'</span>] = frame2.state == <span class="string">'Ohio'</span></span><br><span class="line"><span class="comment"># 关键字del用于删除列</span></span><br><span class="line"><span class="keyword">del</span> frame2[<span class="string">'eastern'</span>] </span><br><span class="line"><span class="comment"># 方法</span></span><br><span class="line">frame.head() <span class="comment"># 前五行</span></span><br></pre></td></tr></table></figure>

<ul>
<li>frame2[column]适用于任何列的名，但是frame2.column只有在列名是一个合理的Python变量名时才适用。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 嵌套字典</span></span><br><span class="line">pop = &#123;<span class="string">'Nevada'</span>: &#123;<span class="number">2001</span>: <span class="number">2.4</span>, <span class="number">2002</span>: <span class="number">2.9</span>&#125;,<span class="string">'Ohio'</span>: &#123;<span class="number">2000</span>: <span class="number">1.5</span>, <span class="number">2001</span>: <span class="number">1.7</span>, <span class="number">2002</span>: <span class="number">3.6</span>&#125;&#125;</span><br><span class="line">frame3 = pd.DataFrame(pop)</span><br><span class="line"><span class="comment"># 对DataFrame进行转置（交换行和列）</span></span><br><span class="line">frame3.T</span><br><span class="line"><span class="comment"># 由Series组成的字典</span></span><br><span class="line">pdata = &#123;<span class="string">'Ohio'</span>: frame3[<span class="string">'Ohio'</span>][:<span class="number">-1</span>],<span class="string">'Nevada'</span>: frame3[<span class="string">'Nevada'</span>][:<span class="number">2</span>]&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-106835b28c0cea5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1075/format/webp" alt="img"></p>
<p>如果设置了DataFrame的index和columns的name属性，则这些信息也会被显示出来:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame3.index.name = <span class="string">'year'</span>; frame3.columns.name = <span class="string">'state'</span></span><br></pre></td></tr></table></figure>

<h4 id="索引对象"><a href="#索引对象" class="headerlink" title="索引对象"></a>索引对象</h4><h4 id="重新索引"><a href="#重新索引" class="headerlink" title="重新索引"></a>重新索引</h4><p>在对Series或DataFrame重新索引时，也可以指定一个填充值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.reindex(columns=df2.columns, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="丢弃指定轴上的项"><a href="#丢弃指定轴上的项" class="headerlink" title="丢弃指定轴上的项"></a>丢弃指定轴上的项</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认删除行（index）</span></span><br><span class="line">data.drop([<span class="string">'Colorado'</span>, <span class="string">'Ohio'</span>])</span><br><span class="line"><span class="comment"># 通过传递axis=1或axis='columns'可以删除列的值</span></span><br><span class="line">data.drop(<span class="string">'two'</span>, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 就地修改对象，不会返回新的对象</span></span><br><span class="line">obj.drop(<span class="string">'c'</span>, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="索引、选取和过滤"><a href="#索引、选取和过滤" class="headerlink" title="索引、选取和过滤"></a>索引、选取和过滤</h4><p>Series：利用标签的切片运算与普通的Python切片运算不同，其末端是包含的。</p>
<p>DataFrame：默认列标签的索引</p>
<h4 id="用loc和iloc进行选取"><a href="#用loc和iloc进行选取" class="headerlink" title="用loc和iloc进行选取"></a>用loc和iloc进行选取</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先行后列</span></span><br><span class="line">data.loc[<span class="string">'Colorado'</span>, [<span class="string">'two'</span>, <span class="string">'three'</span>]] <span class="comment">#行是必须的</span></span><br><span class="line">data.iloc[<span class="number">2</span>, [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="comment"># 切片</span></span><br><span class="line">data.loc[:<span class="string">'Utah'</span>, <span class="string">'two'</span>]</span><br><span class="line">data.iloc[:, :<span class="number">3</span>][data.three &gt; <span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-64354f2ab777bd8c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/929/format/webp" alt="img"></p>
<h4 id="整数索引"><a href="#整数索引" class="headerlink" title="整数索引"></a>整数索引</h4><p>loc和iloc</p>
<h4 id="算术运算和数据对齐"><a href="#算术运算和数据对齐" class="headerlink" title="算术运算和数据对齐"></a>算术运算和数据对齐</h4><p>pandas最重要的一个功能是，它可以对不同索引的对象进行算术运算。在将对象相加时，如果存在不同的索引对，则结果的索引就是该索引对的并集。</p>
<p>自动的数据对齐操作在不重叠的索引处引入了NA值。缺失值会在算术运算过程中传播</p>
<h4 id="在算术方法中填充值"><a href="#在算术方法中填充值" class="headerlink" title="在算术方法中填充值"></a>在算术方法中填充值</h4><p>两个DataFrame相加时，没有重叠的位置就会产生NA值，可以使用add方法填充一个特殊值（比如0）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df1.add(df2, fill_value=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-16857a1021f98d1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/388/format/webp" alt="img"></p>
<ul>
<li>以字母r开头，它会翻转参数。</li>
</ul>
<h4 id="DataFrame和Series之间的运算"><a href="#DataFrame和Series之间的运算" class="headerlink" title="DataFrame和Series之间的运算"></a>DataFrame和Series之间的运算</h4><p>广播（broadcasting）</p>
<p>默认情况下，DataFrame和Series之间的算术运算会将Series的索引匹配到DataFrame的列，然后沿着行一直向下广播。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12.</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">series = frame.iloc[<span class="number">0</span>]</span><br><span class="line">frame - series</span><br><span class="line"><span class="string">""" output</span></span><br><span class="line"><span class="string">          b    d    e</span></span><br><span class="line"><span class="string">Utah    0.0  0.0  0.0</span></span><br><span class="line"><span class="string">Ohio    3.0  3.0  3.0</span></span><br><span class="line"><span class="string">Texas   6.0  6.0  6.0</span></span><br><span class="line"><span class="string">Oregon  9.0  9.0  9.0</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>如果某个索引值在DataFrame的列或Series的索引中找不到，则参与运算的两个对象就会被重新索引以形成并集。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">series2 = pd.Series(range(<span class="number">3</span>), index=[<span class="string">'b'</span>, <span class="string">'e'</span>, <span class="string">'f'</span>])</span><br><span class="line">frame + series2</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">          b   d     e   f</span></span><br><span class="line"><span class="string">Utah    0.0 NaN   3.0 NaN</span></span><br><span class="line"><span class="string">Ohio    3.0 NaN   6.0 NaN</span></span><br><span class="line"><span class="string">Texas   6.0 NaN   9.0 NaN</span></span><br><span class="line"><span class="string">Oregon  9.0 NaN  12.0 NaN</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>可以使用算术运算方法匹配行且在列上广播。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame.sub(series3, axis=<span class="string">'index'</span>) <span class="comment"># 或者 axis=0</span></span><br></pre></td></tr></table></figure>

<h4 id="函数应用和映射"><a href="#函数应用和映射" class="headerlink" title="函数应用和映射"></a>函数应用和映射</h4><p>DataFrame的apply方法可以将函数应用到由各列或行所形成的一维数组上。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(np.random.randn(<span class="number">4</span>, <span class="number">3</span>), columns=list(<span class="string">'bde'</span>),index=[<span class="string">'Utah'</span>, <span class="string">'Ohio'</span>, <span class="string">'Texas'</span>, <span class="string">'Oregon'</span>])</span><br><span class="line">f = <span class="keyword">lambda</span> x: x.max() - x.min()</span><br><span class="line">frame.apply(f) <span class="comment"># 每列</span></span><br><span class="line">frame.apply(f, axis=<span class="string">'columns'</span>) <span class="comment"># 每行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> pd.Series([x.min(), x.max()], index=[<span class="string">'min'</span>, <span class="string">'max'</span>])</span><br><span class="line">frame.apply(f)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">            b         d         e</span></span><br><span class="line"><span class="string">min -0.555730  0.281746 -1.296221</span></span><br><span class="line"><span class="string">max  1.246435  1.965781  1.393406</span></span><br><span class="line"><span class="string">"</span></span><br></pre></td></tr></table></figure>

<p>DataFrame的applymap方法可以使用元素级的Python函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">format = <span class="keyword">lambda</span> x: <span class="string">'%.2f'</span> % x</span><br><span class="line">frame.applymap(format)</span><br></pre></td></tr></table></figure>

<p>Series有一个用于应用元素级函数的map方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frame[<span class="string">'e'</span>].map(format)</span><br></pre></td></tr></table></figure>

<h4 id="排序和排名"><a href="#排序和排名" class="headerlink" title="排序和排名"></a>排序和排名</h4><p>DataFrame和Series中的sort_index方法对行或列索引进行排序（按字典顺序，默认升序），返回一个已排序的新对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">4</span>), index=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">obj.sort_index()</span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">4</span>)),index=[<span class="string">'three'</span>, <span class="string">'one'</span>], columns=[<span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line">frame.sort_index()  <span class="comment"># index</span></span><br><span class="line">frame.sort_index(axis=<span class="number">1</span>, ascending=<span class="literal">False</span>) <span class="comment"># columns</span></span><br></pre></td></tr></table></figure>

<p>若要按值对Series进行排序，可使用其sort_values方法,任何缺失值默认都会被放到Series的末尾。</p>
<p>DataFrame排序时，可以根据一个或多个列中的值进行排序。将一个或多个列的名字传递给sort_values的by选项即可达到该目的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]&#125;)</span><br><span class="line">frame.sort_values(by=<span class="string">'b'</span>)</span><br><span class="line">frame.sort_values(by=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br></pre></td></tr></table></figure>

<p><strong>Series和DataFrame的rank方法</strong></p>
<p>默认情况下，rank是通过“为各组分配一个平均排名”的方式破坏平级关系的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="number">7</span>, <span class="number">-5</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">4</span>])</span><br><span class="line">obj.rank() <span class="comment"># 排名并列会平均</span></span><br><span class="line">obj.rank(method=<span class="string">'first'</span>) <span class="comment"># 排名并列会选择小的数值</span></span><br><span class="line">obj.rank(ascending=<span class="literal">False</span>, method=<span class="string">'max'</span>) <span class="comment"># 排名并列选择大的数值</span></span><br><span class="line"></span><br><span class="line">frame = pd.DataFrame(&#123;<span class="string">'b'</span>: [<span class="number">4.3</span>, <span class="number">7</span>, <span class="number">-3</span>, <span class="number">2</span>], <span class="string">'a'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], <span class="string">'c'</span>: [<span class="number">-2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">-2.5</span>]&#125;) </span><br><span class="line">frame.rank(axis=<span class="string">'columns'</span>) <span class="comment"># 即axis=1， 默认axis=0</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7edfab5b4a147581.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/653/format/webp" alt="img"></p>
<h4 id="带有重复标签的轴索引"><a href="#带有重复标签的轴索引" class="headerlink" title="带有重复标签的轴索引"></a>带有重复标签的轴索引</h4><p>pandas函数（如reindex）都要求标签唯一，但这不是强制性的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series(range(<span class="number">5</span>), index=[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># 检查标签是否唯一</span></span><br><span class="line">obj.index.is_unique</span><br><span class="line"><span class="comment"># 如果某个索引对应多个值，则返回一个Series</span></span><br><span class="line"><span class="comment"># 对DataFrame的行进行索引时，返回DataFrame</span></span><br></pre></td></tr></table></figure>

<h3 id="汇总和计算描述统计"><a href="#汇总和计算描述统计" class="headerlink" title="汇总和计算描述统计"></a>汇总和计算描述统计</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-af35e3809278410e.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p>有些方法（如idxmin和idxmax）返回的是间接统计（比如达到最小值或最大值的索引），另一些方法则是累计型的。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-11fa967f658ac314.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="相关系数与协方差"><a href="#相关系数与协方差" class="headerlink" title="相关系数与协方差"></a>相关系数与协方差</h4><h4 id="唯一值、值计数以及成员资格"><a href="#唯一值、值计数以及成员资格" class="headerlink" title="唯一值、值计数以及成员资格"></a>唯一值、值计数以及成员资格</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">obj = pd.Series([<span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'d'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>])</span><br><span class="line">uniques = obj.unique()</span><br><span class="line">obj.value_counts()</span><br><span class="line"><span class="comment"># isin用于判断矢量化集合的成员资格</span></span><br><span class="line">mask = obj.isin([<span class="string">'b'</span>, <span class="string">'c'</span>])</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-b53c4a9d65a2db32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/848/format/webp" alt="img"></p>
<h2 id="第6章-数据加载、存储与文件格式"><a href="#第6章-数据加载、存储与文件格式" class="headerlink" title="第6章 数据加载、存储与文件格式"></a>第6章 数据加载、存储与文件格式</h2><h3 id="读写文本格式的数据"><a href="#读写文本格式的数据" class="headerlink" title="读写文本格式的数据"></a>读写文本格式的数据</h3><p><img src="https://upload-images.jianshu.io/upload_images/7178691-958f849e6067b19b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/778/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">df = pd.read_csv(<span class="string">'examples/ex1.csv'</span>)</span><br><span class="line">pd.read_table(<span class="string">'examples/ex1.csv'</span>, sep=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># 如果文件没有标题行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, header=<span class="literal">None</span>)</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>])</span><br><span class="line"><span class="comment"># 将某列设置为索引</span></span><br><span class="line">names = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'message'</span>]</span><br><span class="line">pd.read_csv(<span class="string">'examples/ex2.csv'</span>, names=names, index_col=<span class="string">'message'</span>)</span><br><span class="line"><span class="comment"># 层次化索引</span></span><br><span class="line">parsed = pd.read_csv(<span class="string">'examples/csv_mindex.csv'</span>, index_col=[<span class="string">'key1'</span>, <span class="string">'key2'</span>])</span><br><span class="line"><span class="comment"># 正则表达式作为分隔</span></span><br><span class="line">result = pd.read_table(<span class="string">'examples/ex3.txt'</span>, sep=<span class="string">'\s+'</span>)</span><br><span class="line"><span class="comment"># 用skiprows跳过文件的指定行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex4.csv'</span>, skiprows=[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<p>缺失值处理是文件解析任务中的一个重要组成部分。缺失数据经常是要么没有（空字符串），要么用某个标记值表示。默认情况下，pandas会用一组经常出现的标记值进行识别，比如NA及NULL：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># na_values可以用一个列表或集合的字符串表示缺失值</span></span><br><span class="line">result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>, na_values=[<span class="string">'NULL'</span>])</span><br><span class="line"></span><br><span class="line">In [<span class="number">25</span>]: !cat examples/ex5.csv</span><br><span class="line">something,a,b,c,d,message</span><br><span class="line">one,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,NA</span><br><span class="line">two,<span class="number">5</span>,<span class="number">6</span>,,<span class="number">8</span>,world</span><br><span class="line">three,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,foo</span><br><span class="line">In [<span class="number">26</span>]: result = pd.read_csv(<span class="string">'examples/ex5.csv'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-082daf4a00ed9494.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-f2bcc0a703c7236f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-597327ade3e94c7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="逐块读取文本文件"><a href="#逐块读取文本文件" class="headerlink" title="逐块读取文本文件"></a>逐块读取文本文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置pandas显示地更紧些</span></span><br><span class="line">pd.options.display.max_rows = <span class="number">10</span></span><br><span class="line"><span class="comment"># 只读取几行</span></span><br><span class="line">pd.read_csv(<span class="string">'examples/ex6.csv'</span>, nrows=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 要逐块读取文件</span></span><br><span class="line">chunker = pd.read_csv(<span class="string">'ch06/ex6.csv'</span>, chunksize=<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<p>返回可迭代的TextParser对象</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tot = pd.Series([])</span><br><span class="line"><span class="keyword">for</span> piece <span class="keyword">in</span> chunker:</span><br><span class="line">    tot = tot.add(piece[<span class="string">'key'</span>].value_counts(), fill_value=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">tot = tot.sort_values(ascending=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<h4 id="将数据写出到文本格式"><a href="#将数据写出到文本格式" class="headerlink" title="将数据写出到文本格式"></a>将数据写出到文本格式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">data.to_csv(<span class="string">'examples/out.csv'</span>)</span><br><span class="line">data.to_csv(sys.stdout, sep=<span class="string">'|'</span>) <span class="comment"># 写出到sys.stdout，仅仅打印出文本结果</span></span><br><span class="line"><span class="comment"># 默认缺失值在输出结果中会被表示为空字符串</span></span><br><span class="line">data.to_csv(sys.stdout, na_rep=<span class="string">'NULL'</span>)</span><br><span class="line"><span class="comment"># 默认写出行和列的标签</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, header=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 只写出一部分</span></span><br><span class="line">data.to_csv(sys.stdout, index=<span class="literal">False</span>, columns=[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>])</span><br><span class="line"><span class="comment"># Series也有一个to_csv方法</span></span><br><span class="line">dates = pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">7</span>)</span><br><span class="line">ts = pd.Series(np.arange(<span class="number">7</span>), index=dates)</span><br><span class="line">ts.to_csv(<span class="string">'examples/tseries.csv'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="处理分隔符格式"><a href="#处理分隔符格式" class="headerlink" title="处理分隔符格式"></a>处理分隔符格式</h4><p>手动处理：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">54</span>]: !cat examples/ex7.csv</span><br><span class="line"><span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"><span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接使用Python内置的csv模块</span></span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line">f = open(<span class="string">'examples/ex7.csv'</span>)</span><br><span class="line">reader = csv.reader(f)</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> reader:</span><br><span class="line">    print(line)</span><br><span class="line"><span class="comment"># 读取文件到一个多行的列表中</span></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'examples/ex7.csv'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    lines = list(csv.reader(f))</span><br><span class="line"><span class="comment"># 将这些行分为标题行和数据行    </span></span><br><span class="line">header, values = lines[<span class="number">0</span>], lines[<span class="number">1</span>:]</span><br><span class="line"><span class="comment"># 用字典构造式和zip(*values)，后者将行转置为列，创建数据列的字典</span></span><br><span class="line">data_dict = &#123;h: v <span class="keyword">for</span> h, v <span class="keyword">in</span> zip(header, zip(*values))&#125;</span><br></pre></td></tr></table></figure>

<p>CSV文件的形式有很多。只需定义csv.Dialect的一个子类即可定义出新格式（如专门的分隔符、字符串引用约定、行结束符等）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_dialect</span><span class="params">(csv.Dialect)</span>:</span></span><br><span class="line">    lineterminator = <span class="string">'\n'</span></span><br><span class="line">    delimiter = <span class="string">';'</span></span><br><span class="line">    quotechar = <span class="string">'"'</span></span><br><span class="line">    quoting = csv.QUOTE_MINIMAL</span><br><span class="line">reader = csv.reader(f, dialect=my_dialect)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-7a1cee622459072b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1187/format/webp" alt="img"></p>
<h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>通过json.loads即可将JSON字符串转换成Python形式</p>
<p>json.dumps则将Python对象转换成JSON格式</p>
<p>JSON对象转换为DataFrame：向DataFrame构造器传入一个字典的列表（就是原先的JSON对象），并选取数据字段的子集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = json.loads(obj)</span><br><span class="line">siblings = pd.DataFrame(result[<span class="string">'siblings'</span>], columns=[<span class="string">'name'</span>, <span class="string">'age'</span>])</span><br></pre></td></tr></table></figure>

<p>pandas.read_json可以自动将特别格式的JSON数据集转换为Series或DataFrame</p>
<p>将数据从pandas输出到JSON，可以使用to_json方法</p>
<h4 id="XML和HTML：Web信息收集"><a href="#XML和HTML：Web信息收集" class="headerlink" title="XML和HTML：Web信息收集"></a>XML和HTML：Web信息收集</h4><p>pandas有一个内置的功能，read_html，它可以使用lxml和Beautiful Soup自动将HTML文件中的表格解析为DataFrame对象。</p>
<h3 id="二进制数据格式"><a href="#二进制数据格式" class="headerlink" title="二进制数据格式"></a>二进制数据格式</h3><p>实现数据的高效二进制格式存储最简单的办法之一是使用Python内置的pickle序列化</p>
<p>read_pickle和to_pickle</p>
<ul>
<li>pickle仅建议用于短期存储格式。其原因是很难保证该格式永远是稳定的</li>
</ul>
<p>pandas内置支持两个二进制数据格式：HDF5和MessagePack。</p>
<p>pandas或NumPy数据的其它存储格式有：</p>
<ul>
<li>bcolz：一种可压缩的列存储二进制格式，基于Blosc压缩库。</li>
<li>Feather：一种跨语言的列存储文件格式。Feather使用了Apache Arrow的列式内存格式。</li>
</ul>
<h4 id="HDF5格式"><a href="#HDF5格式" class="headerlink" title="HDF5格式"></a>HDF5格式</h4><p>HDF5是一种存储大规模科学数组数据的非常好的文件格式。</p>
<p>HDF5可以高效地分块读写</p>
<p>可以用PyTables或h5py库直接访问HDF5文件，pandas提供了更为高级的接口</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: np.random.randn(<span class="number">100</span>)&#125;)</span><br><span class="line">store[<span class="string">'obj1'</span>] = frame</span><br><span class="line">store[<span class="string">'obj1_col'</span>] = frame[<span class="string">'a'</span>]</span><br><span class="line">store = pd.HDFStore(<span class="string">'mydata.h5'</span>)</span><br><span class="line"><span class="comment"># HDFStore支持两种存储模式，'fixed'和'table'。后者通常会更慢，但是支持使用特殊语法进行查询操作：</span></span><br><span class="line">store.put(<span class="string">'obj2'</span>, frame, format=<span class="string">'table'</span>)</span><br><span class="line">store.select(<span class="string">'obj2'</span>, where=[<span class="string">'index &gt;= 10 and index &lt;= 15'</span>])</span><br><span class="line"></span><br><span class="line">frame.to_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, format=<span class="string">'table'</span>)</span><br><span class="line">pd.read_hdf(<span class="string">'mydata.h5'</span>, <span class="string">'obj3'</span>, where=[<span class="string">'index &lt; 5'</span>])</span><br></pre></td></tr></table></figure>

<h4 id="读取Microsoft-Excel文件"><a href="#读取Microsoft-Excel文件" class="headerlink" title="读取Microsoft Excel文件"></a>读取Microsoft Excel文件</h4><p>pandas的ExcelFile类或pandas.read_excel函数支持读取存储在Excel 2003（或更高版本）中的表格型数据。这两个工具分别使用扩展包xlrd和openpyxl读取XLS和XLSX文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取</span></span><br><span class="line">xlsx = pd.ExcelFile(<span class="string">'examples/ex1.xlsx'</span>)</span><br><span class="line">pd.read_excel(xlsx, <span class="string">'Sheet1'</span>)</span><br><span class="line">frame = pd.read_excel(<span class="string">'examples/ex1.xlsx'</span>, <span class="string">'Sheet1'</span>)</span><br><span class="line"><span class="comment"># 写入</span></span><br><span class="line">writer = pd.ExcelWriter(<span class="string">'examples/ex2.xlsx'</span>)</span><br><span class="line">frame.to_excel(writer, <span class="string">'Sheet1'</span>)</span><br><span class="line">writer.save()</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">frame.to_excel(<span class="string">'examples/ex2.xlsx'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Web-APIs交互"><a href="#Web-APIs交互" class="headerlink" title="Web APIs交互"></a>Web APIs交互</h3><h3 id="数据库交互"><a href="#数据库交互" class="headerlink" title="数据库交互"></a>数据库交互</h3><p>将数据从SQL加载到DataFrame的过程很简单，此外pandas还有一些能够简化该过程的函数。例如，我将使用SQLite数据库（通过Python内置的sqlite3驱动器）</p>
<p>。<a href="http://www.sqlalchemy.org/" target="_blank" rel="noopener">SQLAlchemy项目</a>是一个流行的Python SQL工具，它抽象出了SQL数据库中的许多常见差异。pandas有一个read_sql函数，可以让你轻松的从SQLAlchemy连接读取数据。</p>
<h2 id="第7章-数据清洗和准备"><a href="#第7章-数据清洗和准备" class="headerlink" title="第7章 数据清洗和准备"></a>第7章 数据清洗和准备</h2><h3 id="处理缺失数据"><a href="#处理缺失数据" class="headerlink" title="处理缺失数据"></a>处理缺失数据</h3><p>对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据，称其为哨兵值，可以方便的检测出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string_data = pd.Series([<span class="string">'aardvark'</span>, <span class="string">'artichoke'</span>, np.nan, <span class="string">'avocado'</span>])</span><br><span class="line">string_data.isnull()</span><br><span class="line">string_data[<span class="number">0</span>] = <span class="literal">None</span></span><br><span class="line">string_data.isnull()</span><br></pre></td></tr></table></figure>

<p>pandas采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-1a0f73e5bb26ea21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="滤除缺失数据"><a href="#滤除缺失数据" class="headerlink" title="滤除缺失数据"></a>滤除缺失数据</h4><p>通过pandas.isnull或布尔索引的手工方法，或者dropna。对于一个Series，dropna返回一个仅含非空数据和索引值的Series</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> nan <span class="keyword">as</span> NA</span><br><span class="line">data = pd.Series([<span class="number">1</span>, NA, <span class="number">3.5</span>, NA, <span class="number">7</span>]) </span><br><span class="line">data.dropna()</span><br><span class="line"><span class="comment"># 等价于</span></span><br><span class="line">data[data.notnull()]</span><br></pre></td></tr></table></figure>

<p>对于DataFrame对象，dropna默认丢弃任何含有缺失值的行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame([[<span class="number">1.</span>, <span class="number">6.5</span>, <span class="number">3.</span>], [<span class="number">1.</span>, NA, NA], [NA, NA, NA], [NA, <span class="number">6.5</span>, <span class="number">3.</span>]])</span><br><span class="line">cleaned = data.dropna()</span><br><span class="line"><span class="comment"># 丢弃全为NA的那些行</span></span><br><span class="line">data.dropna(how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 丢弃列</span></span><br><span class="line">data.dropna(axis=<span class="number">1</span>, how=<span class="string">'all'</span>)</span><br><span class="line"><span class="comment"># 滤除DataFrame行的问题涉及时间序列数据，至滤除符合条件的前两行</span></span><br><span class="line">df.dropna(thresh=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="填充缺失数据"><a href="#填充缺失数据" class="headerlink" title="填充缺失数据"></a>填充缺失数据</h4><p>fillna函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">df.fillna(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 实现对不同的列填充不同的值</span></span><br><span class="line">df.fillna(&#123;<span class="number">1</span>: <span class="number">0.5</span>, <span class="number">2</span>: <span class="number">0</span>&#125;)</span><br><span class="line"><span class="comment"># 对现有对象进行就地修改</span></span><br><span class="line"> _ = df.fillna(<span class="number">0</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#对reindexing有效的那些插值方法也可用于fillna    </span></span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>)</span><br><span class="line">df.fillna(method=<span class="string">'ffill'</span>, limit=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 传入平均值</span></span><br><span class="line">data.fillna(data.mean())</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-0bf235386a64c3b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4edd39e68f4dc530.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h3 id="数据转换"><a href="#数据转换" class="headerlink" title="数据转换"></a>数据转换</h3><h4 id="移除重复数据"><a href="#移除重复数据" class="headerlink" title="移除重复数据"></a>移除重复数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'k1'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>] * <span class="number">3</span> + [<span class="string">'two'</span>],<span class="string">'k2'</span>: [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"><span class="comment"># duplicated方法返回一个布尔型Series，表示各行是否和前面出现过的行重复</span></span><br><span class="line">data.duplicated()</span><br><span class="line"><span class="comment"># drop_duplicates方法，返回一个DataFrame，重复的数组会标为False</span></span><br><span class="line">data.drop_duplicates()</span><br><span class="line"><span class="comment"># 指定部分列进行重复项判断</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>])</span><br><span class="line"><span class="comment"># duplicated和drop_duplicates默认保留的是第一个出现的值组合。传入keep='last'则保留最后一个</span></span><br><span class="line">data.drop_duplicates([<span class="string">'k1'</span>, <span class="string">'k2'</span>], keep=<span class="string">'last'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="利用函数或映射进行数据转换"><a href="#利用函数或映射进行数据转换" class="headerlink" title="利用函数或映射进行数据转换"></a>利用函数或映射进行数据转换</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(&#123;<span class="string">'food'</span>: [<span class="string">'bacon'</span>, <span class="string">'pulled pork'</span>, <span class="string">'bacon'</span>,</span><br><span class="line"><span class="string">'Pastrami'</span>, <span class="string">'corned beef'</span>, <span class="string">'Bacon'</span>,<span class="string">'pastrami'</span>, <span class="string">'honey ham'</span>, <span class="string">'nova lox'</span>],<span class="string">'ounces'</span>: [<span class="number">4</span>, <span class="number">3</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">7.5</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>]&#125;)</span><br><span class="line"><span class="comment"># 添加一列表示该肉类食物来源的动物类型</span></span><br><span class="line"><span class="comment"># 编写一个不同肉类到动物的映射</span></span><br><span class="line">meat_to_animal = &#123;</span><br><span class="line">  <span class="string">'bacon'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pulled pork'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'pastrami'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'corned beef'</span>: <span class="string">'cow'</span>,</span><br><span class="line">  <span class="string">'honey ham'</span>: <span class="string">'pig'</span>,</span><br><span class="line">  <span class="string">'nova lox'</span>: <span class="string">'salmon'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 先将字母转换为小写</span></span><br><span class="line">lowercased = data[<span class="string">'food'</span>].str.lower()</span><br><span class="line">data[<span class="string">'animal'</span>] = lowercased.map(meat_to_animal)</span><br><span class="line"><span class="comment"># 传入一个能够完成全部这些工作的函数：</span></span><br><span class="line">data[<span class="string">'food'</span>].map(<span class="keyword">lambda</span> x: meat_to_animal[x.lower()])</span><br></pre></td></tr></table></figure>

<h4 id="替换值"><a href="#替换值" class="headerlink" title="替换值"></a>替换值</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series([<span class="number">1.</span>, <span class="number">-999.</span>, <span class="number">2.</span>, <span class="number">-999.</span>, <span class="number">-1000.</span>, <span class="number">3.</span>])</span><br><span class="line">data.replace(<span class="number">-999</span>, np.nan)</span><br><span class="line"><span class="comment"># 传入多个值</span></span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], np.nan)</span><br><span class="line">data.replace([<span class="number">-999</span>, <span class="number">-1000</span>], [np.nan, <span class="number">0</span>])</span><br><span class="line"><span class="comment"># 也可以传入字典</span></span><br><span class="line">data.replace(&#123;<span class="number">-999</span>: np.nan, <span class="number">-1000</span>: <span class="number">0</span>&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>data.replace方法与data.str.replace不同，后者做的是字符串的元素级替换</li>
</ul>
<h4 id="重命名轴索引"><a href="#重命名轴索引" class="headerlink" title="重命名轴索引"></a>重命名轴索引</h4><p>轴标签可以通过函数或映射进行转换，从而得到一个新的不同标签的对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>)), index=[<span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>, <span class="string">'New York'</span>], columns=[<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>, <span class="string">'four'</span>])</span><br><span class="line">transform = <span class="keyword">lambda</span> x: x[:<span class="number">4</span>].upper()</span><br><span class="line">data.index.map(transform)</span><br><span class="line"><span class="comment"># 对DataFrame就地修改</span></span><br><span class="line">data.index = data.index.map(transform)</span><br><span class="line"><span class="comment"># 用rename方法创建数据集的转换版（而不是修改原始数据）</span></span><br><span class="line">data.rename(index=str.title, columns=str.upper)</span><br><span class="line"><span class="comment"># rename可以结合字典型对象实现对部分轴标签的更新</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;,columns=&#123;<span class="string">'three'</span>: <span class="string">'peekaboo'</span>&#125;)</span><br><span class="line"><span class="comment"># 就地修改</span></span><br><span class="line">data.rename(index=&#123;<span class="string">'OHIO'</span>: <span class="string">'INDIANA'</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="离散化和面元划分"><a href="#离散化和面元划分" class="headerlink" title="离散化和面元划分"></a>离散化和面元划分</h4><p>为了便于分析，连续数据常常被离散化或拆分为“面元”（bin）。</p>
<p>cut函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 年龄分组</span></span><br><span class="line">ages = [<span class="number">20</span>, <span class="number">22</span>, <span class="number">25</span>, <span class="number">27</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">37</span>, <span class="number">31</span>, <span class="number">61</span>, <span class="number">45</span>, <span class="number">41</span>, <span class="number">32</span>]</span><br><span class="line">bins = [<span class="number">18</span>, <span class="number">25</span>, <span class="number">35</span>, <span class="number">60</span>, <span class="number">100</span>]</span><br><span class="line">cats = pd.cut(ages, bins)</span><br><span class="line"><span class="comment"># 返回的是一个特殊的Categorical对象</span></span><br><span class="line">cats.codes <span class="comment"># array([0, 0, 0, 1, 0, 0, 2, 1, 3, 2, 2, 1], dtype=int8)</span></span><br><span class="line">cats.categories </span><br><span class="line"><span class="string">""" IntervalIndex([(18, 25], (25, 35], (35, 60], (60, 100]]</span></span><br><span class="line"><span class="string">              closed='right',</span></span><br><span class="line"><span class="string">              dtype='interval[int64]')"""</span></span><br><span class="line"><span class="comment"># pd.value_counts(cats)是pandas.cut结果的面元计数</span></span><br><span class="line">pd.value_counts(cats)</span><br><span class="line"></span><br><span class="line">pd.cut(ages, [<span class="number">18</span>, <span class="number">26</span>, <span class="number">36</span>, <span class="number">61</span>, <span class="number">100</span>], right=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 可以通过传递一个列表或数组到labels，设置面元名称</span></span><br><span class="line">group_names = [<span class="string">'Youth'</span>, <span class="string">'YoungAdult'</span>, <span class="string">'MiddleAged'</span>, <span class="string">'Senior'</span>]</span><br><span class="line">pd.cut(ages, bins, labels=group_names)</span><br><span class="line"><span class="comment"># 向cut传入的是面元的数量</span></span><br><span class="line">data = np.random.rand(<span class="number">20</span>)</span><br><span class="line">pd.cut(data, <span class="number">4</span>, precision=<span class="number">2</span>) <span class="comment"># 选项precision=2，限定小数只有两位</span></span><br></pre></td></tr></table></figure>

<p>qcut非常类似cut，它可以根据样本分位数对数据进行面元划分。根据数据的分布情况，cut可能无法使各个面元中含有相同数量的数据点。而qcut由于使用的是样本分位数，因此可以得到大小基本相等的面元：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = np.random.randn(<span class="number">1000</span>)</span><br><span class="line">cats = pd.qcut(data, <span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以传递自定义的分位数（0到1之间的数值，包含端点）</span></span><br><span class="line">pd.qcut(data, [<span class="number">0</span>, <span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">0.9</span>, <span class="number">1.</span>])</span><br></pre></td></tr></table></figure>

<h4 id="检测和过滤异常值"><a href="#检测和过滤异常值" class="headerlink" title="检测和过滤异常值"></a>检测和过滤异常值</h4><p>过滤或变换异常值（outlier）在很大程度上就是运用数组运算。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data = pd.DataFrame(np.random.randn(<span class="number">1000</span>, <span class="number">4</span>))</span><br><span class="line">data.describe()</span><br><span class="line"><span class="comment"># 找出某列中绝对值大小超过3的值</span></span><br><span class="line">col = data[<span class="number">2</span>] <span class="comment"># 第二列</span></span><br><span class="line">col[np.abs(col) &gt; <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 选出全部含有“超过3或－3的值”的行</span></span><br><span class="line">data[(np.abs(data) &gt; <span class="number">3</span>).any(<span class="number">1</span>)]</span><br><span class="line">data[np.abs(data) &gt; <span class="number">3</span>] = np.sign(data) * <span class="number">3</span></span><br><span class="line"><span class="comment"># 根据数据的值是正还是负，np.sign(data)可以生成1和-1：</span></span><br><span class="line">np.sign(data).head()</span><br></pre></td></tr></table></figure>

<h4 id="排列和随机采样"><a href="#排列和随机采样" class="headerlink" title="排列和随机采样"></a>排列和随机采样</h4><p>利用numpy.random.permutation函数可以实现对Series或DataFrame的列的排列工作（permuting，随机重排序）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">5</span> * <span class="number">4</span>).reshape((<span class="number">5</span>, <span class="number">4</span>)))</span><br><span class="line">sampler = np.random.permutation(<span class="number">5</span>)</span><br><span class="line">df.take(sampler)</span><br><span class="line"><span class="comment"># 可以在Series和DataFrame上使用sample方法</span></span><br><span class="line">df.sample(n=<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 要通过替换的方式产生样本（允许重复选择），可以传递replace=True到sample</span></span><br><span class="line">choices = pd.Series([<span class="number">5</span>, <span class="number">7</span>, <span class="number">-1</span>, <span class="number">6</span>, <span class="number">4</span>])</span><br><span class="line">draws = choices.sample(n=<span class="number">10</span>, replace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="计算指标-哑变量"><a href="#计算指标-哑变量" class="headerlink" title="计算指标/哑变量"></a>计算指标/哑变量</h4><p>另一种常用于统计建模或机器学习的转换方式是：将分类变量（categorical variable）转换为“哑变量”或“指标矩阵”。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line"><span class="comment"># 给指标DataFrame的列加上一个前缀，以便能够跟其他数据进行合并</span></span><br><span class="line">dummies = pd.get_dummies(df[<span class="string">'key'</span>], prefix=<span class="string">'key'</span>)</span><br><span class="line">df_with_dummy = df[[<span class="string">'data1'</span>]].join(dummies)</span><br><span class="line"><span class="comment"># 如果DataFrame中的某行同属于多个分类，则事情就会有点复杂</span></span><br></pre></td></tr></table></figure>

<p>另一个例子</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.random.seed(<span class="number">12345</span>)</span><br><span class="line">values = np.random.rand(<span class="number">10</span>)</span><br><span class="line">bins = [<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0.4</span>, <span class="number">0.6</span>, <span class="number">0.8</span>, <span class="number">1</span>]</span><br><span class="line">pd.get_dummies(pd.cut(values, bins))</span><br></pre></td></tr></table></figure>

<h3 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val = <span class="string">'a,b,  guido'</span></span><br><span class="line">pieces = [x.strip() <span class="keyword">for</span> x <span class="keyword">in</span> val.split(<span class="string">','</span>)]</span><br><span class="line"><span class="string">'::'</span>.join(pieces) <span class="comment"># 等价于 first + '::' + second + '::' + third</span></span><br><span class="line"><span class="comment"># 子串定位</span></span><br><span class="line"><span class="string">'guido'</span> <span class="keyword">in</span> val</span><br><span class="line">val.index(<span class="string">','</span>) <span class="comment"># 找不到字符串，index将会引发一个异常</span></span><br><span class="line">val.find(<span class="string">':'</span>)  <span class="comment"># 找不到返回-1</span></span><br><span class="line">val.count(<span class="string">','</span>)</span><br><span class="line">val.replace(<span class="string">','</span>, <span class="string">'::'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-087fe67bf6db0701.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d1f0d4ed3e895016.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h4><p>re模块的函数可以分为三个大类：模式匹配、替换以及拆分。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line">text = <span class="string">"foo    bar\t baz  \tqux"</span></span><br><span class="line">re.split(<span class="string">'\s+'</span>, text)</span><br><span class="line"><span class="comment"># 调用re.split('\s+',text)时，正则表达式会先被编译，然后再在text上调用其split方法。</span></span><br><span class="line"><span class="comment"># 如果打算对许多字符串应用同一条正则表达式，强烈建议通过re.compile创建regex对象。这样将可以节省大量的CPU时间。</span></span><br><span class="line">regex = re.compile(<span class="string">'\s+'</span>)</span><br><span class="line">regex.split(text)</span><br><span class="line">regex.findall(text)</span><br><span class="line"><span class="comment"># findall返回字符串中所有的匹配项，search返回第一个匹配项。match只匹配字符串的首部</span></span><br><span class="line">text = <span class="string">"""Dave dave@google.com</span></span><br><span class="line"><span class="string">Steve steve@gmail.com</span></span><br><span class="line"><span class="string">Rob rob@gmail.com</span></span><br><span class="line"><span class="string">Ryan ryan@yahoo.com</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">pattern = <span class="string">r'[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]&#123;2,4&#125;'</span></span><br><span class="line"><span class="comment"># re.IGNORECASE makes the regex case-insensitive</span></span><br><span class="line">regex = re.compile(pattern, flags=re.IGNORECASE)</span><br><span class="line"></span><br><span class="line">regex.findall(text)</span><br><span class="line">m = regex.search(text)</span><br><span class="line"><span class="comment"># &lt;_sre.SRE_Match object; span=(5, 20), match='dave@google.com'&gt;</span></span><br><span class="line">text[m.start():m.end()]</span><br><span class="line">regex.match(text) <span class="comment"># 结果为None,只匹配出现在字符串开头的模式</span></span><br><span class="line">regex.sub(<span class="string">'REDACTED'</span>, text)</span><br><span class="line"><span class="comment"># 分段的模式</span></span><br><span class="line">pattern = <span class="string">r'([A-Z0-9._%+-]+)@([A-Z0-9.-]+)\.([A-Z]&#123;2,4&#125;)'</span></span><br><span class="line">m = regex.match(<span class="string">'wesm@bright.net'</span>)</span><br><span class="line">m.groups()</span><br><span class="line"><span class="comment"># ('wesm', 'bright', 'net')</span></span><br><span class="line">regex.findall(text) <span class="comment"># 对于带有分组功能的模式，findall返回一个元组列表</span></span><br><span class="line"><span class="comment"># sub能通过诸如\1、\2之类的特殊符号访问各匹配项中的分组</span></span><br><span class="line">regex.sub(<span class="string">r'Username: \1, Domain: \2, Suffix: \3'</span>, text)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-efbb80a793759fc0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="pandas的矢量化字符串函数"><a href="#pandas的矢量化字符串函数" class="headerlink" title="pandas的矢量化字符串函数"></a>pandas的矢量化字符串函数</h4><p>通过data.map，所有字符串和正则表达式方法都能被应用于（传入lambda表达式或其他函数）各个值，但是如果存在NA（null）就会报错。</p>
<p>含有字符串的列有时还含有缺失数据,为了解决这个问题，Series有一些能够跳过NA值的面向数组方法，进行字符串操作。通过Series的str属性即可访问这些方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data.str.contains(<span class="string">'gmail'</span>)</span><br><span class="line">data.str.findall(pattern, flags=re.IGNORECASE)</span><br><span class="line">matches = data.str.match(pattern, flags=re.IGNORECASE)</span><br><span class="line">data.str[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-a634364ed6d5d5c5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/870/format/webp" alt="img"></p>
<h2 id="第8章-数据规整：聚合、合并和重塑"><a href="#第8章-数据规整：聚合、合并和重塑" class="headerlink" title="第8章 数据规整：聚合、合并和重塑"></a>第8章 数据规整：聚合、合并和重塑</h2><h3 id="层次化索引"><a href="#层次化索引" class="headerlink" title="层次化索引"></a>层次化索引</h3><p>层次化索引（hierarchical indexing）是pandas的一项重要功能，在一个轴上拥有多个（两个以上）索引级别，以低维度形式处理高维度数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">data = pd.Series(np.random.randn(<span class="number">9</span>),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'d'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="comment"># 外层操作</span></span><br><span class="line">data[<span class="string">'b'</span>]</span><br><span class="line"><span class="comment"># 内层操作</span></span><br><span class="line">data.loc[:, <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 通过unstack方法将这段数据重新安排到一个DataFrame中</span></span><br><span class="line">data.unstack()</span><br><span class="line">data.unstack().stack()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">对于一个DataFrame，每条轴都可以有分层索引：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">frame = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>, <span class="number">3</span>)),index=[[<span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'b'</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]],columns=[[<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Colorado'</span>],[<span class="string">'Green'</span>, <span class="string">'Red'</span>, <span class="string">'Green'</span>]])</span><br><span class="line"><span class="comment"># 各层都可以有名字</span></span><br><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># </span></span><br><span class="line">frame[<span class="string">'Ohio'</span>]</span><br><span class="line">frame.loc[<span class="string">'a'</span>]</span><br></pre></td></tr></table></figure>

<h4 id="重排与分级排序"><a href="#重排与分级排序" class="headerlink" title="重排与分级排序"></a>重排与分级排序</h4><p>swaplevel接受两个级别编号或名称，并返回一个互换了级别的新对象（但数据不会发生变化）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frame.index.names = [<span class="string">'key1'</span>, <span class="string">'key2'</span>]</span><br><span class="line">frame.columns.names = [<span class="string">'state'</span>, <span class="string">'color'</span>]</span><br><span class="line"><span class="comment"># sort_index则根据单个级别中的值对数据进行排序</span></span><br><span class="line">frame.sort_index(level=<span class="number">1</span>)</span><br><span class="line">frame.swaplevel(<span class="number">0</span>, <span class="number">1</span>).sort_index(level=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h4 id="根据级别汇总统计"><a href="#根据级别汇总统计" class="headerlink" title="根据级别汇总统计"></a>根据级别汇总统计</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据行或列上的级别来进行求和</span></span><br><span class="line">frame.sum(level=<span class="string">'key2'</span>)</span><br><span class="line">frame.sum(level=<span class="string">'color'</span>, axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h4 id="使用DataFrame的列进行索引"><a href="#使用DataFrame的列进行索引" class="headerlink" title="使用DataFrame的列进行索引"></a>使用DataFrame的列进行索引</h4><p>DataFrame的set_index函数会将其一个或多个列转换为行索引，并创建一个新的DataFrame</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">frame = pd.DataFrame(&#123;<span class="string">'a'</span>: range(<span class="number">7</span>), <span class="string">'b'</span>: range(<span class="number">7</span>, <span class="number">0</span>, <span class="number">-1</span>),<span class="string">'c'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>, <span class="string">'two'</span>], <span class="string">'d'</span>: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">frame2 = frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>])</span><br><span class="line"><span class="comment"># 默认情况下，那些列会从DataFrame中移除，但也可以将其保留下来</span></span><br><span class="line">frame.set_index([<span class="string">'c'</span>, <span class="string">'d'</span>], drop=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># reset_index的功能跟set_index刚好相反，层次化索引的级别会被转移到列里面</span></span><br><span class="line">frame2.reset_index()</span><br></pre></td></tr></table></figure>
<h3 id="合并数据集"><a href="#合并数据集" class="headerlink" title="合并数据集"></a>合并数据集</h3><p>pandas对象中的数据可以通过一些方式进行合并：</p>
<ul>
<li>pandas.merge可根据一个或多个键将不同DataFrame中的行连接起来。</li>
<li>pandas.concat可以沿着一条轴将多个对象堆叠到一起。</li>
<li>实例方法combine_first可以将重复数据拼接在一起，用一个对象中的值填充另一个对象中的缺失值。</li>
</ul>
<h4 id="数据库风格的DataFrame合并"><a href="#数据库风格的DataFrame合并" class="headerlink" title="数据库风格的DataFrame合并"></a>数据库风格的DataFrame合并</h4><p>数据集的合并（merge）或连接（join）运算是通过一个或多个键将行连接起来的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>],<span class="string">'data1'</span>: range(<span class="number">7</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">3</span>)&#125;)</span><br><span class="line"><span class="comment"># 多对一的合并</span></span><br><span class="line"><span class="comment"># 默认情况下，merge会将重叠列的列名当做键</span></span><br><span class="line">pd.merge(df1, df2)</span><br><span class="line"><span class="comment"># 列名可以指定</span></span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment">#如果两个对象的列名不同，也可以分别进行指定</span></span><br><span class="line">pd.merge(df3, df4, left_on=<span class="string">'lkey'</span>, right_on=<span class="string">'rkey'</span>)</span><br><span class="line"><span class="comment"># 默认情况下，merge做的是“内连接”；结果中的键是交集</span></span><br><span class="line"><span class="comment"># 他方式还有"left"、"right"以及"outer"。外连接求取的是键的并集，组合了左连接和右连接的效果</span></span><br><span class="line">pd.merge(df1, df2, how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e49b3341f4a3c90e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/739/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多对多的合并</span></span><br><span class="line">df1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'b'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>], <span class="string">'data1'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">df2 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>],<span class="string">'data2'</span>: range(<span class="number">5</span>)&#125;)</span><br><span class="line">pd.merge(df1, df2, on=<span class="string">'key'</span>, how=<span class="string">'left'</span>)</span><br><span class="line"><span class="comment"># 多对多连接产生的是行的笛卡尔积</span></span><br><span class="line"><span class="comment"># 由于左边的DataFrame有3个"b"行，右边的有2个，所以最终结果中就有6个"b"行。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据多个键进行合并，传入一个由列名组成的列表</span></span><br><span class="line">left = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>], <span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'one'</span>], <span class="string">'lval'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">right = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'foo'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'bar'</span>],<span class="string">'key2'</span>: [<span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'one'</span>, <span class="string">'two'</span>],<span class="string">'rval'</span>: [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;)</span><br><span class="line">pd.merge(left, right, on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p>合并运算对重复列名的处理：merge有一个更实用的suffixes选项，用于指定附加到左右两个DataFrame对象的重叠列名上的字符串</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>)</span><br><span class="line">pd.merge(left, right, on=<span class="string">'key1'</span>, suffixes=(<span class="string">'_left'</span>, <span class="string">'_right'</span>))</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-35ca716a4f1b8475.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c86672e733ceccd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1180/format/webp" alt="img"></p>
<h4 id="索引上的合并"><a href="#索引上的合并" class="headerlink" title="索引上的合并"></a>索引上的合并</h4><p>有时候，DataFrame中的连接键位于其索引中。在这种情况下，你可以传入left_index=True或right_index=True（或两个都传）以说明索引应该被用作连接键</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">left1 = pd.DataFrame(&#123;<span class="string">'key'</span>: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>, <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>],<span class="string">'value'</span>: range(<span class="number">6</span>)&#125;)</span><br><span class="line">right1 = pd.DataFrame(&#123;<span class="string">'group_val'</span>: [<span class="number">3.5</span>, <span class="number">7</span>]&#125;, index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">pd.merge(left1, right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>对于层次化索引的数据，索引的合并默认是多键合并</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lefth = pd.DataFrame(&#123;<span class="string">'key1'</span>: [<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>, <span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>],<span class="string">'key2'</span>: [<span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>, <span class="number">2001</span>, <span class="number">2002</span>], <span class="string">'data'</span>: np.arange(<span class="number">5.</span>)&#125;)</span><br><span class="line">righth = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">6</span>, <span class="number">2</span>)),index=[[<span class="string">'Nevada'</span>, <span class="string">'Nevada'</span>, <span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>,<span class="string">'Ohio'</span>, <span class="string">'Ohio'</span>],[<span class="number">2001</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2000</span>, <span class="number">2001</span>, <span class="number">2002</span>]],  columns=[<span class="string">'event1'</span>, <span class="string">'event2'</span>])</span><br><span class="line"><span class="comment"># 以列表的形式指明用作合并键的多个列</span></span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>)</span><br><span class="line">pd.merge(lefth, righth, left_on=[<span class="string">'key1'</span>, <span class="string">'key2'</span>], right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<p>DataFrame还有一个便捷的join实例方法，它能更为方便地实现按索引合并。它还可用于合并多个带有相同或相似索引的DataFrame对象，但要求没有重叠的列。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时使用合并双方的索引</span></span><br><span class="line">pd.merge(left2, right2, how=<span class="string">'outer'</span>, left_index=<span class="literal">True</span>, right_index=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># join默认使用的是左连接，保留左边表的行索引</span></span><br><span class="line">left2.join(right2, how=<span class="string">'outer'</span>)</span><br><span class="line"><span class="comment"># 支持在调用的DataFrame的列上，连接传递的DataFrame索引</span></span><br><span class="line">left1.join(right1, on=<span class="string">'key'</span>)</span><br><span class="line"><span class="comment"># 相当于</span></span><br><span class="line">pd.merge(left1,right1, left_on=<span class="string">'key'</span>, right_index=<span class="literal">True</span>,how=<span class="string">'outer'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="轴向连接"><a href="#轴向连接" class="headerlink" title="轴向连接"></a>轴向连接</h4><p>连接（concatenation）、绑定（binding）或堆叠（stacking）。NumPy的concatenation函数可以用NumPy数组来做</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr = np.arange(<span class="number">12</span>).reshape((<span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">np.concatenate([arr, arr], axis=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>对于pandas对象（如Series和DataFrame），还需要考虑以下这些情况：</p>
<ul>
<li>如果对象在其它轴上的索引不同，应该合并这些轴的不同元素还是只使用交集？</li>
<li>连接的数据集是否需要在结果对象中可识别？</li>
<li>连接轴中保存的数据是否需要保留？许多情况下，DataFrame默认的整数标签最好在连接时删掉。</li>
</ul>
<p>pandas的concat函数提供了一种能够解决这些问题的可靠方式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">s1 = pd.Series([<span class="number">0</span>, <span class="number">1</span>], index=[<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line">s2 = pd.Series([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], index=[<span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>])</span><br><span class="line">s3 = pd.Series([<span class="number">5</span>, <span class="number">6</span>], index=[<span class="string">'f'</span>, <span class="string">'g'</span>])</span><br><span class="line">pd.concat([s1, s2, s3])</span><br><span class="line"><span class="comment"># 默认情况下，concat是在axis=0上工作的，最终产生一个新的Series。如果传入axis=1，则结果就会变成一个DataFrame（axis=1是列）</span></span><br><span class="line">s4 = pd.concat([s1, s3])</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join=<span class="string">'inner'</span>)</span><br><span class="line">pd.concat([s1, s4], axis=<span class="number">1</span>, join_axes=[[<span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'e'</span>]])</span><br><span class="line"><span class="comment"># 在连接轴上创建一个层次化索引</span></span><br><span class="line">result = pd.concat([s1, s1, s3], keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line">pd.concat([s1, s2, s3], axis=<span class="number">1</span>, keys=[<span class="string">'one'</span>,<span class="string">'two'</span>, <span class="string">'three'</span>])</span><br><span class="line"><span class="comment"># 如果传入的不是列表而是一个字典，则字典的键就会被当做keys选项的值</span></span><br><span class="line">pd.concat(&#123;<span class="string">'level1'</span>: df1, <span class="string">'level2'</span>: df2&#125;, axis=<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 可以用names参数命名创建的轴级别</span></span><br><span class="line">pd.concat([df1, df2], axis=<span class="number">1</span>, keys=[<span class="string">'level1'</span>, <span class="string">'level2'</span>],names=[<span class="string">'upper'</span>, <span class="string">'lower'</span>])</span><br><span class="line"><span class="comment"># DataFrame的行索引不包含任何相关数据，直接合并index</span></span><br><span class="line">pd.concat([df1, df2], ignore_index=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-339436563b519415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1167/format/webp" alt="img"></p>
<h4 id="合并重叠数据"><a href="#合并重叠数据" class="headerlink" title="合并重叠数据"></a>合并重叠数据</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = pd.Series([np.nan, <span class="number">2.5</span>, np.nan, <span class="number">3.5</span>, <span class="number">4.5</span>, np.nan], index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br><span class="line">b = pd.Series(np.arange(len(a), dtype=np.float64), index=[<span class="string">'f'</span>, <span class="string">'e'</span>, <span class="string">'d'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>])</span><br></pre></td></tr></table></figure>

<h2 id="第11章-时间序列"><a href="#第11章-时间序列" class="headerlink" title="第11章 时间序列"></a>第11章 时间序列</h2><p>时间序列数据的意义取决于具体的应用场景，主要有以下几种：</p>
<ul>
<li>时间戳（timestamp），特定的时刻。</li>
<li>固定时期（period），如2007年1月或2010年全年。</li>
<li>时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。</li>
<li>实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。</li>
</ul>
<h3 id="日期和时间数据类型及工具"><a href="#日期和时间数据类型及工具" class="headerlink" title="日期和时间数据类型及工具"></a>日期和时间数据类型及工具</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="comment"># 以毫秒形式存储日期和时间</span></span><br><span class="line">now = datetime.now() <span class="comment"># datetime.datetime(2017, 9, 25, 14, 5, 52, 72973)</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">start = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>)</span><br><span class="line">datetime.timedelta(<span class="number">926</span>, <span class="number">56700</span>) <span class="comment"># day and second</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-4af261a305a70aeb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="字符串和datetime的相互转换"><a href="#字符串和datetime的相互转换" class="headerlink" title="字符串和datetime的相互转换"></a>字符串和datetime的相互转换</h4><p><code>datetime.strptime</code>是通过已知格式进行日期解析的最佳方式，但是每次都要编写格式定义。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stamp = datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">str(stamp) <span class="comment"># '2011-01-03 00:00:00'</span></span><br><span class="line">stamp.strftime(<span class="string">'%Y-%m-%d'</span>) <span class="comment">#'2011-01-03'</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-50c751823754df58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-de0181e1f6b45eaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="string">'2011-01-03'</span></span><br><span class="line">datetime.strptime(value, <span class="string">'%Y-%m-%d'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dateutil.parser <span class="keyword">import</span> parse</span><br><span class="line">parse(<span class="string">'2011-01-03'</span>) <span class="comment"># datetime.datetime(2011, 1, 3, 0, 0)</span></span><br><span class="line">parse(<span class="string">'Jan 31, 1997 10:45 PM'</span>)</span><br><span class="line">parse(<span class="string">'6/12/2011'</span>, dayfirst=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<p>一些常见的日期格式可以用dateutil这个第三方包中的parser.parse方法。</p>
<p>pandas通常是用于处理成组日期的，不管这些日期是DataFrame的轴索引还是列。to_datetime方法可以解析多种不同的日期表示形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">datestrs = [<span class="string">'2011-07-06 12:00:00'</span>, <span class="string">'2011-08-06 00:00:00'</span>]</span><br><span class="line">pd.to_datetime(datestrs) <span class="comment"># DatetimeIndex(['2011-07-06 12:00:00', '2011-08-06 00:00:00'], dtype='datetime64[ns]', freq=None)</span></span><br></pre></td></tr></table></figure>

<p>NaT（Not a Time）是pandas中时间戳数据的null值。</p>
<ul>
<li><p>注意：dateutil.parser是一个实用但不完美的工具。比如说，它会把一些原本不是日期的字符串认作是日期（比如”42”会被解析为2042年的今天）。</p>
<p>特定于当前环境（位于不同国家或使用不同语言的系统）的日期格式</p>
</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-cf0119398273e2b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h3 id="时间序列基础"><a href="#时间序列基础" class="headerlink" title="时间序列基础"></a>时间序列基础</h3><p>pandas用NumPy的datetime64数据类型以纳秒形式存储时间戳。</p>
<p>datetime对象用作index时，实际上被放在一个DatetimeIndex中，其中的各个标量值是pandas的Timestamp对象。</p>
<h4 id="索引、选取、子集构造"><a href="#索引、选取、子集构造" class="headerlink" title="索引、选取、子集构造"></a>索引、选取、子集构造</h4><p>根据标签索引选取数据时，</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">stamp = ts.index[<span class="number">2</span>] </span><br><span class="line">ts[stamp]</span><br><span class="line"><span class="comment"># 下面这种格式也可以</span></span><br><span class="line">ts[<span class="string">'1/10/2011'</span>]</span><br><span class="line">ts[<span class="string">'20110110'</span>]</span><br><span class="line"><span class="comment"># 对于较长的时间序列，只需传入“年”或“年月”即可轻松选取数据的切片</span></span><br><span class="line">longer_ts = pd.Series(np.random.randn(<span class="number">1000</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">1000</span>))</span><br><span class="line">longer_ts[<span class="string">'2001'</span>]</span><br><span class="line">longer_ts[<span class="string">'2001-05'</span>]</span><br><span class="line"><span class="comment"># 使用datetime对象进行切片</span></span><br><span class="line">ts[datetime(<span class="number">2011</span>, <span class="number">1</span>, <span class="number">7</span>):]</span><br><span class="line"><span class="comment"># 也可以用不存在于该时间序列中的时间戳对其进行切片（即范围查询）</span></span><br><span class="line">ts[<span class="string">'1/6/2011'</span>:<span class="string">'1/11/2011'</span>] <span class="comment"># 产生的是原时间序列的视图</span></span><br><span class="line">ts.truncate(after=<span class="string">'1/9/2011'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="带有重复索引的时间序列"><a href="#带有重复索引的时间序列" class="headerlink" title="带有重复索引的时间序列"></a>带有重复索引的时间序列</h4><p>多个观测数据落在同一个时间点上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.DatetimeIndex([<span class="string">'1/1/2000'</span>, <span class="string">'1/2/2000'</span>, <span class="string">'1/2/2000'</span>,<span class="string">'1/2/2000'</span>, <span class="string">'1/3/2000'</span>])</span><br><span class="line">dup_ts = pd.Series(np.arange(<span class="number">5</span>), index=dates)</span><br><span class="line">dup_ts.index.is_unique</span><br><span class="line"><span class="comment"># 对具有非唯一时间戳的数据进行聚合</span></span><br><span class="line">grouped = dup_ts.groupby(level=<span class="number">0</span>)</span><br><span class="line">grouped.mean()</span><br><span class="line">grouped.count()</span><br></pre></td></tr></table></figure>

<h3 id="日期的范围、频率以及移动"><a href="#日期的范围、频率以及移动" class="headerlink" title="日期的范围、频率以及移动"></a>日期的范围、频率以及移动</h3><p>pandas中的原生时间序列没有固定的频率,一般被认为是不规则的。但pandas有一整套标准时间序列频率以及用于重采样、频率推断、生成固定频率日期范围的工具。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">resampler = ts.resample(<span class="string">'D'</span>)</span><br><span class="line"><span class="comment"># 字符串“D”是每天的意思</span></span><br></pre></td></tr></table></figure>

<h4 id="生成日期范围"><a href="#生成日期范围" class="headerlink" title="生成日期范围"></a>生成日期范围</h4><p><code>pandas.date_range</code>可用于根据指定的频率生成指定长度的DatetimeIndex.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-04-01'</span>, <span class="string">'2012-06-01'</span>)</span><br><span class="line">pd.date_range(start=<span class="string">'2012-04-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line">pd.date_range(end=<span class="string">'2012-06-01'</span>, periods=<span class="number">20</span>)</span><br><span class="line"><span class="comment"># 生成一个由每月最后一个工作日组成的日期索引</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-12-01'</span>, freq=<span class="string">'BM'</span>) <span class="comment">#"BM"频率business end of month</span></span><br></pre></td></tr></table></figure>

<p>date_range默认会保留起始和结束时间戳的时间信息</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 每个日期都有12:56:31,可以关掉</span></span><br><span class="line">pd.date_range(<span class="string">'2012-05-02 12:56:31'</span>, periods=<span class="number">5</span>, normalize=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h4 id="频率和日期偏移量"><a href="#频率和日期偏移量" class="headerlink" title="频率和日期偏移量"></a>频率和日期偏移量</h4><p>pandas中的频率是由一个基础频率（base frequency）和一个乘数组成的</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Hour, Minute</span><br><span class="line">hour = Hour()</span><br><span class="line">four_hours = Hour(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 可以使用别名"H"或"4H"</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-01-03 23:59'</span>, freq=<span class="string">'4h'</span>)</span><br><span class="line"><span class="comment"># 偏移量对象都可通过加法进行连接</span></span><br><span class="line">Hour(<span class="number">2</span>) + Minute(<span class="number">30</span>) <span class="comment"># &lt;150 * Minutes&gt;</span></span><br><span class="line"><span class="comment"># 传入频率字符串</span></span><br><span class="line">pd.date_range(<span class="string">'2000-01-01'</span>, periods=<span class="number">10</span>, freq=<span class="string">'1h30min'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-c8614ddbd10793ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-8da46ba96544b071.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<p><img src="https://upload-images.jianshu.io/upload_images/7178691-3ca410609195edc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554/format/webp" alt="img"></p>
<h4 id="WOM日期"><a href="#WOM日期" class="headerlink" title="WOM日期"></a>WOM日期</h4><p>WOM（Week Of Month）是一种非常实用的频率类，获得诸如“每月第3个星期五”之类的日期。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'2012-01-01'</span>, <span class="string">'2012-09-01'</span>, freq=<span class="string">'WOM-3FRI'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="移动（超前和滞后）数据"><a href="#移动（超前和滞后）数据" class="headerlink" title="移动（超前和滞后）数据"></a>移动（超前和滞后）数据</h4><p>移动（shifting）指的是沿着时间轴将数据前移或后移。Series和DataFrame都有shift方法用于执行单纯的前移或后移操作，<strong>保持索引不变</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ts = pd.Series(np.random.randn(<span class="number">4</span>),index=pd.date_range(<span class="string">'1/1/2000'</span>, periods=<span class="number">4</span>, freq=<span class="string">'M'</span>))</span><br><span class="line"><span class="comment"># 数据位移，会在时间序列的前面或后面产生缺失数据</span></span><br><span class="line">ts.shift(<span class="number">2</span>)</span><br><span class="line">ts.shift(<span class="number">-2</span>)</span><br><span class="line"><span class="comment"># 实现对时间戳进行位移而不是对数据进行简单位移</span></span><br><span class="line">ts.shift(<span class="number">2</span>, freq=<span class="string">'M'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="通过偏移量对日期进行位移"><a href="#通过偏移量对日期进行位移" class="headerlink" title="通过偏移量对日期进行位移"></a>通过偏移量对日期进行位移</h4><p>pandas的日期偏移量还可以用在datetime或Timestamp对象上</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pandas.tseries.offsets <span class="keyword">import</span> Day, MonthEnd</span><br><span class="line">now = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">17</span>)</span><br><span class="line">now + <span class="number">3</span> * Day() <span class="comment"># Timestamp('2011-11-20 00:00:00')</span></span><br><span class="line"><span class="comment"># 使用锚点偏移量</span></span><br><span class="line">now + MonthEnd() <span class="comment"># Timestamp('2011-12-31 00:00:00')</span></span><br><span class="line"><span class="comment"># 通过锚点偏移量的rollforward和rollback方法，可明确地将日期向前或向后“滚动”</span></span><br><span class="line">offset = MonthEnd()</span><br><span class="line">offset.rollforward(now) <span class="comment"># Timestamp('2011-11-30 00:00:00')</span></span><br><span class="line">offset.rollback(now) <span class="comment"># Timestamp('2011-10-31 00:00:00')</span></span><br></pre></td></tr></table></figure>
<h3 id="时区处理"><a href="#时区处理" class="headerlink" title="时区处理"></a>时区处理</h3><h4 id="时区本地化和转换"><a href="#时区本地化和转换" class="headerlink" title="时区本地化和转换"></a>时区本地化和转换</h4><p>在Python中，时区信息来自第三方库pytz，它使Python可以使用Olson数据库（汇编了世界时区信息）。pandas包装了pytz的功能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line">pytz.common_timezones[<span class="number">-5</span>:]<span class="comment"># ['US/Eastern', 'US/Hawaii', 'US/Mountain', 'US/Pacific', 'UTC']</span></span><br><span class="line">tz = pytz.timezone(<span class="string">'America/New_York'</span>) <span class="comment"># &lt;DstTzInfo 'America/New_York' LMT-1 day, 19:04:00 STD&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，pandas中的时间序列是单纯（naive）的时区,其索引的tz字段为None。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">6</span>, freq=<span class="string">'D'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">print(ts.index.tz) <span class="comment"># None</span></span><br><span class="line"><span class="comment"># 可以指定时区</span></span><br><span class="line">pd.date_range(<span class="string">'3/9/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'D'</span>, tz=<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 通过tz_localize方法从单纯转换到本地化</span></span><br><span class="line">ts_utc = ts.tz_localize(<span class="string">'UTC'</span>)</span><br><span class="line"><span class="comment"># 被本地化到某个特定时区，就可以用tz_convert将其转换到别的时区</span></span><br><span class="line">ts_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br><span class="line"><span class="comment"># 独立的Timestamp对象也能被从单纯型（naive）本地化为时区意识型（time zone-aware）</span></span><br><span class="line">stamp = pd.Timestamp(<span class="string">'2011-03-12 04:00'</span>)</span><br><span class="line">stamp_utc = stamp.tz_localize(<span class="string">'utc'</span>)</span><br><span class="line">stamp_utc.tz_convert(<span class="string">'America/New_York'</span>)</span><br></pre></td></tr></table></figure>

<p>如果两个时间序列的时区不同，在将它们合并到一起时，最终结果就会是UTC</p>
 <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rng = pd.date_range(<span class="string">'3/7/2012 9:30'</span>, periods=<span class="number">10</span>, freq=<span class="string">'B'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts1 = ts[:<span class="number">7</span>].tz_localize(<span class="string">'Europe/London'</span>)</span><br><span class="line">ts2 = ts1[<span class="number">2</span>:].tz_convert(<span class="string">'Europe/Moscow'</span>)</span><br><span class="line">result = ts1 + ts2</span><br></pre></td></tr></table></figure>

<h3 id="时期及其算术运算"><a href="#时期及其算术运算" class="headerlink" title="时期及其算术运算"></a>时期及其算术运算</h3><p>时期（period）表示的是时间区间，比如数日、数月、数季、数年等。Period类所表示的就是这种数据类型，其构造函数需要用到一个字符串或整数，以及频率符号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p = pd.Period(<span class="number">2007</span>, freq=<span class="string">'A-DEC'</span>) <span class="comment">#表示的是从2007年1月1日到2007年12月31日之间的整段时间</span></span><br><span class="line"><span class="comment"># 对Period对象加上或减去一个整数即可达到根据其频率进行位移的效果</span></span><br><span class="line">p + <span class="number">5</span>  <span class="comment"># Period('2012', 'A-DEC')</span></span><br><span class="line"><span class="comment"># period_range函数可用于创建规则的时期范围</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2000-01-01'</span>, <span class="string">'2000-06-30'</span>, freq=<span class="string">'M'</span>) <span class="comment"># 返回PeriodIndex对象</span></span><br><span class="line"><span class="comment"># 字符串数组，可以使用PeriodIndex类：</span></span><br><span class="line">values = [<span class="string">'2001Q3'</span>, <span class="string">'2002Q2'</span>, <span class="string">'2003Q1'</span>]</span><br><span class="line">index = pd.PeriodIndex(values, freq=<span class="string">'Q-DEC'</span>)</span><br></pre></td></tr></table></figure>

<h4 id="时期的频率转换"><a href="#时期的频率转换" class="headerlink" title="时期的频率转换"></a>时期的频率转换</h4><p>Period和PeriodIndex对象都可以通过其asfreq方法被转换成别的频率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-DEC'</span>)<span class="comment"># Period('2007', 'A-DEC')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)<span class="comment"># Period('2007-01', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, how=<span class="string">'end'</span>)<span class="comment">#  Period('2007-12', 'M')</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">p = pd.Period(<span class="string">'2007'</span>, freq=<span class="string">'A-JUN'</span>)</span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'start'</span>)  <span class="comment"># Period('2006-07', 'M')</span></span><br><span class="line">p.asfreq(<span class="string">'M'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2007-06', 'M')</span></span><br><span class="line"><span class="comment"># 完整的PeriodIndex或TimeSeries的频率转换方式也是如此</span></span><br><span class="line">rng = pd.period_range(<span class="string">'2006'</span>, <span class="string">'2009'</span>, freq=<span class="string">'A-DEC'</span>)</span><br><span class="line">ts = pd.Series(np.random.randn(len(rng)), index=rng)</span><br><span class="line">ts.asfreq(<span class="string">'M'</span>, how=<span class="string">'start'</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-d201200d0e65676f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="按季度计算的时期频率"><a href="#按季度计算的时期频率" class="headerlink" title="按季度计算的时期频率"></a>按季度计算的时期频率</h4><p>时期”2012Q4”根据财年末的不同会有不同的含义。pandas支持12种可能的季度型频率，即Q-JAN到Q-DEC.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以1月结束的财年中，2012Q4是从11月到1月（将其转换为日型频率就明白了）</span></span><br><span class="line">p = pd.Period(<span class="string">'2012Q4'</span>, freq=<span class="string">'Q-JAN'</span>) <span class="comment"># Period('2012Q4', 'Q-JAN')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'start'</span>) <span class="comment"># Period('2011-11-01', 'D')</span></span><br><span class="line">p.asfreq(<span class="string">'D'</span>, <span class="string">'end'</span>) <span class="comment"># Period('2012-01-31', 'D')</span></span><br><span class="line"><span class="comment"># 获取该季度倒数第二个工作日下午4点的时间戳</span></span><br><span class="line">p4pm = (p.asfreq(<span class="string">'B'</span>, <span class="string">'e'</span>) - <span class="number">1</span>).asfreq(<span class="string">'T'</span>, <span class="string">'s'</span>) + <span class="number">16</span> * <span class="number">60</span> <span class="comment"># Period('2012-01-30 16:00', 'T')</span></span><br><span class="line">p4pm.to_timestamp() <span class="comment"># Timestamp('2012-01-30 16:00:00')</span></span><br></pre></td></tr></table></figure>

<p><img src="https://upload-images.jianshu.io/upload_images/7178691-e2e1d52c9766f6ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="img"></p>
<h4 id="将Timestamp转换为Period（及其反向过程）"><a href="#将Timestamp转换为Period（及其反向过程）" class="headerlink" title="将Timestamp转换为Period（及其反向过程）"></a>将Timestamp转换为Period（及其反向过程）</h4><p>to_period方法，可以将由时间戳索引的Series和DataFrame对象转换为以时期索引，要转换回时间戳，使用to_timestamp》</p>
<h4 id="通过数组创建PeriodIndex"><a href="#通过数组创建PeriodIndex" class="headerlink" title="通过数组创建PeriodIndex"></a>通过数组创建PeriodIndex</h4>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"># python</a>
              <a href="/tags/numpy/" rel="tag"># numpy</a>
              <a href="/tags/pandas/" rel="tag"># pandas</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/08/18/%E8%AF%8D%E4%BA%91/" rel="prev" title="词云">
      <i class="fa fa-chevron-left"></i> 词云
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/08/25/%E3%80%8AScikit-Learn%E4%B8%8ETensorFlow%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E7%94%A8%E6%8C%87%E5%8D%97%E3%80%8B/" rel="next" title="《Scikit-Learn与TensorFlow机器学习实用指南》">
      《Scikit-Learn与TensorFlow机器学习实用指南》 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#第2章-Python语法基础，IPython和Jupyter-Notebooks"><span class="nav-number">1.</span> <span class="nav-text">第2章 Python语法基础，IPython和Jupyter Notebooks</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IPython键盘快捷键"><span class="nav-number">1.1.</span> <span class="nav-text">IPython键盘快捷键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPython魔术命令"><span class="nav-number">1.2.</span> <span class="nav-text">IPython魔术命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Matplotlib"><span class="nav-number">1.3.</span> <span class="nav-text">Matplotlib</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python语法基础"><span class="nav-number">1.4.</span> <span class="nav-text">Python语法基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用缩进"><span class="nav-number">1.4.1.</span> <span class="nav-text">使用缩进</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#万物皆对象"><span class="nav-number">1.4.2.</span> <span class="nav-text">万物皆对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#位置和关键词参数"><span class="nav-number">1.4.3.</span> <span class="nav-text">位置和关键词参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量和参数传递："><span class="nav-number">1.4.4.</span> <span class="nav-text">变量和参数传递：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强类型化语言"><span class="nav-number">1.4.5.</span> <span class="nav-text">强类型化语言</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性和方法"><span class="nav-number">1.4.6.</span> <span class="nav-text">属性和方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#鸭子类型"><span class="nav-number">1.4.7.</span> <span class="nav-text">鸭子类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#引入"><span class="nav-number">1.4.8.</span> <span class="nav-text">引入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#二元运算符和比较运算符"><span class="nav-number">1.4.9.</span> <span class="nav-text">二元运算符和比较运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可变与不可变对象"><span class="nav-number">1.4.10.</span> <span class="nav-text">可变与不可变对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#标量类型"><span class="nav-number">1.4.11.</span> <span class="nav-text">标量类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数值类型"><span class="nav-number">1.4.12.</span> <span class="nav-text">数值类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串"><span class="nav-number">1.4.13.</span> <span class="nav-text">字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字节和Unicode"><span class="nav-number">1.4.14.</span> <span class="nav-text">字节和Unicode</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#None"><span class="nav-number">1.4.15.</span> <span class="nav-text">None</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间和日期"><span class="nav-number">1.4.16.</span> <span class="nav-text">时间和日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制流"><span class="nav-number">1.4.17.</span> <span class="nav-text">控制流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#if语句："><span class="nav-number">1.4.17.1.</span> <span class="nav-text">if语句：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#for循环："><span class="nav-number">1.4.17.2.</span> <span class="nav-text">for循环：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#while循环："><span class="nav-number">1.4.17.3.</span> <span class="nav-text">while循环：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#pass："><span class="nav-number">1.4.17.4.</span> <span class="nav-text">pass：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#三元表达式"><span class="nav-number">1.4.18.</span> <span class="nav-text">三元表达式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第3章-Python的数据结构、函数和文件"><span class="nav-number">2.</span> <span class="nav-text">第3章 Python的数据结构、函数和文件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据结构和序列"><span class="nav-number">2.1.</span> <span class="nav-text">数据结构和序列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#元组"><span class="nav-number">2.1.1.</span> <span class="nav-text">元组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#拆分元组"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">拆分元组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#tuple方法"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">tuple方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#列表"><span class="nav-number">2.1.2.</span> <span class="nav-text">列表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#串联和组合列表"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">串联和组合列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#排序"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">排序</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#二分搜索和维护已排序的列表"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">二分搜索和维护已排序的列表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#切片"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">切片</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#序列函数"><span class="nav-number">2.1.3.</span> <span class="nav-text">序列函数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#enumerate函数"><span class="nav-number">2.1.3.1.</span> <span class="nav-text">enumerate函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#sorted函数"><span class="nav-number">2.1.3.2.</span> <span class="nav-text">sorted函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#zip函数"><span class="nav-number">2.1.3.3.</span> <span class="nav-text">zip函数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#reversed函数"><span class="nav-number">2.1.3.4.</span> <span class="nav-text">reversed函数</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字典"><span class="nav-number">2.1.4.</span> <span class="nav-text">字典</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#用序列创建字典"><span class="nav-number">2.1.4.1.</span> <span class="nav-text">用序列创建字典</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认值"><span class="nav-number">2.1.4.2.</span> <span class="nav-text">默认值</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#有效的键对类型"><span class="nav-number">2.1.4.3.</span> <span class="nav-text">有效的键对类型</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#集合"><span class="nav-number">2.1.5.</span> <span class="nav-text">集合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#合并（union方法，或者-运算符）"><span class="nav-number">2.1.5.1.</span> <span class="nav-text">合并（union方法，或者|运算符）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#交集（intersection或-amp-运算符）"><span class="nav-number">2.1.5.2.</span> <span class="nav-text">交集（intersection或&amp;运算符）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#列表，集合和字典推导式"><span class="nav-number">2.1.5.3.</span> <span class="nav-text">列表，集合和字典推导式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#嵌套列表推导式"><span class="nav-number">2.1.5.4.</span> <span class="nav-text">嵌套列表推导式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数"><span class="nav-number">2.2.</span> <span class="nav-text">函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#命名空间、作用域和局部函数"><span class="nav-number">2.2.1.</span> <span class="nav-text">命名空间、作用域和局部函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#返回多个值"><span class="nav-number">2.2.2.</span> <span class="nav-text">返回多个值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数也是对象"><span class="nav-number">2.2.3.</span> <span class="nav-text">函数也是对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#匿名（lambda）函数"><span class="nav-number">2.2.4.</span> <span class="nav-text">匿名（lambda）函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#柯里化：部分参数应用"><span class="nav-number">2.2.5.</span> <span class="nav-text">柯里化：部分参数应用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#生成器"><span class="nav-number">2.2.6.</span> <span class="nav-text">生成器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#生成器表达式（generator-expression）"><span class="nav-number">2.2.6.1.</span> <span class="nav-text">生成器表达式（generator expression）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#itertools模块"><span class="nav-number">2.2.6.2.</span> <span class="nav-text">itertools模块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误和异常处理"><span class="nav-number">2.2.7.</span> <span class="nav-text">错误和异常处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IPython的异常"><span class="nav-number">2.2.8.</span> <span class="nav-text">IPython的异常</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件和操作系统"><span class="nav-number">2.3.</span> <span class="nav-text">文件和操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常用方法-read、seek、tell"><span class="nav-number">2.3.1.</span> <span class="nav-text">常用方法 read、seek、tell</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的字节和Unicode"><span class="nav-number">2.3.2.</span> <span class="nav-text">文件的字节和Unicode</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第4章-NumPy基础：数组和矢量计算"><span class="nav-number">3.</span> <span class="nav-text">第4章 NumPy基础：数组和矢量计算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#多维数组对象ndarray"><span class="nav-number">3.1.</span> <span class="nav-text">多维数组对象ndarray</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建ndarray"><span class="nav-number">3.1.1.</span> <span class="nav-text">创建ndarray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ndarray的数据类型"><span class="nav-number">3.1.2.</span> <span class="nav-text">ndarray的数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#NumPy数组的运算"><span class="nav-number">3.1.3.</span> <span class="nav-text">NumPy数组的运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基本的索引和切片"><span class="nav-number">3.1.4.</span> <span class="nav-text">基本的索引和切片</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#一维数组"><span class="nav-number">3.1.4.1.</span> <span class="nav-text">一维数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#高维度数组"><span class="nav-number">3.1.4.2.</span> <span class="nav-text">高维度数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#切片索引"><span class="nav-number">3.1.4.3.</span> <span class="nav-text">切片索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#布尔型索引"><span class="nav-number">3.1.4.4.</span> <span class="nav-text">布尔型索引</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#花式索引"><span class="nav-number">3.1.4.5.</span> <span class="nav-text">花式索引</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组转置和轴兑换"><span class="nav-number">3.1.5.</span> <span class="nav-text">数组转置和轴兑换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通用函数：快速的元素级数组函数"><span class="nav-number">3.2.</span> <span class="nav-text">通用函数：快速的元素级数组函数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数学和统计方法"><span class="nav-number">3.2.1.</span> <span class="nav-text">数学和统计方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用于布尔型数组的方法"><span class="nav-number">3.2.2.</span> <span class="nav-text">用于布尔型数组的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一化以及其它的集合逻辑"><span class="nav-number">3.2.3.</span> <span class="nav-text">唯一化以及其它的集合逻辑</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用于数组的文件输入输出"><span class="nav-number">3.3.</span> <span class="nav-text">用于数组的文件输入输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线性代数"><span class="nav-number">3.4.</span> <span class="nav-text">线性代数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#伪随机数生成"><span class="nav-number">3.5.</span> <span class="nav-text">伪随机数生成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#示例：随机漫步"><span class="nav-number">3.6.</span> <span class="nav-text">示例：随机漫步</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一次模拟多个随机漫步"><span class="nav-number">3.6.1.</span> <span class="nav-text">一次模拟多个随机漫步</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第5章-pandas入门"><span class="nav-number">4.</span> <span class="nav-text">第5章 pandas入门</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#pandas的数据结构介绍"><span class="nav-number">4.1.</span> <span class="nav-text">pandas的数据结构介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Series"><span class="nav-number">4.1.1.</span> <span class="nav-text">Series</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataFrame"><span class="nav-number">4.1.2.</span> <span class="nav-text">DataFrame</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引对象"><span class="nav-number">4.1.3.</span> <span class="nav-text">索引对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重新索引"><span class="nav-number">4.1.4.</span> <span class="nav-text">重新索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#丢弃指定轴上的项"><span class="nav-number">4.1.5.</span> <span class="nav-text">丢弃指定轴上的项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引、选取和过滤"><span class="nav-number">4.1.6.</span> <span class="nav-text">索引、选取和过滤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用loc和iloc进行选取"><span class="nav-number">4.1.7.</span> <span class="nav-text">用loc和iloc进行选取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整数索引"><span class="nav-number">4.1.8.</span> <span class="nav-text">整数索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#算术运算和数据对齐"><span class="nav-number">4.1.9.</span> <span class="nav-text">算术运算和数据对齐</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#在算术方法中填充值"><span class="nav-number">4.1.10.</span> <span class="nav-text">在算术方法中填充值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DataFrame和Series之间的运算"><span class="nav-number">4.1.11.</span> <span class="nav-text">DataFrame和Series之间的运算</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#函数应用和映射"><span class="nav-number">4.1.12.</span> <span class="nav-text">函数应用和映射</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序和排名"><span class="nav-number">4.1.13.</span> <span class="nav-text">排序和排名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有重复标签的轴索引"><span class="nav-number">4.1.14.</span> <span class="nav-text">带有重复标签的轴索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#汇总和计算描述统计"><span class="nav-number">4.2.</span> <span class="nav-text">汇总和计算描述统计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#相关系数与协方差"><span class="nav-number">4.2.1.</span> <span class="nav-text">相关系数与协方差</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一值、值计数以及成员资格"><span class="nav-number">4.2.2.</span> <span class="nav-text">唯一值、值计数以及成员资格</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第6章-数据加载、存储与文件格式"><span class="nav-number">5.</span> <span class="nav-text">第6章 数据加载、存储与文件格式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#读写文本格式的数据"><span class="nav-number">5.1.</span> <span class="nav-text">读写文本格式的数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逐块读取文本文件"><span class="nav-number">5.1.1.</span> <span class="nav-text">逐块读取文本文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将数据写出到文本格式"><span class="nav-number">5.1.2.</span> <span class="nav-text">将数据写出到文本格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#处理分隔符格式"><span class="nav-number">5.1.3.</span> <span class="nav-text">处理分隔符格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#JSON"><span class="nav-number">5.1.4.</span> <span class="nav-text">JSON</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#XML和HTML：Web信息收集"><span class="nav-number">5.1.5.</span> <span class="nav-text">XML和HTML：Web信息收集</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#二进制数据格式"><span class="nav-number">5.2.</span> <span class="nav-text">二进制数据格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#HDF5格式"><span class="nav-number">5.2.1.</span> <span class="nav-text">HDF5格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#读取Microsoft-Excel文件"><span class="nav-number">5.2.2.</span> <span class="nav-text">读取Microsoft Excel文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Web-APIs交互"><span class="nav-number">5.3.</span> <span class="nav-text">Web APIs交互</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库交互"><span class="nav-number">5.4.</span> <span class="nav-text">数据库交互</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第7章-数据清洗和准备"><span class="nav-number">6.</span> <span class="nav-text">第7章 数据清洗和准备</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理缺失数据"><span class="nav-number">6.1.</span> <span class="nav-text">处理缺失数据</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#滤除缺失数据"><span class="nav-number">6.1.1.</span> <span class="nav-text">滤除缺失数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充缺失数据"><span class="nav-number">6.1.2.</span> <span class="nav-text">填充缺失数据</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据转换"><span class="nav-number">6.2.</span> <span class="nav-text">数据转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#移除重复数据"><span class="nav-number">6.2.1.</span> <span class="nav-text">移除重复数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#利用函数或映射进行数据转换"><span class="nav-number">6.2.2.</span> <span class="nav-text">利用函数或映射进行数据转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#替换值"><span class="nav-number">6.2.3.</span> <span class="nav-text">替换值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重命名轴索引"><span class="nav-number">6.2.4.</span> <span class="nav-text">重命名轴索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#离散化和面元划分"><span class="nav-number">6.2.5.</span> <span class="nav-text">离散化和面元划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#检测和过滤异常值"><span class="nav-number">6.2.6.</span> <span class="nav-text">检测和过滤异常值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排列和随机采样"><span class="nav-number">6.2.7.</span> <span class="nav-text">排列和随机采样</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#计算指标-哑变量"><span class="nav-number">6.2.8.</span> <span class="nav-text">计算指标&#x2F;哑变量</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串操作"><span class="nav-number">6.3.</span> <span class="nav-text">字符串操作</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#正则表达式"><span class="nav-number">6.3.1.</span> <span class="nav-text">正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#pandas的矢量化字符串函数"><span class="nav-number">6.3.2.</span> <span class="nav-text">pandas的矢量化字符串函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第8章-数据规整：聚合、合并和重塑"><span class="nav-number">7.</span> <span class="nav-text">第8章 数据规整：聚合、合并和重塑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层次化索引"><span class="nav-number">7.1.</span> <span class="nav-text">层次化索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#重排与分级排序"><span class="nav-number">7.1.1.</span> <span class="nav-text">重排与分级排序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#根据级别汇总统计"><span class="nav-number">7.1.2.</span> <span class="nav-text">根据级别汇总统计</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用DataFrame的列进行索引"><span class="nav-number">7.1.3.</span> <span class="nav-text">使用DataFrame的列进行索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#合并数据集"><span class="nav-number">7.2.</span> <span class="nav-text">合并数据集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据库风格的DataFrame合并"><span class="nav-number">7.2.1.</span> <span class="nav-text">数据库风格的DataFrame合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#索引上的合并"><span class="nav-number">7.2.2.</span> <span class="nav-text">索引上的合并</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#轴向连接"><span class="nav-number">7.2.3.</span> <span class="nav-text">轴向连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#合并重叠数据"><span class="nav-number">7.2.4.</span> <span class="nav-text">合并重叠数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第11章-时间序列"><span class="nav-number">8.</span> <span class="nav-text">第11章 时间序列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#日期和时间数据类型及工具"><span class="nav-number">8.1.</span> <span class="nav-text">日期和时间数据类型及工具</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串和datetime的相互转换"><span class="nav-number">8.1.1.</span> <span class="nav-text">字符串和datetime的相互转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间序列基础"><span class="nav-number">8.2.</span> <span class="nav-text">时间序列基础</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#索引、选取、子集构造"><span class="nav-number">8.2.1.</span> <span class="nav-text">索引、选取、子集构造</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#带有重复索引的时间序列"><span class="nav-number">8.2.2.</span> <span class="nav-text">带有重复索引的时间序列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#日期的范围、频率以及移动"><span class="nav-number">8.3.</span> <span class="nav-text">日期的范围、频率以及移动</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#生成日期范围"><span class="nav-number">8.3.1.</span> <span class="nav-text">生成日期范围</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#频率和日期偏移量"><span class="nav-number">8.3.2.</span> <span class="nav-text">频率和日期偏移量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#WOM日期"><span class="nav-number">8.3.3.</span> <span class="nav-text">WOM日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#移动（超前和滞后）数据"><span class="nav-number">8.3.4.</span> <span class="nav-text">移动（超前和滞后）数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过偏移量对日期进行位移"><span class="nav-number">8.3.5.</span> <span class="nav-text">通过偏移量对日期进行位移</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时区处理"><span class="nav-number">8.4.</span> <span class="nav-text">时区处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时区本地化和转换"><span class="nav-number">8.4.1.</span> <span class="nav-text">时区本地化和转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时期及其算术运算"><span class="nav-number">8.5.</span> <span class="nav-text">时期及其算术运算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时期的频率转换"><span class="nav-number">8.5.1.</span> <span class="nav-text">时期的频率转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按季度计算的时期频率"><span class="nav-number">8.5.2.</span> <span class="nav-text">按季度计算的时期频率</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#将Timestamp转换为Period（及其反向过程）"><span class="nav-number">8.5.3.</span> <span class="nav-text">将Timestamp转换为Period（及其反向过程）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过数组创建PeriodIndex"><span class="nav-number">8.5.4.</span> <span class="nav-text">通过数组创建PeriodIndex</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QQAI"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">QQAI</p>
  <div class="site-description" itemprop="description">Home is behind, the world ahead</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QQAI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

  

</body>
</html>
