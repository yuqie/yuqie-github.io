<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="认识操作系统">
<meta property="og:type" content="article">
<meta property="og:title" content="操作系统">
<meta property="og:url" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="Ringinmay&#39;s Blog">
<meta property="og:description" content="认识操作系统">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217528868.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600160298027.png">
<meta property="og:image" content="https://img-blog.csdn.net/20180718153127412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JqYXJuZUNwcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70">
<meta property="og:image" content="https://bkimg.cdn.bcebos.com/pic/9345d688d43f8794964ce0bdd31b0ef41ad53af5?x-bce-process=image/resize,m_lfit,w_250,h_250,limit_1">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600168907591.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600174254344.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600174669528.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216350126.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216585570.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216594038.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217029845.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217767997.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600220979244.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600225430669.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600233868365.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600234612151.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600237514736.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240126229.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240676849.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240942918.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600241408214.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600246506593.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600259991563.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600260741139.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262207567.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262739859.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262824458.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262922944.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600327716389.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600330767595.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600331216327.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600331687285.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600332477587.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600332692103.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600333059233.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600333186105.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600334025618.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600337115639.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600337144675.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600338063467.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600349120853.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600350074121.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600350829224.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600351378026.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600351821747.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600352565654.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600354302449.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391479702.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391494196.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391706575.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600392296985.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600392723432.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600397144597.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600398022673.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600416897823.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600416930613.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600418399431.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600418767973.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419071897.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419317010.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419649541.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419685650.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419871957.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600420838617.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600420953207.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200918190257435.png">
<meta property="og:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200918191841473.png">
<meta property="article:published_time" content="2020-09-15T03:20:39.000Z">
<meta property="article:modified_time" content="2020-09-19T01:51:12.501Z">
<meta property="article:author" content="QQAI">
<meta property="article:tag" content="OS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217528868.png">

<link rel="canonical" href="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>操作系统 | Ringinmay's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ringinmay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Home is behind, the world ahead</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          操作系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-15 11:20:39" itemprop="dateCreated datePublished" datetime="2020-09-15T11:20:39+08:00">2020-09-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-19 09:51:12" itemprop="dateModified" datetime="2020-09-19T09:51:12+08:00">2020-09-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="认识操作系统"><a href="#认识操作系统" class="headerlink" title="认识操作系统"></a>认识操作系统</h2><p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217528868.png" alt="1600217528868"></p>
<a id="more"></a>
<p><a href="https://blog.csdn.net/weixin_34408717/article/details/92328959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param" target="_blank" rel="noopener">BSD操作系统大盘点：四种主流BSD</a></p>
<p>现在，共有5个流行的BSD操作系统，其中的三个——FreeBSD，NetBSD 和OpenBSD——得到了BSD的授权，操作系统和源代码都是免费的，任何人都可以用于任何目的。其余的两个BSD/OS和Mac OS X是商业产品，它们以开放的BSD代码为基础，具有特殊的优势和与众不同的技术。</p>
<ol>
<li>OpenBSD非常适合用于网络路由器、防火墙和安全互联网服务解决方案中，因为它具有高水平的内置安全和加密功能。操作系统很小，但效率很高，它能在老的只有16MB内存的486机器上运行得很好</li>
<li>FreeBSD的重点是性能，特别是TCP/IP堆栈的性能。包括雅虎在内的许多公司都在使用FreeBSD作为互联网服务器平台。FreeBSD还有一项传输数据的非正式的记录，一台运行这个操作系统的服务器传输了2TB以上的数据。这个统计还显示，FreeBSD还是最稳定的操作系统之一。</li>
<li>基于BSD的最轻便的操作系统。目前能够在46种之多的不同硬件构架上运行, 嵌入式系统的最佳选择。</li>
</ol>
<p>台式机：</p>
<blockquote>
<p>FreeBSD是一种稳定的和广泛支持的选择。</p>
<p>对于比较老的硬件或者非主流的硬件来说，NetBSD也许是更好的解决方案。</p>
<p>如果正在开发部署针对多种嵌入式系统的解决方案，NetBSD应该是很好的选择，因为它可以方便的应用于各种目标平台。</p>
</blockquote>
<p>服务器：</p>
<blockquote>
<p>OpenBSD显然是服务器的选择，因为它有非常高的安全政策。拥有这样的安全环境，很容易部署基于OpenBSD的服务器，而不比太担心这个系统或者网络被攻破。OpenBSD用于网络的公共方面、提供防火墙和互联网与内部网络之间的代理服务是特别理想的。</p>
<p>对于纯Web服务器来说，FreeBSD也是一个很好的选择，因为它在x86等关键的硬件平台上具有很好的稳定性。硬盘和网络堆栈的质量意决定了服务器的可用性。特别是通过关闭你不需要支持的服务，还能使FreeBSD更加安全。</p>
</blockquote>
<h3 id="x86-系统的结构"><a href="#x86-系统的结构" class="headerlink" title="x86 系统的结构"></a>x86 系统的结构</h3><p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600160298027.png" alt="1600160298027"></p>
<h4 id="PCI-E"><a href="#PCI-E" class="headerlink" title="PCI-E"></a>PCI-E</h4><p>PCIe (Peripheral Component Interconnect Express，PCI-Express)一种高速串行计算机扩展总线标准，PCIe属于高速串行点对点双通道高带宽传输，所连接的设备分配独享通道带宽，不共享总线带宽，主要支持主动电源管理，错误报告，端对端的可靠性传输，热插拔以及服务质量(<a href="https://baike.baidu.com/item/QOS" target="_blank" rel="noopener">QOS</a>)等功能。</p>
<p>PCIe Sizes：x16 vs x8 vs x4 vs x1</p>
<p>x后面的数字表示PCIe卡或插槽的物理大小，x16是最大的，x1是最小的。以下是各种尺寸的形状：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>-</th>
<th>Number of Pins（引脚的数量）</th>
<th>Length</th>
</tr>
</thead>
<tbody>
<tr>
<td>PCI Express x1</td>
<td>18</td>
<td>25毫米</td>
</tr>
<tr>
<td>PCI Express x4</td>
<td>32</td>
<td>39毫米</td>
</tr>
<tr>
<td>PCI Express x8</td>
<td>49</td>
<td>56毫米</td>
</tr>
<tr>
<td>PCI Express x16</td>
<td>82</td>
<td>89毫米</td>
</tr>
</tbody>
</table>
</div>
<p>不管PCIe插槽或卡片的大小是多少，关键的凹槽，卡或槽中的小空间，总是在大头针11上。</p>
<p>PCIe卡片适合于主板上的任何PCIe插槽，它的大小至少和它一样大。例如，PCIe x1卡将适用于任何PCIe x4、PCIe x8或PCIe x16插槽。</p>
<p><img src="https://img-blog.csdn.net/20180718153127412?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0JqYXJuZUNwcA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h4 id="MDI"><a href="#MDI" class="headerlink" title="MDI"></a>MDI</h4><p>Medium Dependent Interface ，介质相关接口。在 hub 或 switch 中有两种接口，分别叫 MDI port和 MDI-X port， MDI port 也叫做级联端口（ uplink port ），是 hub 或 switch 之间相互连接的端口。 </p>
<p>MDI port和 MDI-X port 之间最大的区别在于， MDI port内部发送数据线和接收数据线没交叉， 而MDI-X port 内部发送数据线和接收数据线是交叉的，这个X代表交叉的意思。</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/9345d688d43f8794964ce0bdd31b0ef41ad53af5?x-bce-process=image/resize,m_lfit,w_250,h_250,limit_1" alt="img"></p>
<p>计算机和交换机的连接要用直通线，交换机和交换机之间的连接要用交叉线，</p>
<h4 id="DMI"><a href="#DMI" class="headerlink" title="DMI"></a>DMI</h4><p>DMI是指Direct Media Interface(直接媒体接口)，用于连接主板南北桥的总线，取代了以前的Hub-Link总线。它基于<a href="https://baike.baidu.com/item/PCI-Express" target="_blank" rel="noopener">PCI-Express</a>总线，跟随PCI-E总线的换代而换代。DMI采用点对点的连接方式，时钟频率为100MHz。</p>
<h4 id="USB"><a href="#USB" class="headerlink" title="USB"></a>USB</h4><p>USB(Univversal Serial Bus) 连接慢速 I/O 设备和计算机。USB 1.0 ：12 Mb/s，USB 2.0 总线速度 480Mb/s，USB 3.0不小于 5Gb/s。USB连接不需要重启计算机。</p>
<h4 id="SCSI"><a href="#SCSI" class="headerlink" title="SCSI"></a>SCSI</h4><p>SCSI(Small Computer System Interface) 总线是一种高速总线，用在高速硬盘，扫描仪和其他需要较大带宽的设备上。现在，它们主要用在服务器和工作站中，速度可以达到640MB/s。</p>
<h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><h4 id="RAM"><a href="#RAM" class="headerlink" title="RAM"></a>RAM</h4><h4 id="ROM"><a href="#ROM" class="headerlink" title="ROM"></a>ROM</h4><blockquote>
<ol>
<li><p>rom最初不能编程，出厂什么内容就永远什么内容，不灵活。</p>
</li>
<li><p>后来出现了prom，可以自己写入一次，要是写错了，只能换一片。</p>
</li>
<li><p>人类文明不断进步，终于出现了可多次擦除写入的EPROM，每次擦除要把芯片拿到紫外线上照一下.</p>
</li>
<li><p>历史的车轮不断前进，伟大的EEPROM出现了，拯救了一大批程序员，终于可以随意的修改rom中的内容了。</p>
<p>ROM—PROM—EPROM—EEPROM的进化！</p>
</li>
</ol>
</blockquote>
<h4 id="EEPROM"><a href="#EEPROM" class="headerlink" title="EEPROM"></a>EEPROM</h4><p>全称是“电可擦除可编程只读存储器，即Electrically Erasable Programmable Read-Only Memory。是相对于紫外擦除的rom来讲的。但是今天已经存在多种EEPROM的变种，变成了一类存储器的统称。</p>
<h4 id="Flash"><a href="#Flash" class="headerlink" title="Flash"></a>Flash</h4><p>狭义的EEPROM：这种rom的特点是可以随机访问和修改任何一个字节，可以往每个bit中写入0或者1。这是最传统的一种EEPROM，掉电后数据不丢失，可以保存100年，可以擦写100w次。具有较高的可靠性，但是电路复杂/成本也高。因此目前的EEPROM都是几十千字节到几百千字节的，绝少有超过512K的。</p>
<p>Flash属于广义的EEPROM，也是电擦除的rom。但擦除时不再以字节为单位，而是以块为单位，一次简化了电路，数据密度更高，降低了成本。上M的rom一般都是flash。</p>
<p>flash分为nor flash和nand flash。</p>
<blockquote>
<ol>
<li>nor flash数据线和地址线分开，可以实现ram一样的随机寻址功能，可以读取任何一个字节。但是擦除仍要按块来擦。</li>
<li>nand flash同样是按块擦除，但是数据线和地址线复用，不能利用地址线随机寻址。读取只能按页来读取。（nandflash按块来擦除，按页来读，norflash没有页）</li>
<li>由于nandflash引脚上复用，因此读取速度比nor flash慢一点，但是擦除和写入速度比nor flash快很多。nand flash内部电路更简单，因此数据密度大，体积小，成本也低。因此大容量的flash都是nand型的。小容量的2～12M的flash多是nor型的。</li>
<li>使用寿命上，nand flash的擦除次数是nor的数倍。而且nand flash可以标记坏块，从而使软件跳过坏块。nor flash 一旦损坏便无法再用。</li>
<li>因为nor flash可以进行字节寻址，所以程序可以在nor flash中运行。嵌入式系统多用一个小容量的nor flash存储引导代码，用一个大容量的nand flash存放文件系统和内核。</li>
</ol>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/Pual623548198/p/7085319.html" target="_blank" rel="noopener">https://www.cnblogs.com/Pual623548198/p/7085319.html</a></p>
<h3 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h3><h4 id="基本输入输出系统-Basic-Input-Output-System-BIOS"><a href="#基本输入输出系统-Basic-Input-Output-System-BIOS" class="headerlink" title="基本输入输出系统(Basic Input Output System, BIOS)"></a>基本输入输出系统(Basic Input Output System, BIOS)</h4><p>保存在闪存中，非易失性。</p>
<p>有底层I/0软件：读键盘，写屏幕，磁盘I/O。</p>
<p>计算机启动时，检查设备，通过尝试存储在CMOS存储器中的设备清单尝试启动设备。</p>
<p>决定从外部（CD-ROM，USB）还是硬盘启动。</p>
<h4 id="互补金属氧化物半导体-Complementary-Metal-Oxide-Semiconductor-CMOS"><a href="#互补金属氧化物半导体-Complementary-Metal-Oxide-Semiconductor-CMOS" class="headerlink" title="互补金属氧化物半导体(Complementary Metal Oxide Semiconductor , CMOS)"></a>互补金属氧化物半导体(Complementary Metal Oxide Semiconductor , CMOS)</h4><p>电脑主板上的一块可读写的RAM芯片。用来保存BIOS设置完电脑硬件参数后的数据。</p>
<h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>大型机操作系统</p>
<p>服务器操作系统：典型的服务器操作系统有Solaris， FreeBSD，Linux，Windows Server 201x</p>
<p>多处理器操作系统：将多个CPU连接到一个系统中，并行计算机（多核处理器）</p>
<p>个人计算机系统：Linux，FreeBSD，Windows 7，Windows 8 ， OS X</p>
<p>掌上计算机：Abdroid和IOS</p>
<p>嵌入式操作系统：</p>
<p>传感器节点操作系统：</p>
<p>实时操作系统：硬实时系统和软实时系统</p>
<p>智能卡操作系统：信用卡</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><p>本质是操作系统执行的一个程序。</p>
<h5 id="地址空间："><a href="#地址空间：" class="headerlink" title="地址空间："></a>地址空间：</h5><p>32位有2^32字节的地址空间，64位有2^64字节的地址空间。</p>
<p>通常，每个进程有一些可以使用的地址集合，典型值从0开始到某个最大值，一个进程可拥有的最大地址空间小于主存，这种情况下，即使进程用完其地址空间，内存也会有足够的内存运行该进程。</p>
<blockquote>
<p>如果进程的地址空间比主存还大，可以把部分地址空间装入主存，部分留在磁盘，并在需要时来回交换（虚拟内存）</p>
</blockquote>
<p>磁芯映像 core image</p>
<p>资源集：寄存器（程序计数器和堆栈指针），打开文件的清单等 （这些都在进程表中）</p>
<p>进程表：与一个进程相关的所有信息，除了该进程自身空间的内容以外，均存放在操作系统的一张表中。是数组或者链表结构，当前存在每一个进程都占据其中的一项。</p>
<p>进程间通信：合作完成某些作业的相关进程需要彼此通信</p>
<h4 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h4><p>读写之前，检查访问权限，若权限许可，系统返回一个小整数（文件描述符），若禁止访问，系统返回一个错误码。</p>
<p>UNIX的特殊文件：为了使系统向调用读写文件一样调用I/O设备</p>
<p>块特殊文件：可随机存取的块组成的设备，比如磁盘</p>
<p>字符特殊文件：用于打印机，调制解调器和其他接受或输出字符流的设备。</p>
<p>管道：一种虚文件，可以用来连接两个进程。</p>
<h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><p>提供应用程序抽象：创建，写入，读取和删除文件。</p>
<p>管理计算资源：</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>以系统调用read(fd, buffer, nbytes)为例</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600168907591.png" alt="1600168907591"></p>
<p>首先把参数压入栈堆：1. C和C++编译器使用逆序 2. 第二个参数通过引用传递，即传递的是缓冲区的地址 &amp;</p>
<p>TRAP指令：将用户态切换到内核态。</p>
<p>完成调用之后，操作系统需要清除用户堆栈，增加堆栈指针（increment stackpointer）</p>
<h5 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h5><p>fork创建原有进程的副本，包括所有的文件描述，寄存器等。fork调用返回一个值，在子进程中为0，在父进程中等于子进程的进程标识符（Process IDentified，PID）。</p>
<h5 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h5><p>O_RDONLY O_WRONLY O_RDWR</p>
<p>iseek(fd,offset,whence)</p>
<h5 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h5><p>mkdir   rmdir</p>
<p>link(name1,name2) 允许同一个文件以两个或者多个名称出现。</p>
<p>每个文件都独一无二，i-number 是inodes表的索引。目录是一系列（i-编号，ASCII名称）的集合。</p>
<p>link利用某个已有文件的i-编号，穿件一个新的目录项。</p>
<p>mount(specila, name, flag)将两个文件系统合并为一个。<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600174254344.png" alt="1600174254344"></p>
<h5 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h5><p>chdir    chmod   kill</p>
<h3 id="Win-32-API"><a href="#Win-32-API" class="headerlink" title="Win 32 API"></a>Win 32 API</h3><p>UNIX程序由执行某些操作或执行其他操作的代码组成，进行系统调用以执行某些服务。</p>
<p>Windows应用程序通常是由事件驱动的，主程序等待一些时间发生，然后调用程序去处理。</p>
<p>win中函数库的调用和实际的系统调用几乎是不对应的。</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600174669528.png" alt="1600174669528"></p>
<p>windows中没有类似UNIX中的进程层次，不存在父进程和子进程的概念。</p>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><p>内核态以单一程序的方式运行</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216350126.png" alt="1600216350126"></p>
<p>除了核心操作系统外，操作系统还支持扩展：I/O设备驱动和文件系统。UNIX中叫做<strong>共享库（shared library）</strong>，windows中叫做**动态链接库（Dynamic Link Library，DLL）</p>
<h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>使用层来分隔不同的功能单元，每一层只与该层的上层和下层通信。上层软件都是在下层软件的基础之上构建的。</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216585570.png" alt="1600216585570"></p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600216594038.png" alt="1600216594038"></p>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>在分层方式中，确定哪里划分内核-用户的分界。</p>
<p>MINIX3</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217029845.png" alt="1600217029845"></p>
<p>微内核中机制与策略分离，内核均值寻找最高的优先级进程并运行，策略（赋予进程优先级）可以在用户态中的进程完成。</p>
<h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><p>当策略将进程分为两大类：服务器（提供服务）和客户端（使用服务）——客户-服务模式。</p>
<h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600217767997.png" alt="1600217767997"></p>
<h3 id="进程-1"><a href="#进程-1" class="headerlink" title="进程"></a>进程</h3><p>进程是对正在运行中的程序的一个抽象。一般包括一个地址空间和一个控制线程。</p>
<p>即使CPU只有一个，也支持（伪）并发操作（将单独的CPU抽象为多个虚拟机的CPU）</p>
<p>伪并行（pseudoparallelism）：单核或多核处理器同时执行多个进程，从而使程序更快，通过以非常有限的时间间隔在程序之间快速切换CPU产生并行感。</p>
<h4 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h4><p>进程包括：程序计数器，寄存器，变量当前值。</p>
<h4 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h4><ul>
<li><p>系统初始化（init）: 启动阶段穿件进程</p>
<blockquote>
<p>前台进程（numerous process）：同用户进行交互并完成工作</p>
<p>守护进程（daemons）：运行在后台，不与特定用户进行交互</p>
</blockquote>
</li>
<li><p>正在运行的程序执行了创建进程的系统调用（fork）</p>
<blockquote>
<p>​</p>
</blockquote>
</li>
<li><p>用户请求创建新进程</p>
<blockquote>
<p>交互式系统中，输入命令或者双击启动程序</p>
</blockquote>
</li>
<li><p>初始化一个批处理工作</p>
<blockquote>
<p>大型机的批处理系统</p>
<p>在UNIX中，系统调用(fork)后，创建一个与调用进程相关的副本，子进程有何父进程相同的内存映像，环境字符创和打开文件，子进程执行<code>execve</code>或者简单的系统调用来改变内存映像并运行一个新程序。</p>
<p>例如 shell中输入sort命令，shell会fork一个子进程，然后执行sort命令</p>
<p>Win32中，<code>CreateProcess</code>处理流程创建并将正确的程序加载到新的进程中。</p>
</blockquote>
</li>
</ul>
<h4 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h4><ul>
<li><p>正常退出(自愿)</p>
<blockquote>
<p>编译器完成给定程序的编译后，编译器执行一个系统调用告诉操作系统完成了工作</p>
<p>UNIX：<code>exit</code>  Windows: <code>ExitProcess</code></p>
<p>界面化的软件有可以点击关闭的按钮，用来通知进程删除其打开的临时文件，然后终止。</p>
</blockquote>
</li>
<li><p>错误退出(自愿)</p>
<blockquote>
<p>发出声明，给出错误参数，并退出</p>
<p>面向屏幕的交互式进程通常并不会直接退出</p>
</blockquote>
</li>
<li><p>严重错误（非自愿）</p>
<blockquote>
<p>进程引起的错误，通常由于程序中的错误导致，UNIX中，进程会受到信号（中断）</p>
<p>例如，执行一条非法指令，引用不存在的内存，或者除数为0</p>
</blockquote>
</li>
<li><p>被其他进程杀死（非自愿）</p>
<blockquote>
<p>UNIX kill；Win32中TerminateProcess</p>
</blockquote>
</li>
</ul>
<h4 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h4><ul>
<li><p>UNIX</p>
<p>进程和其所有子进程以及子进程的子进程共同组成一个进程组。</p>
</li>
<li><p>Windows</p>
<p>没有进程层次的概念。父进程可以得到一个特别的令牌（句柄），用来控制子进程，但该令牌可以移交给别的操作系统。UNIX中不能剥夺其子进程的进程权。</p>
</li>
</ul>
<h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>
<p>当grep就绪，但输入进程还没能完成时，必须阻塞grep进程，直到输入完毕。</p>
<p><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600220979244.png" alt="1600220979244"></p>
<ul>
<li>运行态：进程实际占用CPU时间片</li>
<li>就绪态：可运行，但因其他进程正在运行而处于就绪状态</li>
<li>阻塞态：除非某种外部时间发生，否则进程不能运行</li>
</ul>
<p>程序调度：决定哪个进程优先被运行和运行多久。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600225430669.png" class width="1600225430669">
<p>顺序进程（sequential process）</p>
<p>操作系统最底层是调度程序（中断和调度处理），之上是顺序进程。</p>
<h4 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h4><p><code>进程表</code></p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600233868365.png" class width="1600233868365">
<p>中断向量</p>
<ol>
<li>硬件压入堆栈程序计数器等</li>
<li>硬件从中断向量装入新的程序计数器</li>
<li>汇编语言过程保存寄存器的值</li>
<li>汇编语言过程设置新的堆栈</li>
<li>C中断服务器运行</li>
<li>调度器决定接下来那个程序先运行</li>
<li>C过程返回汇编代码</li>
<li>汇编语言过程开始运行新的当前进程</li>
</ol>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>在许多情况下，经常存在同一个地址空间中运行多个控制线程的情形，这些线程就像是分离的进程。</p>
<h4 id="线程的使用"><a href="#线程的使用" class="headerlink" title="线程的使用"></a>线程的使用</h4><div class="table-container">
<table>
<thead>
<tr>
<th>线程</th>
<th>进程</th>
</tr>
</thead>
<tbody>
<tr>
<td>多线程可以共享一块地址空间和所有可用数据</td>
<td></td>
</tr>
<tr>
<td>更轻量级，比进程更容易创建，撤销，创建一个线程比创建一个进程快10-100倍</td>
<td></td>
</tr>
<tr>
<td>性能方面：如果多个线程都是CPU密集型的，则不能获得性能上的增强，吐过存在大量的计算和大量I/O处理，多线程可以重叠进行，加快应用程序的执行速度。</td>
</tr>
</tbody>
</table>
</div>
<h5 id="多线程解决方案"><a href="#多线程解决方案" class="headerlink" title="多线程解决方案"></a>多线程解决方案</h5><p>一个多线程的web服务器</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600234612151.png" class width="1600234612151">
<p>调度线程的大致逻辑：一个的循环获得工作请求，并将请求派给工作线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">get_next_request(&amp;buf);</span><br><span class="line">handoff_work(&amp;buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>工作线程的大致逻辑：在告诉缓存中查找页面，若无，从web服务器（磁盘中）获得页面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">wait_for_work(&amp;buf);</span><br><span class="line">look_for_page_in_cache(&amp;buf,&amp;page);</span><br><span class="line"><span class="keyword">if</span>(page_not_in_cache(&amp;page))&#123;</span><br><span class="line">read_page_from_disk(&amp;buf,&amp;page);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> _page(&amp;page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="单线程解决方案"><a href="#单线程解决方案" class="headerlink" title="单线程解决方案"></a>单线程解决方案</h5><p>web服务器通过主循环获取请求并检查请求，争取在下一个请求之前完成工作，在等待磁盘操作时，服务器空转，不处理任何其他请求。</p>
<h5 id="状态机解决方案"><a href="#状态机解决方案" class="headerlink" title="状态机解决方案"></a>状态机解决方案</h5><p>并行，非阻塞系统调用，中断</p>
<p>有限状态机</p>
<h4 id="经典的线程模型"><a href="#经典的线程模型" class="headerlink" title="经典的线程模型"></a>经典的线程模型</h4><p>线程有程序计数器（记录下一条执行指令）和寄存器（保存线程当前正在使用的变量）以及堆栈（记录程序的执行路径）。</p>
<p>线程具有一些进程的属性，被称为<code>轻量的进程</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>线程</th>
<th>进程</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于把资源集中在一起</td>
<td>CPU上调度执行的实体</td>
</tr>
<tr>
<td>多个线程共享同一地址空间和其他资源，每个线程都可以访问进程地址空间内每个内存地址，因此一个线程可以读取、写入甚至擦除另一个线程的堆栈</td>
<td>多进程共享物理内存，磁盘，打印机和其他资源。</td>
</tr>
</tbody>
</table>
</div>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600237514736.png" class width="1600237514736">
<p>线程通常会被阻塞，直到它等待某个外部事件的发生或者有其他线程来释放它。</p>
<h4 id="线程系统调用"><a href="#线程系统调用" class="headerlink" title="线程系统调用"></a>线程系统调用</h4><p><code>thread_create</code>：创建</p>
<p><code>thread_exit</code>：退出</p>
<p><code>thread_join</code>：阻塞调用线程直到等待特定的线程退出</p>
<p><code>thread_yield</code>：允许线程自动放弃CPU从而让另一线程运行</p>
<h4 id="POSIX线程（pthreads）"><a href="#POSIX线程（pthreads）" class="headerlink" title="POSIX线程（pthreads）"></a>POSIX线程（pthreads）</h4><p>一种独立于语言而存在的执行模型，以及并行执行模型。</p>
<p><code>pthread_create</code>创建新线程，返回新线程的标识符，起着PID的作用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUMBER_OF_THREADS 10</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">print_hello_world</span><span class="params">(vvoid *tid)</span></span>&#123;</span><br><span class="line"><span class="comment">/* 输出线程标识符 */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Hello World. Greetings from thread %d\n"</span>,tid);</span><br><span class="line">pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span></span>&#123;</span><br><span class="line"><span class="comment">/* 主程序创建10个线程，然后退出 */</span></span><br><span class="line"><span class="keyword">pthread_t</span> threads[NUMBER_OF_THREADS];</span><br><span class="line"><span class="keyword">int</span> status,i;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NUMBER_OF_THREADS;i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Main here. Creating thread %d\n"</span>,i);</span><br><span class="line">status = pthread_create(&amp;threads[i], <span class="literal">NULL</span>, print_hello_world, (<span class="keyword">void</span> *)i);</span><br><span class="line"><span class="keyword">if</span>(status != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Oops. pthread_create returned error code %d\n"</span>,status);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exit</span>(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h4><h5 id="在用户空间实现"><a href="#在用户空间实现" class="headerlink" title="在用户空间实现"></a>在用户空间实现</h5><p>内核对线程一无所知</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240126229.png" class width="1600240126229">
<p>运行时系统（runtime system）也叫作运行时环境。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>优势</th>
<th>劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程调度便捷，效率高：不需要切换到内核，也不需要上下文切换，不需要对内存高速缓存进行刷新</td>
<td>使用线程的一个目标是能都让线程进行阻塞调用，避免被阻塞的线程影响其他线程。</td>
</tr>
<tr>
<td>允许每个进程有自己定制的调度算法</td>
<td>程序调用不在内存的指令时，会发生页面故障，OS将到磁盘上取回这个丢失的指令，该阶段整个进程会被阻塞。（如果是由一个线程引起的，也会整个阻塞）</td>
</tr>
<tr>
<td>较好的可扩展性</td>
<td>再一个单进程内部，没有时钟中断，不能使用轮转调度的方式调度线程</td>
</tr>
</tbody>
</table>
</div>
<h5 id="在内核空间实现"><a href="#在内核空间实现" class="headerlink" title="在内核空间实现"></a>在内核空间实现</h5><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240676849.png" class width="1600240676849">
<p>当一个线程阻塞时，内核可以选择是运行同一个进程中的线程还是运行另一个进程中的线程。</p>
<p>内核中线程的创建和销毁开销大，某些系统通过可循环利用的方式回收线程：线程销毁时，标记不可运行状态，但内部结构没有影响。在创建新线程时，启用就线程，标记为可用状态。</p>
<h5 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h5><p>内核级线程：将用户级线程与内核线程多路复用</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600240942918.png" class width="1600240942918">
<h3 id="进程间通信（inter-process-communication）"><a href="#进程间通信（inter-process-communication）" class="headerlink" title="进程间通信（inter process communication）"></a>进程间通信（inter process communication）</h3><p>竞态条件（race condition）：两个或多个线程同时对一共享数据进行修改，影响程序运行的正确性。</p>
<p>互斥操作（mutual exclusion）：禁止两个或多个进程在同一时刻对共享资源进行读写。</p>
<p>临界区（critical section）或临界区域（critical region）：对共享内存进行访问的程序片段。</p>
<h4 id="临界互斥："><a href="#临界互斥：" class="headerlink" title="临界互斥："></a>临界互斥：</h4><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600241408214.png" class width="1600241408214">
<h4 id="忙等互斥-（都是忙等待）"><a href="#忙等互斥-（都是忙等待）" class="headerlink" title="忙等互斥 （都是忙等待）"></a>忙等互斥 （都是忙等待）</h4><p>当一个进程正忙于更新其关键区域的共享内存时，没有其他进程会进入其关键区域</p>
<h5 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h5><p>让每个进程在进入临界区后屏蔽所有中断，离开临界区域之前重启它们。</p>
<h5 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h5><p>软件层面解决方案：单个共享的锁变量，初始值为零。一个线程想进入关键区域时，先检查锁的值是否为0，若为零，设为1，进入关键区域，若为1，等待变量变为0.</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600246506593.png" class width="1600246506593">
<h5 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h5><p>抛出一段代码，进程0的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">turn</span> = <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="comment">/* 进入关键区域 */</span></span><br><span class="line">      critical_region();</span><br><span class="line">      <span class="built_in">turn</span> = <span class="number">1</span>;</span><br><span class="line">       <span class="comment">/* 离开关键区域 */</span></span><br><span class="line">       noncritical_region();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进程1的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">turn</span> = <span class="number">1</span>)&#123;</span><br><span class="line">   critical_region();</span><br><span class="line">   <span class="built_in">turn</span> = <span class="number">0</span>;</span><br><span class="line">   noncritical_region();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>忙等待：</strong>连续检查一个变量直到出现某个值</p>
<p><strong>自旋锁</strong>：用于忙等待的锁</p>
<p>当一个进程比另一个进程执行速度慢很多的情况下，轮流进入临界区并不是一个好方法。</p>
<h5 id="Peterson解法"><a href="#Peterson解法" class="headerlink" title="Peterson解法"></a>Peterson解法</h5><p>将锁变量和警告变量相结合，一个不需要严格轮换的软件互斥算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FALSE 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TRUE 1</span></span><br><span class="line"><span class="comment">/* 进程数量 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 2</span></span><br><span class="line"><span class="comment">/* 现在轮到谁 */</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">turn</span>;</span><br><span class="line"><span class="comment">/* 所有值初始化为 0 (FALSE) */</span></span><br><span class="line"><span class="keyword">int</span> interested[N];</span><br><span class="line"><span class="comment">/* 进程是0 或 1 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">enter_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 另一个进程号 */</span></span><br><span class="line">   <span class="keyword">int</span> other;</span><br><span class="line">   <span class="comment">/* 另一个进程 */</span></span><br><span class="line">   other = <span class="number">1</span> - <span class="built_in">process</span>;</span><br><span class="line">   <span class="comment">/* 表示愿意进入临界区 */</span></span><br><span class="line">   interested[<span class="built_in">process</span>] = TRUE;</span><br><span class="line">   <span class="built_in">turn</span> = <span class="built_in">process</span>;</span><br><span class="line">   <span class="comment">/* 空循环 */</span></span><br><span class="line">   <span class="keyword">while</span>(<span class="built_in">turn</span> == <span class="built_in">process</span></span><br><span class="line">        &amp;&amp; interested[other] == <span class="literal">true</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">leave_region</span><span class="params">(<span class="keyword">int</span> <span class="built_in">process</span>)</span></span>&#123;</span><br><span class="line">   <span class="comment">/* 表示离开临界区 */</span></span><br><span class="line">   interested[<span class="built_in">process</span>] == FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="TSL指令"><a href="#TSL指令" class="headerlink" title="TSL指令"></a>TSL指令</h5><p>需要硬件帮助，<code>TSL RX,LOCK</code>称为<strong>测试并加锁（test and set lock）</strong></p>
<p>锁住总线，比禁用中断好，原因：禁用中断不能保证另一个处理器对内存的读写。</p>
<h4 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h4><p>忙等待浪费CPU时间，还可能引起<strong>优先级反转问题（orioruty inversion problem）</strong></p>
<p>实现方式<strong>监听</strong></p>
<p>问题：唤醒尚未进行睡眠状态的进程会导致唤醒丢失</p>
<p><strong>唤醒等待位</strong></p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>用一个整型变量累计唤醒次数。</p>
<h4 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h4><p>mutex：信号量的简单版本</p>
<p>futex:快速用户空间互斥（fast user space mutex）</p>
<blockquote>
<p>分为内核服务和用户库两部分</p>
<p>内核服务提供了一个等待队列（wait queue）允许多个进程在锁上排队等待。</p>
</blockquote>
<p>Pthreads也有互斥量机制，还有第二种同步机制：条件变量</p>
<h4 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h4><p>管程：monitor：程序，变量和数据结构等组成的一个集合，组成一个特殊的模块或者包。</p>
<p>特性：在任何时候管程中只能有一个活跃的进程</p>
<p>管道语言需要编译器识别管道并用某种方式对其互斥做出保证。</p>
<h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p>send和receive</p>
<p>对发送者，需要判断消息有没有本网络丢失。</p>
<p>对于接受者来说，如何区分新的消息和一条重发的老消息很重要，通常会在每条原始消息中嵌入一个连续的序号。还需要身份验证，是不是真正的文件服务器通信。</p>
<h4 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h4><p>屏障用来实现一组进程同步：当一个进程到达屏障时，会被屏障所拦截，直到所有的屏障都达到为止。</p>
<h4 id="避免锁"><a href="#避免锁" class="headerlink" title="避免锁"></a>避免锁</h4><p>读-复制-更新（ready-copy-update，RCU）</p>
<p>确保每个读操作要么读取旧的版本，要么读取新的版本</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>调度程序&amp;调度算法</p>
<h4 id="调度介绍"><a href="#调度介绍" class="headerlink" title="调度介绍"></a>调度介绍</h4><p>大型机：批处理+分时服务</p>
<h5 id="进程行为"><a href="#进程行为" class="headerlink" title="进程行为"></a>进程行为</h5><p>进程中，I/O请求和计算时交替进行的</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600259991563.png" class width="1600259991563">
<p>a：CPU密集型        b：I/O密集型</p>
<p>随着CPU速度越来越快，更多进程倾向于I/O密集型</p>
<p><strong>空闲进程（system-supplied idle process）</strong>：在系统没有处理其他线程时占据处理器时间，并不是一个真正的进程，是核心虚拟出来的。代表CPU的空闲状态。</p>
<h5 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h5><p>非抢占式（nonpreemprtive）：直到该进程被阻塞，或者直到该进程自动释放CPU。不会被强制挂起，并且如果没有更高优先级的进程等待，责备中断的进程会继续执行</p>
<p>抢占式：有最大固定时间，需要在时间间隔结束时发起时钟中断。</p>
<ol>
<li>批处理环境下：一般非抢占式或者周期长的抢占式，减少线程切换，提升性能</li>
<li>交互式环境下：抢占式（包括服务器）</li>
<li>实时环境下：</li>
</ol>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600260741139.png" class width="1600260741139">
<h4 id="批处理中的调度"><a href="#批处理中的调度" class="headerlink" title="批处理中的调度"></a>批处理中的调度</h4><p>先来先服务（first-come，first-serverd），缺点没有优先级</p>
<p>最短作业优先（Shortest job first）</p>
<p>最短剩余时间优先（shortest remaining time next）：新作业到达时，同当前进程的剩余时间做比较，如果新的进程比当前短，当前进程被挂起，运行新的进程。</p>
<h4 id="交互式系统中的调度"><a href="#交互式系统中的调度" class="headerlink" title="交互式系统中的调度"></a>交互式系统中的调度</h4><p>个人计算机&amp;服务器</p>
<h5 id="轮询调度"><a href="#轮询调度" class="headerlink" title="轮询调度"></a>轮询调度</h5><p>时间片(quantum)，调度程序维护一个可运行进程的列表。</p>
<p>进程间切换（process switch）和上下文切换（context switch）：将其设置太短会导致过多的进程切换降低CPU效率；太长会导致一个短请求很长时间得不到相应。（一般20-50 ms）</p>
<h5 id="优先级调度"><a href="#优先级调度" class="headerlink" title="优先级调度"></a>优先级调度</h5><p>动态或静态分配优先级，调度程序会在每个时钟中断期间降低当前运行进程的优先级。或者分配允许运行的最大时间间隔。</p>
<h5 id="多级队列"><a href="#多级队列" class="headerlink" title="多级队列"></a>多级队列</h5><p>CTSS(compatible timesharing system）兼容分时系统</p>
<h5 id="最短进程优先"><a href="#最短进程优先" class="headerlink" title="最短进程优先"></a>最短进程优先</h5><p>根据进程过去的行为推测，并执行估计运行时间最短的那一个。</p>
<p><code>a*T0+(1-a)T1</code> a决定了老化（aging）的速度。</p>
<h5 id="保证调度"><a href="#保证调度" class="headerlink" title="保证调度"></a>保证调度</h5><p>对进程做出明确的性能保证，n个进程，所有进程等价，每个进程获得1/n的CPU时间</p>
<h5 id="彩票调度"><a href="#彩票调度" class="headerlink" title="彩票调度"></a>彩票调度</h5><p>lottery scheduling：将资源作为彩票抽奖，抽中得到CPU时间</p>
<p>进程之间可以通过交换票据协作。</p>
<h5 id="公平分享调度"><a href="#公平分享调度" class="headerlink" title="公平分享调度"></a>公平分享调度</h5><p>用户1:9个进程，用户2:1个进程，这是轮转或者相同优先级调度算法不合适</p>
<p>每个用户都分配一些CPU时间</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262207567.png" class width="1600262207567">
<h4 id="实时系统中的调度"><a href="#实时系统中的调度" class="headerlink" title="实时系统中的调度"></a>实时系统中的调度</h4><p>硬实时：必须满足绝对的截止时间</p>
<p>软实时：可以容忍偶尔错失截止时间</p>
<p>周期性事件：</p>
<p>非周期性事件：</p>
<h4 id="调度策略和机制"><a href="#调度策略和机制" class="headerlink" title="调度策略和机制"></a>调度策略和机制</h4><p>有一种情况：一个进程中有多个子进程（数据库管理系统进程）</p>
<p>分为调度机制（scheduling mechanism）+ 调度策略（scheduling policy），参数化，但参数可以被用户填写。调度机制位于内核，调度策略由用户决定。</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>用户级线程：内核不能感受线程，选择一个进程，线程不会影响其他进程，时钟中断也不能中断线程</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262739859.png" class width="1600262739859">
<p>内核级线程：内核不考虑线程属于哪个进程</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262824458.png" class width="1600262824458">
<p>将进程A切换到进程B的消耗高于运行进程A的两个线程。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600262922944.png" class width="1600262922944">
<p>分层存储体系</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600327716389.png" class width="1600327716389">
<p>操作系统中管理内存层次结构的部分<code>内存管理器（memory manager）</code></p>
<h3 id="无存储器抽象"><a href="#无存储器抽象" class="headerlink" title="无存储器抽象"></a>无存储器抽象</h3><p>每个程序直接访问物理内存，通过多线程并行（多线程可以共享同一内存映像）。</p>
<p>缺点：1. 很容易破坏操作系统 2. 很难运行多个程序</p>
<h3 id="一种存储器抽象：地址空间"><a href="#一种存储器抽象：地址空间" class="headerlink" title="一种存储器抽象：地址空间"></a>一种存储器抽象：地址空间</h3><p>保护和重定位。</p>
<p>保护密钥标记内存块</p>
<p>地址空间（the address space）：创建抽象内存供程序使用。是进程可以用来寻址内存的地址集。每个进程都有自己的地址空间。</p>
<h4 id="基址寄存器和变址寄存器"><a href="#基址寄存器和变址寄存器" class="headerlink" title="基址寄存器和变址寄存器"></a>基址寄存器和变址寄存器</h4><p>动态重定位：将每个进程的地址空间映射到物理内存的不同区域。</p>
<p>当一个程序运行时，程序的起始物理地址装载到基址寄存器中，程序的长度装载到变址寄存器中。</p>
<p>缺点：每次访问内存时，都会运行<code>ADD</code>和<code>CMP</code>运算，变慢</p>
<h4 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h4><p>交换技术：把一个进程完整调入内存，然后在内存中运行一段时间，再把它放回磁盘，空闲进程会存储在磁盘中。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600330767595.png" class width="1600330767595">
<p>交换会在内存中创建多个空闲区（hole），可以通过内存紧缩（memory compaction）合并成大的空闲区，但是耗费时间。</p>
<h5 id="段-segment"><a href="#段-segment" class="headerlink" title="段-segment"></a>段-segment</h5><p>代码段：文本段，存放指令，一般只读，空间大小在代码运行前已经确定。</p>
<p>数据段：存储初始化的全局变量和初始化的静态变量，生存期：随进程持续性。</p>
<p>bss段：可读可写，存储未初始化的全局变量和未初始化的静态变量，生存期：随进程持续性。</p>
<p>rodata段：只读数据</p>
<p>栈（stack）：可读可写，存储函数或代码中的局部变量，生存期随代码块持续性</p>
<p>堆（heap）：可读可写，存储程序运行期间动态分配的malloc/realloc，随进程持续性</p>
<p>有些区域会自动增长(针对单个或者一小部分需要增长的进程)：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600331216327.png" class width="1600331216327">
<p>若大部分进程都要在运行时增长，可以预先分配额外的内存。</p>
<h4 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h4><h5 id="位图（bitmap）"><a href="#位图（bitmap）" class="headerlink" title="位图（bitmap）"></a>位图（bitmap）</h5><p>内存被划分为一定大小的分配单元，对应位图中的一位，0—-空闲；1-占用。</p>
<p>缺点：当把具有k个分配单元的进程放入内存时，内容管理器必须搜索位图，在位图中找到能够运行k个连续0位的串，耗时。</p>
<h5 id="链表（segment-list）"><a href="#链表（segment-list）" class="headerlink" title="链表（segment list）"></a>链表（segment list）</h5><p>空闲区（H）进程（P）</p>
<p>段链表按照地址排序，进程终止或者交换时，更新列表很简单。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600331687285.png" class width="1600331687285">
<p>首次适配（first fit）：内存管理器沿着段列表扫描，直到知道一个足够大的空闲区。很快，但会拆分大的空闲区。</p>
<p>下次适配（next fit）：在每次找到合适的空闲区时，记录当前位置。（性能略低于首次适配）</p>
<p>最佳适配（best fit）：从头到尾寻找链表，找到能够容纳进程的最小空闲区。（产生很多小缓冲区）</p>
<p>最差适配（worst fit）：总分配最大的内存区域，</p>
<p>快速适配法（quick fit）：为常用大小的空闲区维护单独的链表。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>运行的程序往往大到内存无法容纳。大内存交换不现实，太慢。</p>
<p>虚拟内存：每个程序有自己的地址空间，被划分为多个页面（page），每一页都是连续的地址范围，被映射到物理内存，不需要所有页都在内存中才能运行程序。允许应用程序部分地运行在内存中。</p>
<h4 id="分页（paging）"><a href="#分页（paging）" class="headerlink" title="分页（paging）"></a>分页（paging）</h4><p>程序生成的地址被称为：虚拟地址，形成虚拟地址空间。在使用虚拟内存时，虚拟地址不会直接发送到内存总线上，会使用内存管理单元（MMU）吧虚拟地址映射为物理内存地址</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600332477587.png" class width="1600332477587">
<p>虚拟空间：页（pages）</p>
<p>物理内存：页框（page frames）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600332692103.png" class width="1600332692103">
<p>未映射的页标记X，OS会讲很少使用的页写入磁盘。</p>
<h4 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h4><p>蓝色为页表，在/不在位如果为0——缺页异常。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600333059233.png" class width="1600333059233">
<p>页表的结构：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600333186105.png" class width="1600333186105">
<p>修改位（也叫脏位）：如果页面被修改（脏的），需要写会磁盘，如果页面没有修改（干净），该页框会被丢弃，因为磁盘上的副本仍然有效。</p>
<h4 id="加速分页过程"><a href="#加速分页过程" class="headerlink" title="加速分页过程"></a>加速分页过程</h4><p>如果页的大小为4KB，32位的地址空间将有100万页，而64位地址空间会更多。</p>
<h5 id="转换检测缓冲区（translation-lookaside-buffer，TLB）"><a href="#转换检测缓冲区（translation-lookaside-buffer，TLB）" class="headerlink" title="转换检测缓冲区（translation lookaside buffer，TLB）"></a>转换检测缓冲区（translation lookaside buffer，TLB）</h5><p>大多数程序对少量的页面进行多次访问。在TLB中的PTE（page table entry 页表项）可以不访问内存。</p>
<p>精简指令集（RISC），使计算机的微处理器的每条指令（CPI）周期比复杂指令计算机（CISC）少。</p>
<p>软失效：页在内存中而不在TLB中</p>
<p>硬失效：页不在内存中，需要页表遍历（page table walk）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600334025618.png" class width="1600334025618">
<h4 id="针对大内存的页表"><a href="#针对大内存的页表" class="headerlink" title="针对大内存的页表"></a>针对大内存的页表</h4><h5 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h5><p>避免把全部页表保存在内存中。</p>
<p>32位的地址被划分为PT1,PT2和offset</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600337115639.png" class width="1600337115639">
<p>顶级页表：1024个表项，对应于10位的PT1域。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600337144675.png" class width="1600337144675">
<h5 id="倒排页表"><a href="#倒排页表" class="headerlink" title="倒排页表"></a>倒排页表</h5><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><p>发生缺页异常时，操作系统会选择一个页面进行换出为新的页面腾出空间。</p>
<h4 id="最优页面置换算法"><a href="#最优页面置换算法" class="headerlink" title="最优页面置换算法"></a>最优页面置换算法</h4><p>标记最大的页面</p>
<h4 id="最近未使用（NRU）页面置换算法"><a href="#最近未使用（NRU）页面置换算法" class="headerlink" title="最近未使用（NRU）页面置换算法"></a>最近未使用（NRU）页面置换算法</h4><p>在一个时钟内（约20ms）淘汰一个已修改但是没有北方味的页面比一个大量引用的未修改页面好。</p>
<h4 id="先进先出（FIFO）页面置换法"><a href="#先进先出（FIFO）页面置换法" class="headerlink" title="先进先出（FIFO）页面置换法"></a>先进先出（FIFO）页面置换法</h4><p>操作系统维护一个所有在当前内存中的页面的链表，最早进入的放在表头，最新进入的页面放在表尾。发生缺页异常时，将头部的页移除并把新的页添加到表尾。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600338063467.png" class width="1600338063467">
<p>bug：出链和入链不会进行check，会把经常使用的页面置换出去。（<strong>可能会抛弃重要界面</strong>）</p>
<h4 id="第二次机会页面置换法"><a href="#第二次机会页面置换法" class="headerlink" title="第二次机会页面置换法"></a>第二次机会页面置换法</h4><p>检查页面R位，</p>
<p>缺点：需要经常在链表中移动页面，降低了效率。</p>
<h4 id="时钟页面置换算法（实际使用）"><a href="#时钟页面置换算法（实际使用）" class="headerlink" title="时钟页面置换算法（实际使用）"></a>时钟页面置换算法（实际使用）</h4><p>把所有的页面都保存在一个类似钟面的环形链表中，一个指针指向最老的页面。</p>
<h4 id="最近最少使用（LRU）页面置换算法"><a href="#最近最少使用（LRU）页面置换算法" class="headerlink" title="最近最少使用（LRU）页面置换算法"></a>最近最少使用（LRU）页面置换算法</h4><p>在缺页中断时，置换未使用时间最长的页面。（LRU（Least Recently Used））</p>
<h4 id="工作集页面置换法"><a href="#工作集页面置换法" class="headerlink" title="工作集页面置换法"></a>工作集页面置换法</h4><p>一个进程当前正在使用的页面的集合称为它的<strong>工作集（working set）</strong></p>
<h4 id="工作集时钟页面置换法"><a href="#工作集时钟页面置换法" class="headerlink" title="工作集时钟页面置换法"></a>工作集时钟页面置换法</h4><p>对基本工作集算法的提升是基于时钟算法但是却使用工作集的信息——WSClock（工作集时钟）</p>
<p>发生缺页异常时，首先检查指针指向的页面，如果R为被设置为1，说明页面在当前时钟周期内被使用过，该页面不该被淘汰，并把该页面的R位置设为0，指针指向下一个页面，并重复。</p>
<p>如果R=0，页面使用期限大于t，并且被访问过，磁盘上有此页面的副本，需要更新。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600349120853.png" class width="1600349120853">
<p>文件是由进程创建的逻辑信息单元。可以把每个文件都看作一个独立的地址空间。</p>
<p>操作系统中处理文件的部分称为<strong>文件系统（file system）</strong></p>
<h3 id="文件-1"><a href="#文件-1" class="headerlink" title="文件"></a>文件</h3><h4 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h4><p>UNIX文件名区分大小写，MS-DOS不区分。</p>
<p>文件系统FAT-16,FAT-32，NTFS，exFAT</p>
<p>文件名，文件扩展名：UNIX系统不前置采用文件扩展名，并且可以有多个文件扩展名；Windows用户（或进程）可以在操作系统中注册扩展名，双击时，拥有给文件名的程序就启动并运行文件。</p>
<h4 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h4><p>字节序列</p>
<p>记录序列：文件是有固定长度记录的序列，每个记录有其内部结构。读操作返回一个记录，而写操作重写或者追加一个记录。</p>
<p>树</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600350074121.png" class width="1600350074121">
<h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p>字符特殊文件 ：和串行I/O设备有关</p>
<p>块特殊文件：用于磁盘类设备</p>
<p>常规文件：可执行文件，文本文件，图像文件。</p>
<p>常规文件：ASCII码和二进制文件。</p>
<p>行用回车符结束（ASCII码 13，控制字符CR，转义字符\r），或者换行符（ASCII码 10，控制字符LF，转义字符\n），windows二者都用。</p>
<p>ASCII码文件：显示和打印</p>
<p>二进制文件：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600350829224.png" class width="1600350829224">
<h4 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h4><p>顺序访问</p>
<p>随机访问文件（read从头读取，seek操作当前位置）</p>
<h4 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h4><p>属性（attributes）也称作元数据（metadata）</p>
<p>属性有两种状态：设置（set）和清除（clear）</p>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>目录（directories）和文件夹（folders）</p>
<h4 id="一级目录系统"><a href="#一级目录系统" class="headerlink" title="一级目录系统"></a>一级目录系统</h4><p>有一个能够包含所有文件的目录——根目录。一般用于嵌入式设备。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600351378026.png" class width="1600351378026">
<h4 id="层次目录系统"><a href="#层次目录系统" class="headerlink" title="层次目录系统"></a>层次目录系统</h4><h4 id="路径名"><a href="#路径名" class="headerlink" title="路径名"></a>路径名</h4><p>绝对路径名：第一个字符是分隔符</p>
<p>相对路径名：和工作目录（当前目录）一起使用。</p>
<h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><p>创建，删除，读取，关闭，重命名，链接link</p>
<h3 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h3><h4 id="文件系统布局"><a href="#文件系统布局" class="headerlink" title="文件系统布局"></a>文件系统布局</h4><p>磁盘分区（disk partitioning）或者磁盘分片（disk slicing）</p>
<p>磁盘号为0：主引导记录（master boot record，MBR），用来引导（BOOT）计算机</p>
<p>MBR结尾是分区表（partition table）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600351821747.png" class width="1600351821747">
<h5 id="引导块"><a href="#引导块" class="headerlink" title="引导块"></a>引导块</h5><p>MBR确定活动分区，读入其第一个块（引导块，boot block），引导块中的程序加载分区中的操作系统。4096字节</p>
<h5 id="超级块"><a href="#超级块" class="headerlink" title="超级块"></a>超级块</h5><p>4096字节，包含文件系统的所有关键参数：</p>
<ul>
<li>文件系统的大小</li>
<li>文件系统中的数据块数</li>
<li>指示文件系统状态的标志</li>
<li>分配组大小</li>
</ul>
<h5 id="空闲空间块"><a href="#空闲空间块" class="headerlink" title="空闲空间块"></a>空闲空间块</h5><p>位图和链表</p>
<h5 id="碎片（fragment）"><a href="#碎片（fragment）" class="headerlink" title="碎片（fragment）"></a>碎片（fragment）</h5><p>零散的单个数据</p>
<h5 id="inode"><a href="#inode" class="headerlink" title="inode"></a>inode</h5><p>索引节点（index node），一个数组结构，存储对象数据的属性和磁盘块位置。</p>
<p>包含：</p>
<ul>
<li>权限</li>
<li>所有者ID</li>
<li>组ID</li>
<li>文件大小</li>
<li>文件硬链接数</li>
<li>上次访问时间</li>
<li>最后修改时间</li>
<li>inode上次修改时间</li>
</ul>
<h4 id="文件的实现"><a href="#文件的实现" class="headerlink" title="文件的实现"></a>文件的实现</h4><p>文件两部分：索引节点+块；需要记录各个文件分别使用了哪些磁盘块，背后思想：有效可利用文件空间和快速访问文件。</p>
<h5 id="连续分配"><a href="#连续分配" class="headerlink" title="连续分配"></a>连续分配</h5><p>优点：实现简单，高性能</p>
<ul>
<li>简单：只需记忆第一个块的文件地址和文件的块数量</li>
<li>读取性强</li>
</ul>
<p>缺点：磁盘会变得零碎（当删除文件后）</p>
<p>CD-ROM（只读光盘）</p>
<h5 id="链表分配"><a href="#链表分配" class="headerlink" title="链表分配"></a>链表分配</h5><p>为每个文件构造磁盘块链表，每个文件都是磁盘块的链接列表。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600352565654.png" class width="1600352565654">
<p>缺点：</p>
<ul>
<li>指针会占用一些字节</li>
<li>随机访问比较困难</li>
</ul>
<h5 id="使用内存表进行链表分配"><a href="#使用内存表进行链表分配" class="headerlink" title="使用内存表进行链表分配"></a>使用内存表进行链表分配</h5><p>将磁盘块的指针放在内存的一个表中。文件分配表（File Application Table，FAT）</p>
<p>缺点：必须把整个链表放在内存中</p>
<h5 id="inode-1"><a href="#inode-1" class="headerlink" title="inode"></a>inode</h5><p>给每个文件赋予一个索引节点。</p>
<p>链表的表的大小和磁盘本省成正比，如果磁盘有n个快，表也需要n项，线性增长。</p>
<p>inode需要节点中的数组，大小与可能打开的最大文件个数成正比。</p>
<p>NTFS（new technology File system）</p>
<h4 id="目录的实现"><a href="#目录的实现" class="headerlink" title="目录的实现"></a>目录的实现</h4><p>哈希表（也叫散列表）：提高文件检索效率。管理复杂。</p>
<p>缓存：</p>
<h4 id="共享文件"><a href="#共享文件" class="headerlink" title="共享文件"></a>共享文件</h4><p>图论中：一个有向图从任意顶点出发无法经过若干条边回到该点，则是一个有向无环图。</p>
<ol>
<li>仅仅将inode放在目录中，而不把磁盘块例如目录</li>
<li>符号链接</li>
</ol>
<h4 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h4><p>log-structured file system（LFS）主要解决：减少对硬盘的随机写操作。</p>
<h4 id="日志文件系统"><a href="#日志文件系统" class="headerlink" title="日志文件系统"></a>日志文件系统</h4><p>移除文件：</p>
<ul>
<li>在目录中删除文件</li>
<li>释放inode到空闲inode池</li>
<li>将所有磁盘块归还给空闲磁盘池</li>
</ul>
<p>原子事物</p>
<p>文件系统一致性检查（fsck）</p>
<h4 id="虚拟文件系统（Virtual-File-System，VFS-）"><a href="#虚拟文件系统（Virtual-File-System，VFS-）" class="headerlink" title="虚拟文件系统（Virtual File System，VFS ）"></a>虚拟文件系统（Virtual File System，VFS ）</h4><p>UNIX操作系统使用：将多种文件系统构成一个有序的结构。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600354302449.png" class width="1600354302449">
<h3 id="文件系统的管理和优化"><a href="#文件系统的管理和优化" class="headerlink" title="文件系统的管理和优化"></a>文件系统的管理和优化</h3><h4 id="磁盘空间管理"><a href="#磁盘空间管理" class="headerlink" title="磁盘空间管理"></a>磁盘空间管理</h4><p>两种策略：</p>
<ol>
<li><p>分配n个字节的连续磁盘空间</p>
</li>
<li><p>把文件拆分成多个并不连续的块</p>
<blockquote>
<p>块太大浪费空间，太小浪费时间</p>
<p>记录空间块：磁盘块链表（可以记录单个块，也可以连续分块），位图</p>
</blockquote>
</li>
</ol>
<p>存储管理系统：</p>
<ol>
<li>分段管理</li>
<li>分页管理</li>
</ol>
<h4 id="磁盘配额"><a href="#磁盘配额" class="headerlink" title="磁盘配额"></a>磁盘配额</h4><p>enforcing disk quotas：系统管理员为每个用户分配最大的文件和块分配。</p>
<p>软限制</p>
<p>硬限制</p>
<h4 id="文件备份系统"><a href="#文件备份系统" class="headerlink" title="文件备份系统"></a>文件备份系统</h4><ul>
<li>从意外的灾难中恢复</li>
<li>从错误的操作中恢复</li>
</ul>
<p>增量转储（incremental dumps）</p>
<h5 id="物理转储（physical-dump）："><a href="#物理转储（physical-dump）：" class="headerlink" title="物理转储（physical dump）："></a>物理转储（physical dump）：</h5><p>简单，快速，缺点：全量备份</p>
<h5 id="逻辑转储（logical-dump）："><a href="#逻辑转储（logical-dump）：" class="headerlink" title="逻辑转储（logical dump）："></a>逻辑转储（logical dump）：</h5><h4 id="文件系统的一致性"><a href="#文件系统的一致性" class="headerlink" title="文件系统的一致性"></a>文件系统的一致性</h4><p>检查文件系统的一致性：fsck（UNIX）和scf（Windows）</p>
<p>块的一致性检查和文件的一致性检查。</p>
<p>文件系统一致时：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391479702.png" class width="1600391479702">
<p>系统崩溃后：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391494196.png" class width="1600391494196">
<p>磁盘块2——块丢失（missing block）</p>
<h4 id="文件系统性能"><a href="#文件系统性能" class="headerlink" title="文件系统性能"></a>文件系统性能</h4><p>存储层次结构</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600391706575.png" class width="1600391706575">
<h5 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h5><p>块高速缓存（block cache）</p>
<p>缓冲区高速缓存（buffer cache）</p>
<h5 id="块提前读"><a href="#块提前读" class="headerlink" title="块提前读"></a>块提前读</h5><p>对于顺序读取的文件</p>
<h5 id="减少磁盘臂运动"><a href="#减少磁盘臂运动" class="headerlink" title="减少磁盘臂运动"></a>减少磁盘臂运动</h5><p>把有可能顺序访问的块放在一起（同柱面）</p>
<p>（寻道时间和旋转时间）</p>
<h5 id="磁盘碎片整理"><a href="#磁盘碎片整理" class="headerlink" title="磁盘碎片整理"></a>磁盘碎片整理</h5><p>windows：defrag</p>
<p>SSD不需要碎片整理</p>
<h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600392296985.png" class width="1600392296985">
<h3 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h3><p>输入/输出设备，能够像计算机发送数据，并从计算机接收数据。</p>
<h4 id="块设备（block-devices）"><a href="#块设备（block-devices）" class="headerlink" title="块设备（block devices）"></a>块设备（block devices）</h4><p>固定大小的块：硬盘，U盘</p>
<p>通常需要较少的引脚</p>
<p>缺点：需要在开头开始读取或写入</p>
<h4 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h4><p>以字符为单位发送或接受一个字符流，不可寻址</p>
<p>打印机，网络设备，鼠标等</p>
<h4 id="设备控制器"><a href="#设备控制器" class="headerlink" title="设备控制器"></a>设备控制器</h4><p>通过应用程序的借口与操作系统进行通信，把串行的位流转换成字节块，并进行必要的错误矫正工作。</p>
<p>I/O设备：机械组件和电子组件（设备控制器或者适配器，一般是可以插入PCIe扩展槽的主板上的芯片或印刷电路卡形成）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600392723432.png" class width="1600392723432">
<h4 id="内存映射I-O"><a href="#内存映射I-O" class="headerlink" title="内存映射I/O"></a>内存映射I/O</h4><p>在CPU与其连接的外围设备之间交换数据和指令的一种方式。</p>
<ul>
<li>数据缓冲区，设置I/O端口</li>
<li>PDP-11，处理器和IO设备共享同一内存位置的内存</li>
</ul>
<h4 id="直接内存访问（DMA）"><a href="#直接内存访问（DMA）" class="headerlink" title="直接内存访问（DMA）"></a>直接内存访问（DMA）</h4><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600397144597.png" class width="1600397144597">
<h4 id="精确中断和不精确中断"><a href="#精确中断和不精确中断" class="headerlink" title="精确中断和不精确中断"></a>精确中断和不精确中断</h4><p>PC（程序计数器）保存在一个已知的地方，PC之前指令已经完全执行，之后指令都没有执行，PC所指向的指令的执行状态已知。</p>
<h3 id="I-O软件原理"><a href="#I-O软件原理" class="headerlink" title="I/O软件原理"></a>I/O软件原理</h3><p>设备独立性</p>
<p>错误处理</p>
<p>同步和异步传输：大部分物理IO是异步的（物理IO从磁盘等存储设备实际获取数据，逻辑IO对存储器（块，缓冲区）获取数据）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600398022673.png" class width="1600398022673">
<p>缓冲</p>
<p>共享和独占</p>
<h4 id="使用程序控制IO"><a href="#使用程序控制IO" class="headerlink" title="使用程序控制IO"></a>使用程序控制IO</h4><p>可编程IO，由CPU在驱动程序软件控制下启动的数据传输来访问设备上的寄存器或者其他存储器。</p>
<p>CPU会轮询（polling）或者忙等（busy waiting）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600416897823.png" class width="1600416897823">
<h4 id="使用中断驱动"><a href="#使用中断驱动" class="headerlink" title="使用中断驱动"></a>使用中断驱动</h4><p>可以使CPU在等待IO设备的同时，能够做其他事情</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600416930613.png" class width="1600416930613">
<h4 id="使用DMA的IO"><a href="#使用DMA的IO" class="headerlink" title="使用DMA的IO"></a>使用DMA的IO</h4><p>CPU赋予IO模块权限在不涉及CPU的情况下读取或者写入内存。</p>
<h3 id="IO层次结构"><a href="#IO层次结构" class="headerlink" title="IO层次结构"></a>IO层次结构</h3><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600418399431.png" class width="1600418399431">
<h4 id="中断服务程序（Interrupt-service-routines-ISR"><a href="#中断服务程序（Interrupt-service-routines-ISR" class="headerlink" title="中断服务程序（Interrupt service routines,ISR)"></a>中断服务程序（Interrupt service routines,ISR)</h4><p>启动中断驱动程序解决阻塞，三种通知方式：</p>
<ol>
<li>信号量实现中</li>
<li>管道实现</li>
<li>发送消息</li>
</ol>
<p>嵌套中断：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600418767973.png" class width="1600418767973">
<h4 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h4><p>字符设备和块设备</p>
<p>功能：接收和识别命令，进行数据交换，地址识别，差错检测</p>
<h4 id="与设备无关的IO软件"><a href="#与设备无关的IO软件" class="headerlink" title="与设备无关的IO软件"></a>与设备无关的IO软件</h4><p>基本功能是对所有设备执行公共的IO功能，并且向用户层软件提供一个统一的接口。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419071897.png" class width="1600419071897">
<h5 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h5><p>双缓冲（duble buffering）</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419317010.png" class width="1600419317010">
<p>缓冲循环</p>
<h4 id="用户空间的IO软件"><a href="#用户空间的IO软件" class="headerlink" title="用户空间的IO软件"></a>用户空间的IO软件</h4><p>大部分IO软件在内核结构中，但有一些在用户空间。</p>
<h3 id="盘"><a href="#盘" class="headerlink" title="盘"></a>盘</h3><h4 id="盘硬件"><a href="#盘硬件" class="headerlink" title="盘硬件"></a>盘硬件</h4><p>磁盘 magnetic hard disks ， hard disk， HDD</p>
<p>随机访问，非易失性设备</p>
<p>重叠寻址：控制器控制两个或者多个驱动器进行磁盘寻址</p>
<h4 id="RAID"><a href="#RAID" class="headerlink" title="RAID"></a>RAID</h4><p>磁盘冗余阵列，简称磁盘阵列，使用虚拟化技术把多个硬盘结合在一起。</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419649541.png" class width="1600419649541">
<h4 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h4><p>扇区格式：</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419685650.png" class width="1600419685650">
<p>前导码：柱面好，扇区号等</p>
<p>数据大小由<strong>低级格式化程序</strong>控制，一般512字节</p>
<p>ECC。error correction code，数据纠错码，一般16位</p>
<p>0扇区位置和前一个磁道相比，有偏移——柱面斜进</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600419871957.png" class width="1600419871957">
<p><strong>高级格式化</strong></p>
<p>设置引导块，空闲存储管理（位图或者链表），根目录，空文件系统。</p>
<h4 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h4><ul>
<li>寻道时间（影响最大）</li>
<li>旋转延迟</li>
<li>实际数据的读取和写入</li>
</ul>
<p>FIFO</p>
<p>最短路径优先（SSF）</p>
<p>电梯算法：协调效率和公平性，保持一个方向移动，知道在该方向上没有请求为止，然后改变方向。</p>
<p>实际情况下，磁盘控制器会读取多个扇区并进行高速缓存</p>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>坏块的处理办法</p>
<ul>
<li>控制器：将备用扇区之一重新映射或者将所有的扇区都想上移动一个扇区</li>
<li>系统操作</li>
</ul>
<h4 id="稳定器存储"><a href="#稳定器存储" class="headerlink" title="稳定器存储"></a>稳定器存储</h4><ul>
<li>稳定写</li>
<li>稳定读</li>
<li>崩溃恢复：恢复程序扫描两个磁盘，比较对应的块，如果都是好的，并且相同，不触发任何机制；若其中一块触发了ECC错误，使用好块覆盖坏块</li>
</ul>
<h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>时钟（clocks）也被成为定时器（timers），负责维护时间，防止一个进程长期占用CPU时间等其他功能。</p>
<h4 id="时钟硬件"><a href="#时钟硬件" class="headerlink" title="时钟硬件"></a>时钟硬件</h4><ul>
<li><p>110V或者220V，美国电压周期差生一个中断</p>
</li>
<li><p>时钟晶体振荡器+计数器+寄存器（可编程时钟）</p>
<blockquote>
<p>一键式：时钟启动时，把存储器的值复制到计数器，每次晶体振荡器的脉冲，使计数器-1，计数器变为0时，产生一个中断。</p>
<p>方波模式，计数器变为0并产生中断后，存储寄存器的值会自动恢复到计数器中。</p>
</blockquote>
</li>
</ul>
<h4 id="时钟软件"><a href="#时钟软件" class="headerlink" title="时钟软件"></a>时钟软件</h4><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600420838617.png" class width="1600420838617">
<h4 id="软定时器"><a href="#软定时器" class="headerlink" title="软定时器"></a>软定时器</h4><p>可编程时钟，可以以程序需要的任何速率发生中断。</p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1600420953207.png" class width="1600420953207">
<p>计算机独占性的资源，一次只能由一个进程使用。（例如打印机）</p>
<h3 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h3><p>可抢占资源：可以从进程中抢占，不造成其他影响（如内存）</p>
<p><strong>不可抢占资源</strong>（和死锁有关）：除非引起错误或者异常，否则进程无法抢占指定资源（光盘等）</p>
<h4 id="资源获取"><a href="#资源获取" class="headerlink" title="资源获取"></a>资源获取</h4><p>数据库记录资源：<strong>信号量</strong>来管理（或者互斥锁）</p>
<h4 id="资源死锁"><a href="#资源死锁" class="headerlink" title="资源死锁"></a>资源死锁</h4><h4 id="死锁模型"><a href="#死锁模型" class="headerlink" title="死锁模型"></a>死锁模型</h4><img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200918190257435.png" class title="image-20200918190257435">
<p>四个条件：</p>
<ul>
<li>互斥</li>
<li>保持和等待</li>
<li>不可抢占</li>
<li>循环等待</li>
</ul>
<h4 id="鸵鸟算法"><a href="#鸵鸟算法" class="headerlink" title="鸵鸟算法"></a>鸵鸟算法</h4><p>忽略死锁带来的影响</p>
<h4 id="死锁的检测与恢复"><a href="#死锁的检测与恢复" class="headerlink" title="死锁的检测与恢复"></a>死锁的检测与恢复</h4><p>检测：基于矩阵</p>
<img src="/2020/09/15/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20200918191841473.png" class title="image-20200918191841473">
<ul>
<li>通过抢占恢复</li>
<li>回滚恢复</li>
<li>杀死进程恢复</li>
</ul>
<h4 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h4><ol>
<li>单个资源的银行家算法</li>
</ol>
<h4 id="破坏死锁"><a href="#破坏死锁" class="headerlink" title="破坏死锁"></a>破坏死锁</h4><p>破坏四个条件</p>
<ol>
<li><p>互斥</p>
<blockquote>
<p>假脱机打印机</p>
</blockquote>
</li>
<li><p>等待</p>
<blockquote>
<p>组织持有资源的进程请求其他资源</p>
</blockquote>
</li>
<li><p>不可抢占条件</p>
<blockquote>
<p>虚拟化</p>
</blockquote>
</li>
<li><p>循环等待</p>
</li>
</ol>
<h4 id="两阶段加锁"><a href="#两阶段加锁" class="headerlink" title="两阶段加锁"></a>两阶段加锁</h4><h4 id="通信死锁"><a href="#通信死锁" class="headerlink" title="通信死锁"></a>通信死锁</h4><p>以上都是资源死锁，可以通过<strong>调度的方式</strong>解决</p>
<p>通信死锁：<strong>超时（time out）</strong></p>
<h4 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h4><p>一对并行的进程用到了两个资源，分别获得另一个锁失败后，两个进程都释放自己持有的锁，再次进行尝试，该过程一直重复。</p>
<h4 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h4><p>进程永远得不到服务</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/OS/" rel="tag"># OS</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/09/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/" rel="prev" title="网络相关知识">
      <i class="fa fa-chevron-left"></i> 网络相关知识
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/16/Hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/" rel="next" title="Hexo-插入本地图片">
      Hexo-插入本地图片 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#认识操作系统"><span class="nav-text">认识操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#x86-系统的结构"><span class="nav-text">x86 系统的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#PCI-E"><span class="nav-text">PCI-E</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MDI"><span class="nav-text">MDI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#DMI"><span class="nav-text">DMI</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#USB"><span class="nav-text">USB</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#SCSI"><span class="nav-text">SCSI</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储器"><span class="nav-text">存储器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RAM"><span class="nav-text">RAM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ROM"><span class="nav-text">ROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#EEPROM"><span class="nav-text">EEPROM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Flash"><span class="nav-text">Flash</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主板"><span class="nav-text">主板</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本输入输出系统-Basic-Input-Output-System-BIOS"><span class="nav-text">基本输入输出系统(Basic Input Output System, BIOS)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互补金属氧化物半导体-Complementary-Metal-Oxide-Semiconductor-CMOS"><span class="nav-text">互补金属氧化物半导体(Complementary Metal Oxide Semiconductor , CMOS)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统"><span class="nav-text">操作系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分类"><span class="nav-text">分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程"><span class="nav-text">进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件"><span class="nav-text">文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能"><span class="nav-text">功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#系统调用"><span class="nav-text">系统调用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Win-32-API"><span class="nav-text">Win 32 API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统结构"><span class="nav-text">操作系统结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#单体系统"><span class="nav-text">单体系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分层系统"><span class="nav-text">分层系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#微内核"><span class="nav-text">微内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#客户-服务器模式"><span class="nav-text">客户-服务器模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程"><span class="nav-text">进程和线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程-1"><span class="nav-text">进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#进程模型"><span class="nav-text">进程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的创建"><span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的终止"><span class="nav-text">进程的终止</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的层次结构"><span class="nav-text">进程的层次结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程状态"><span class="nav-text">进程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#进程的实现"><span class="nav-text">进程的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程"><span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#线程的使用"><span class="nav-text">线程的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#经典的线程模型"><span class="nav-text">经典的线程模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程系统调用"><span class="nav-text">线程系统调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#POSIX线程（pthreads）"><span class="nav-text">POSIX线程（pthreads）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程实现"><span class="nav-text">线程实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程间通信（inter-process-communication）"><span class="nav-text">进程间通信（inter process communication）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#临界互斥："><span class="nav-text">临界互斥：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#忙等互斥-（都是忙等待）"><span class="nav-text">忙等互斥 （都是忙等待）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#睡眠和唤醒"><span class="nav-text">睡眠和唤醒</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#互斥量"><span class="nav-text">互斥量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#管程"><span class="nav-text">管程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#消息传递"><span class="nav-text">消息传递</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#屏障"><span class="nav-text">屏障</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#避免锁"><span class="nav-text">避免锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调度"><span class="nav-text">调度</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#调度介绍"><span class="nav-text">调度介绍</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批处理中的调度"><span class="nav-text">批处理中的调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交互式系统中的调度"><span class="nav-text">交互式系统中的调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实时系统中的调度"><span class="nav-text">实时系统中的调度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#调度策略和机制"><span class="nav-text">调度策略和机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程调度"><span class="nav-text">线程调度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存"><span class="nav-text">内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无存储器抽象"><span class="nav-text">无存储器抽象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一种存储器抽象：地址空间"><span class="nav-text">一种存储器抽象：地址空间</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基址寄存器和变址寄存器"><span class="nav-text">基址寄存器和变址寄存器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#交换技术"><span class="nav-text">交换技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#空闲内存管理"><span class="nav-text">空闲内存管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟内存"><span class="nav-text">虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#分页（paging）"><span class="nav-text">分页（paging）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页表"><span class="nav-text">页表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#加速分页过程"><span class="nav-text">加速分页过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#针对大内存的页表"><span class="nav-text">针对大内存的页表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最优页面置换算法"><span class="nav-text">最优页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近未使用（NRU）页面置换算法"><span class="nav-text">最近未使用（NRU）页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#先进先出（FIFO）页面置换法"><span class="nav-text">先进先出（FIFO）页面置换法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二次机会页面置换法"><span class="nav-text">第二次机会页面置换法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟页面置换算法（实际使用）"><span class="nav-text">时钟页面置换算法（实际使用）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最近最少使用（LRU）页面置换算法"><span class="nav-text">最近最少使用（LRU）页面置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作集页面置换法"><span class="nav-text">工作集页面置换法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#工作集时钟页面置换法"><span class="nav-text">工作集时钟页面置换法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-text">文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件-1"><span class="nav-text">文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件命名"><span class="nav-text">文件命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件结构"><span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件类型"><span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件访问"><span class="nav-text">文件访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件属性"><span class="nav-text">文件属性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件操作"><span class="nav-text">文件操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#目录"><span class="nav-text">目录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一级目录系统"><span class="nav-text">一级目录系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#层次目录系统"><span class="nav-text">层次目录系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径名"><span class="nav-text">路径名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录操作"><span class="nav-text">目录操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统的实现"><span class="nav-text">文件系统的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统布局"><span class="nav-text">文件系统布局</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件的实现"><span class="nav-text">文件的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#目录的实现"><span class="nav-text">目录的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享文件"><span class="nav-text">共享文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志结构文件系统"><span class="nav-text">日志结构文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日志文件系统"><span class="nav-text">日志文件系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#虚拟文件系统（Virtual-File-System，VFS-）"><span class="nav-text">虚拟文件系统（Virtual File System，VFS ）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件系统的管理和优化"><span class="nav-text">文件系统的管理和优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘空间管理"><span class="nav-text">磁盘空间管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘配额"><span class="nav-text">磁盘配额</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件备份系统"><span class="nav-text">文件备份系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统的一致性"><span class="nav-text">文件系统的一致性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#文件系统性能"><span class="nav-text">文件系统性能</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#I-O"><span class="nav-text">I&#x2F;O</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O设备"><span class="nav-text">I&#x2F;O设备</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#块设备（block-devices）"><span class="nav-text">块设备（block devices）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符设备"><span class="nav-text">字符设备</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备控制器"><span class="nav-text">设备控制器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存映射I-O"><span class="nav-text">内存映射I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#直接内存访问（DMA）"><span class="nav-text">直接内存访问（DMA）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#精确中断和不精确中断"><span class="nav-text">精确中断和不精确中断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#I-O软件原理"><span class="nav-text">I&#x2F;O软件原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用程序控制IO"><span class="nav-text">使用程序控制IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用中断驱动"><span class="nav-text">使用中断驱动</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用DMA的IO"><span class="nav-text">使用DMA的IO</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IO层次结构"><span class="nav-text">IO层次结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#中断服务程序（Interrupt-service-routines-ISR"><span class="nav-text">中断服务程序（Interrupt service routines,ISR)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#设备驱动程序"><span class="nav-text">设备驱动程序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#与设备无关的IO软件"><span class="nav-text">与设备无关的IO软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#用户空间的IO软件"><span class="nav-text">用户空间的IO软件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#盘"><span class="nav-text">盘</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#盘硬件"><span class="nav-text">盘硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RAID"><span class="nav-text">RAID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘格式化"><span class="nav-text">磁盘格式化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#磁盘调度算法"><span class="nav-text">磁盘调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#错误处理"><span class="nav-text">错误处理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#稳定器存储"><span class="nav-text">稳定器存储</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时钟"><span class="nav-text">时钟</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟硬件"><span class="nav-text">时钟硬件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时钟软件"><span class="nav-text">时钟软件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软定时器"><span class="nav-text">软定时器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#资源"><span class="nav-text">资源</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#资源获取"><span class="nav-text">资源获取</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#资源死锁"><span class="nav-text">资源死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁模型"><span class="nav-text">死锁模型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#鸵鸟算法"><span class="nav-text">鸵鸟算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的检测与恢复"><span class="nav-text">死锁的检测与恢复</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁避免"><span class="nav-text">死锁避免</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#破坏死锁"><span class="nav-text">破坏死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#两阶段加锁"><span class="nav-text">两阶段加锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通信死锁"><span class="nav-text">通信死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#活锁"><span class="nav-text">活锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#饥饿"><span class="nav-text">饥饿</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QQAI"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">QQAI</p>
  <div class="site-description" itemprop="description">Home is behind, the world ahead</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">43</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QQAI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
