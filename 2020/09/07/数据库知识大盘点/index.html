<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.1',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="转载来源：数据库面试题 数据库基本知识范式的定义改造关系模式，通过分解关系模型来消除其中不合适的数据依赖，以决绝插入异常，删除异常，数据用余。">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库知识点大总结">
<meta property="og:url" content="http://yoursite.com/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%9B%98%E7%82%B9/index.html">
<meta property="og:site_name" content="Ringinmay&#39;s Blog">
<meta property="og:description" content="转载来源：数据库面试题 数据库基本知识范式的定义改造关系模式，通过分解关系模型来消除其中不合适的数据依赖，以决绝插入异常，删除异常，数据用余。">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAwMzcucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAxMDAucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2MjkucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2NTgucG5n?x-oss-process=image/format,png">
<meta property="article:published_time" content="2020-09-07T13:25:42.000Z">
<meta property="article:modified_time" content="2020-09-16T03:13:17.375Z">
<meta property="article:author" content="QQAI">
<meta property="article:tag" content="SQL">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAwMzcucG5n?x-oss-process=image/format,png">

<link rel="canonical" href="http://yoursite.com/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%9B%98%E7%82%B9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true
  };
</script>

  <title>数据库知识点大总结 | Ringinmay's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Ringinmay's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">Home is behind, the world ahead</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="Searching..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/09/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E5%A4%A7%E7%9B%98%E7%82%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/header.jpg">
      <meta itemprop="name" content="QQAI">
      <meta itemprop="description" content="Home is behind, the world ahead">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ringinmay's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据库知识点大总结
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-09-07 21:25:42" itemprop="dateCreated datePublished" datetime="2020-09-07T21:25:42+08:00">2020-09-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-09-16 11:13:17" itemprop="dateModified" datetime="2020-09-16T11:13:17+08:00">2020-09-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">基础知识</span>
                  </a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>转载来源：<a href="https://blog.csdn.net/wugenqiang/article/details/106501338" target="_blank" rel="noopener">数据库面试题</a></p>
<h2 id="数据库基本知识"><a href="#数据库基本知识" class="headerlink" title="数据库基本知识"></a>数据库基本知识</h2><h3 id="范式的定义"><a href="#范式的定义" class="headerlink" title="范式的定义"></a>范式的定义</h3><p>改造关系模式，通过分解关系模型来消除其中不合适的数据依赖，以决绝插入异常，删除异常，数据用余。</p>
<a id="more"></a>
<h3 id="数据库三大范式是什么"><a href="#数据库三大范式是什么" class="headerlink" title="数据库三大范式是什么"></a>数据库三大范式是什么</h3><p>第一范式（1NF）：关系模式 R 中每个列都不可以再拆分。</p>
<p>第二范式（2NF）：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>
<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。</p>
<h3 id="mysql有关权限的表"><a href="#mysql有关权限的表" class="headerlink" title="mysql有关权限的表"></a>mysql有关权限的表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>
<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>
<li>table_priv权限表：记录数据表级的操作权限。</li>
<li>columns_priv权限表：记录数据列级的操作权限。</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>
</ul>
<h3 id="MySQL的binlog的3种录入格式"><a href="#MySQL的binlog的3种录入格式" class="headerlink" title="MySQL的binlog的3种录入格式"></a>MySQL的binlog的3种录入格式</h3><p>有三种格式，statement，row和mixed。</p>
<ul>
<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>
<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>
<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>
</ul>
<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>
<h3 id="⭐什么是数据字典"><a href="#⭐什么是数据字典" class="headerlink" title="⭐什么是数据字典"></a>⭐什么是数据字典</h3><p>数据字典是关系数据库管理系统内部的一组系统表，它<strong>记录了数据库中所有的定义信息</strong>，包括关系模式定义、视图定义、索引定义、完整性约束定义、各类用户对数据库的操作权限、统计信息等。<strong>关系数据库管理系统在执行 SQL 的数据定义语句时，实际上就是在更新数据字典中的相应信息</strong></p>
<h2 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h2><h3 id="关系型数据库和非关系型数据库比较"><a href="#关系型数据库和非关系型数据库比较" class="headerlink" title="关系型数据库和非关系型数据库比较"></a>关系型数据库和非关系型数据库比较</h3><h4 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库:"></a>关系型数据库:</h4><ul>
<li>采用了关系模型来组织数据的数据库，以行和列形式存储数据，以便于用户理解。</li>
<li>通用的 SQL 语言使得操作关系型数据库非常方便。</li>
<li>关系型数据库遵循 ACID 原则。</li>
<li>常见的关系型数据库比如 MySQL，Oracle</li>
</ul>
<p><strong>关系型数据库存在的问题</strong>：</p>
<ul>
<li>网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘 I/O 是一个很大的瓶颈</li>
<li>网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的。因此，关系型数据不适合持久存储海量数据</li>
<li>很难进行横向扩展（增加服务器），也就是说想要提高数据处理能力，要使用性能更好的计算机（纵向扩展）</li>
<li>性能欠佳：导致关系型数据库性能欠佳的最主要原因就是多表的关联查询，为了保证数据库的ACID特性，必须尽量按照范式要求设计数据库，关系数据库中的表存储的往往是一个固定的、格式化的数据结构</li>
</ul>
<p>而非关系型数据库就可以很好的解决关系型数据库很难解决的大数据问题</p>
<h4 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h4><ul>
<li>非关系型数据库以键值对存储，且结构不固定，每一个元组可以有不一样的字段，每个元组可以根据需要增加一些自己的键值对，不局限于固定的结构，可以减少一些时间和空间的开销。</li>
<li>支持分布式存储，容易进行横向扩展</li>
<li>不遵循 ACID 特性（不提供对事务的处理）</li>
<li>常见的非关系型数据库比如 Redis、MongoDB、Elasticsearch</li>
</ul>
<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h4 id="①-概述"><a href="#①-概述" class="headerlink" title="① 概述"></a>① 概述</h4><p>数据库连接池是负责分配、管理和释放数据库连接，它<strong>允许应用程序重复使用一个现有的数据库连接</strong>，而不是每次访问数据库的时候都需要重新建立一次连接。</p>
<h4 id="②-为什么要使用连接池"><a href="#②-为什么要使用连接池" class="headerlink" title="② 为什么要使用连接池"></a>② 为什么要使用连接池</h4><p><strong> 数据库连接是一种关键的有限的昂贵的资源</strong> ，这一点在多用户的网页应用程序中体现得尤为突出。 一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p>
<p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并将这些连接组成一个连接池，由应用程序动态地对池中的连接进行申请、使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。</p>
<p>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量、使用情况等。</p>
<h4 id="③-传统的连接机制与连接池运行机制区别"><a href="#③-传统的连接机制与连接池运行机制区别" class="headerlink" title="③ 传统的连接机制与连接池运行机制区别"></a>③ 传统的连接机制与连接池运行机制区别</h4><p>执行一个 SQL 命令</p>
<p><strong>不使用数据库连接池的步骤</strong>：</p>
<ul>
<li>TCP建立连接三次握手</li>
<li>MySQL认证三次握手</li>
<li>真正的SQL执行</li>
<li>MySQL关闭</li>
<li>TCP四次挥手关闭</li>
</ul>
<p>可以看到，为了执行一条SQL，却多了非常多网络交互，应用需要频繁的创建连接和关闭连接。</p>
<p><strong>使用数据库连接池的步骤</strong>：</p>
<p>第一次访问的时候，需要建立连接。 但是之后的访问，均会复用之前创建的连接，直接执行SQL语句。</p>
<h3 id="超键、候选键、主键、外键分别是什么"><a href="#超键、候选键、主键、外键分别是什么" class="headerlink" title="超键、候选键、主键、外键分别是什么"></a>超键、候选键、主键、外键分别是什么</h3><ul>
<li><strong>⭐超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>
<li><strong>⭐候选键</strong>：即最小超键，即没有冗余元素的超键。候选键中的元素称为<strong>主属性</strong></li>
<li><strong>主键</strong>：候选键中选出一个作为主键，一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>
<li><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</li>
</ul>
<h4 id="主键和外键的区别"><a href="#主键和外键的区别" class="headerlink" title="主键和外键的区别"></a>主键和外键的区别</h4><p>主键在本表中是唯一的、不可为空的，外键可以重复可以为空；外键和另一张表的主键关联，不能创建对应表中不存在的外键。</p>
<h3 id="主码和外码"><a href="#主码和外码" class="headerlink" title="主码和外码"></a>主码和外码</h3><p>若关系中某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>，若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。</p>
<p>如果F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的主码。如果F与Ks相对应，则称F是R的<strong>外码</strong>。</p>
<blockquote>
<p>类似外键：F不是R的主键，但是是另一个关系S的主键，则F是R的外键</p>
</blockquote>
<h3 id="⭐完整性约束"><a href="#⭐完整性约束" class="headerlink" title="⭐完整性约束"></a>⭐完整性约束</h3><p>数据库的完整性是指<strong>数据的正确性和相容性</strong>。</p>
<ul>
<li>数据的正确性是指数据是符合现实世界语义、反映当前实际状况的。</li>
<li>数据的相容性是指数据库同一对象在不同关系表中的数据是符合逻辑的。</li>
</ul>
<p>l <strong>实体完整性</strong>：若属性A是基本关系B的主属性，则A不能取空值（所谓空值是指不知道，不存在，无意义的值）</p>
<p>l <strong>参照完整性</strong>：若属性F是基本关系R的外码，它与基本关系S的主码Ks相对应，则对于R中每个元组在F上的值必须：</p>
<p>² 或者取空值（F的每个属性值均为空值）</p>
<p>² 或者等于S中某个元组的主码值</p>
<p>（某个同学班长属性可以是尚为选出班长，也可以是本关系中某个元组的学号值）</p>
<p>l <strong>用户定义完整性</strong>：针对某一具体关系数据库的约束条件，反映某一具体应用涉及的数据必须满足的语义要求（如某个属性必须取唯一值，某个非主属性不能取空值）</p>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL-的四个组成部分-⭐"><a href="#SQL-的四个组成部分-⭐" class="headerlink" title="SQL 的四个组成部分 ⭐"></a>SQL 的四个组成部分 ⭐</h3><ol>
<li>数据库模式定义语言DDL：create用来创建数据库中的各种对象——表、视图、索引、同义词、聚簇等</li>
<li>数据查询语言dql：基本结构是由SELECT子句，FROM子句和WHERE子句组成的查询块</li>
<li>数据操纵语言dml：插入INSERT、更新UPDATE和删除DELETE</li>
<li>数据控制语言dcl：用来授予或回收访问数据库的某种特权，并控制数据库操纵事物发生的时间和效果，对数据库实行监视等</li>
</ol>
<h3 id="SQL-约束"><a href="#SQL-约束" class="headerlink" title="SQL 约束"></a>SQL 约束</h3><ul>
<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>
<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>
<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>
<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>
<li>CHECK: 用于控制字段的值范围。</li>
</ul>
<h3 id="六种关联查询"><a href="#六种关联查询" class="headerlink" title="六种关联查询"></a>六种关联查询</h3><ul>
<li><p>交叉连接（CROSS JOIN）</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li><p>内连接（INNER JOIN）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A,B WHERE A.id&#x3D;B.id </span><br><span class="line">SELECT * FROM A INNER JOIN B ON A.id&#x3D;B.id #多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</span><br></pre></td></tr></table></figure>
<blockquote>
<p>等值连接：ON A.id=B.id</p>
<p>不等值连接：ON A.id &gt; B.id</p>
<p>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</p>
</blockquote>
</li>
<li><p>外连接（LEFT JOIN/RIGHT JOIN）</p>
<blockquote>
<p>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN<br>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</p>
</blockquote>
</li>
<li><p>联合查询（UNION与UNION ALL）</p>
<blockquote>
<p>把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并<br>如果使用UNION ALL，不会合并重复的记录行<br>效率 UNION 高于 UNION ALL</p>
</blockquote>
</li>
<li><p>全连接（FULL JOIN）</p>
<blockquote>
<p>MySQL不支持全连接<br>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</p>
</blockquote>
</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><blockquote>
<ol>
<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>
<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>
</ol>
</blockquote>
<h3 id="子查询的三种情况"><a href="#子查询的三种情况" class="headerlink" title="子查询的三种情况"></a>子查询的三种情况</h3><ul>
<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 查询工资最高的员工是谁？ </span><br><span class="line">select  * from employee where salary&#x3D;(select max(salary) from employee);</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id from Stduent where id in (select id from SC);</span><br></pre></td></tr></table></figure>
<ul>
<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-- 1) 查询出2011年以后入职的员工信息</span><br><span class="line">-- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。</span><br><span class="line">select * from dept d,  (select * from employee where join_date &gt; &#39;2011-1-1&#39;) e where e.dept_id &#x3D;  d.id;    </span><br><span class="line"></span><br><span class="line">-- 使用表连接：</span><br><span class="line">select d.*, e.* from  dept d inner join employee e on d.id &#x3D; e.dept_id where e.join_date &gt;  &#39;2011-1-1&#39;</span><br></pre></td></tr></table></figure>
<h3 id="in-和-exists-的区别"><a href="#in-和-exists-的区别" class="headerlink" title="in 和 exists 的区别"></a>in 和 exists 的区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select id from Student where id exists (select id from SC);</span><br><span class="line">select id from Stduent where id in (select id from SC);</span><br></pre></td></tr></table></figure>
<ul>
<li><p>in 先进行子查询 select id from SC，再进行外查询 select id from Student</p>
<p>exists 先执行外查询，再执行子查询</p>
</li>
<li><p>in 语句是把外表和内表作连接</p>
<p>而 exists 语句是对外表作循环，每次循环再对内表进行查询</p>
</li>
<li><p>exists 适合子查询的表比外查询大的查询语句</p>
<p>如果内表和外表差不多大，那么 in 和 exists 的效率差别不大</p>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAwMzcucG5n?x-oss-process=image/format,png" alt="image-20200429100036635"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDAxMDAucG5n?x-oss-process=image/format,png" alt="image-20200429100059106"></p>
<h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。</p>
<p>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。</p>
<p>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。仍占4字节存储，存储范围不变，不影响内部存储。</p>
<h4 id="实数类型"><a href="#实数类型" class="headerlink" title="实数类型"></a>实数类型</h4><p>FLOAT（存储至多8位十进制数，4字节）、DOUBLE（存储至多18位十进制数，8字节）、DECIMAL。</p>
<p>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>
<h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>year, date, time, datetime, timestep</p>
<p>尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。</p>
<h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>VARCHAR、CHAR、TEXT、BLOB</p>
<p>CHAR是定长的，根据定义的字符串长度分配足够的空间，会根据需要使用空格进行填充方便比较，适合存储很短的字符串，或者所有值都接近同一个长度。存储的内容超出设置的长度时，内容会被截断。</p>
<p>VARCHAR用于存储可变长字符串，列长度小于255字节时，使用1字节表示，否则使用2字节表示，存储的内容超出设置的长度时，内容会被截断，比定长类型更节省空间。使用额外1或2个字节存储字符串长度。</p>
<p>varchar(50)中50的表示最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>
<p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>
<h4 id="枚举类型（ENUM）"><a href="#枚举类型（ENUM）" class="headerlink" title="枚举类型（ENUM）"></a>枚举类型（ENUM）</h4><p>把不重复的数据存储为一个预定义的集合。</p>
<p>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>
<h3 id="drop、delete与truncate的区别"><a href="#drop、delete与truncate的区别" class="headerlink" title="drop、delete与truncate的区别"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p>
<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h4><p>1、delete是DML，执行delete操作时，每次从表中删除一行，并且同时将该行的的删除操作记录在redo和undo表空间中以便进行回滚（rollback）和重做操作，但要注意表空间要足够大，需要手动提交（commit）操作才能生效，可以通过rollback撤消操作。</p>
<p>2、delete可根据条件删除表中满足条件的数据，如果不指定where子句，那么删除表中所有记录。</p>
<p>3、delete语句不影响表所占用的extent，高水线(high watermark)保持原位置不变。</p>
<h4 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h4><p>1、truncate是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、truncate会删除表中所有记录，并且将重新设置高水线和所有的索引，缺省情况下将空间释放到minextents个extent，除非使用reuse storage，。不会记录日志，所以执行速度很快，但不能通过rollback撤消操作（如果一不小心把一个表truncate掉，也是可以恢复的，只是不能通过rollback来恢复）。</p>
<p>3、对于外键（foreignkey ）约束引用的表，不能使用 truncate table，而应使用不带 where 子句的 delete 语句。</p>
<p>4、truncatetable不能用于参与了索引视图的表。</p>
<h4 id="drop"><a href="#drop" class="headerlink" title="drop"></a>drop</h4><p>1、drop是DDL，会隐式提交，所以，不能回滚，不会触发触发器。</p>
<p>2、drop语句删除表结构及所有数据，并将表所占用的空间全部释放。</p>
<p>3、drop语句将删除表的结构所依赖的约束，触发器，索引，依赖于该表的存储过程/函数将保留,但是变为invalid状态。</p>
<h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>1、在速度上，一般来说，drop&gt; truncate &gt; delete。</p>
<p>2、在使用drop和truncate时一定要注意，虽然可以恢复，但为了减少麻烦，还是要慎重。</p>
<p>3、如果想删除部分数据用delete，注意带上where子句，回滚段要足够大；</p>
<p>   如果想删除表，当然用drop； </p>
<p>   如果想保留表而将所有数据删除，如果和事务无关，用truncate即可；</p>
<p>   如果和事务有关，或者想触发trigger，还是用delete；</p>
<p>   如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。</p>
<h3 id="SQL-的生命周期"><a href="#SQL-的生命周期" class="headerlink" title="SQL 的生命周期"></a>SQL 的生命周期</h3><ol>
<li>应用服务器与数据库服务器建立一个连接</li>
<li>数据库进程拿到请求sql</li>
<li>解析并生成执行计划，执行</li>
<li>读取数据到内存并进行逻辑处理</li>
<li>通过步骤一的连接，发送结果到客户端</li>
<li>关掉连接，释放资源</li>
</ol>
<h3 id="在数据库中查询语句速度很慢，应如何优化"><a href="#在数据库中查询语句速度很慢，应如何优化" class="headerlink" title="在数据库中查询语句速度很慢，应如何优化"></a>在数据库中查询语句速度很慢，应如何优化</h3><ol>
<li>建索引</li>
<li>减少表之间的关联</li>
<li>优化 SQL，尽量让 SQL 很快定位数据，不要让 SQL 做全表查询，应该走索引，把数据量大的表排在前面</li>
<li>简化查询字段，没用的字段不要，已经对返回结果的控制，尽量返回少量数据</li>
<li>尽量用 Prepared Statement 来查询，不要用 Statement</li>
</ol>
<h3 id="超大分页怎么处理？"><a href="#超大分页怎么处理？" class="headerlink" title="超大分页怎么处理？"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p>
<ul>
<li><p>数据库层面：核心减少load的数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 下面第一条语句需要load1000000数据，只取10条，基本上全部丢弃,所以很慢</span><br><span class="line">select * from table where age &gt; 20 limit 1000000,10</span><br><span class="line">select * from table where id in (select id from table where age &gt; 20 limit 1000000,10)</span><br><span class="line"></span><br><span class="line">select * from table where id &gt; 1000000 limit 10</span><br></pre></td></tr></table></figure>
</li>
<li><p>从需求的角度减少这种请求：不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</p>
</li>
</ul>
<h3 id="Union-和-Union-All-有什么不同"><a href="#Union-和-Union-All-有什么不同" class="headerlink" title="Union 和 Union All 有什么不同"></a>Union 和 Union All 有什么不同</h3><p>UNION 在进行表链接后会筛选掉重复的记录，所以在表链接后会对所产生的结果集进行排序运算，删除重复的记录再返回结果。实际大部分应用中是不会产生重复的记录，最常见的是过程表与历史表 UNION。 </p>
<p>UNION ALL 只是简单的将两个结果合并后就返回。 </p>
<p>从效率上说，UNION ALL 要比 UNION 快很多，如果可以确认合并的两个结果集中不包含重复的数据的话，那么就使用 UNION ALL。</p>
<h3 id="order-by-和-group-by-的区别"><a href="#order-by-和-group-by-的区别" class="headerlink" title="order by 和 group by 的区别"></a>order by 和 group by 的区别</h3><p>order by 排序查询、asc 升序、desc 降序 </p>
<p>group by 分组查询、having 只能用于 group by 子句，作用于组内，having 条件子句可以直接跟函数表达式。使用 group by 子句的查询语句需要使用聚合函数。</p>
<h3 id="什么是-PL-SQL"><a href="#什么是-PL-SQL" class="headerlink" title="什么是 PL / SQL"></a>什么是 PL / SQL</h3><p>PL / SQL 是一种程序语言，叫做过程化 SQL 语言（Procedural Language/SQL）。PL / SQL 是 Oracle 数据库对 SQL 语句的扩展。在普通 SQL 语句的使用上增加了编程语言的特点，所以 PL / SQL 把数据操作和查询语句组织在 PL / SQL 代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算。</p>
<p>PL / SQL 只有 Oracle 数据库有。 MySQL 目前不支持 PL / SQL 的。</p>
<h2 id="引擎"><a href="#引擎" class="headerlink" title="引擎"></a>引擎</h2><p>存储引擎Storage engine：数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>
<p>常用的存储引擎有以下：</p>
<ol>
<li>Innodb引擎：提供了对数据库ACID事务的支持，还提供了行级锁和外键的约束。它的设计目标就是处理大数据容量的数据库系统。</li>
<li>MyIASM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>
<li>MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>
</ol>
<h3 id="MySQL存储引擎MyISAM与InnoDB区别"><a href="#MySQL存储引擎MyISAM与InnoDB区别" class="headerlink" title="MySQL存储引擎MyISAM与InnoDB区别"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2MjkucG5n?x-oss-process=image/format,png" alt="image-20200429100628653"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vd3VnZW5xaWFuZy9QaWN0dXJlQmVkL3Jhdy9tYXN0ZXIvQ1MtTm90ZXMvMjAyMDA0MjkxMDA2NTgucG5n?x-oss-process=image/format,png" alt="image-20200429100657751"></p>
<blockquote>
<p>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。<br>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。<br>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。<br>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p>
</blockquote>
<h3 id="InnoDB引擎的4大特性"><a href="#InnoDB引擎的4大特性" class="headerlink" title="InnoDB引擎的4大特性"></a>InnoDB引擎的4大特性</h3><blockquote>
<ul>
<li>插入缓冲（insert buffer)</li>
<li>二次写(double write)</li>
<li>自适应哈希索引(ahi)</li>
<li>预读(read ahead)</li>
</ul>
</blockquote>
<h3 id="存储引擎选择"><a href="#存储引擎选择" class="headerlink" title="存储引擎选择"></a>存储引擎选择</h3><blockquote>
<p>如果没有特别的需求，使用默认的<code>Innodb</code>即可。</p>
<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>
<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>
</blockquote>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul>
<li>索引是一种特殊的文件（InnoDB 数据表上的索引是表空间的一个组成部分），包含对数据表里所有记录的引用指针。</li>
<li>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用 B 树及其变种 B + 树。</li>
<li>索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，需要占据物理空间。</li>
</ul>
<h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><p>索引就一种特殊的查询表，数据库的搜索可以利用它加速对数据的检索。如果没有索引，一般来说执行查询时遍历整张表。</p>
<h3 id="添加索引目的"><a href="#添加索引目的" class="headerlink" title="添加索引目的"></a>添加索引目的</h3><p>提高数据查询的效率</p>
<h3 id="聚集索引和非聚集索引-⭐"><a href="#聚集索引和非聚集索引-⭐" class="headerlink" title="聚集索引和非聚集索引 ⭐"></a>聚集索引和非聚集索引 ⭐</h3><p>物理存储顺序与逻辑顺序相同，即聚集索引（InnoDB）</p>
<p>物理存储顺序与索引顺序不一致，即非聚集索引（MyISAM）</p>
<h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p>优点</p>
<ul>
<li>加快数据的检索速度，这也是创建索引的最主要的原因。</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>
</ul>
<p>缺点</p>
<ul>
<li>时间方面：创建索引和维护索引要耗费时间，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>
<li>空间方面：索引需要占物理空间。</li>
</ul>
<h3 id="什么样的字段适合建索引"><a href="#什么样的字段适合建索引" class="headerlink" title="什么样的字段适合建索引"></a>什么样的字段适合建索引</h3><p>唯一、不为空、经常被查询的字段</p>
<h3 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h3><p>主键索引: 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>
<p>唯一索引: 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>
<ul>
<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>
<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</li>
</ul>
<p>普通索引: 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>
<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>
</ul>
<p>全文索引： 是目前搜索引擎使用的一种关键技术。（InnoDB不支持，MyISAM支持）</p>
<ul>
<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>
</ul>
<h3 id="索引的数据结构"><a href="#索引的数据结构" class="headerlink" title="索引的数据结构"></a>索引的数据结构</h3><h3 id="索引的基本原理"><a href="#索引的基本原理" class="headerlink" title="索引的基本原理"></a>索引的基本原理</h3><p>索引的原理就是把无序的数据变成有序的查询，把创建了索引的列的内容进行排序，对排序结果生成倒排表，在倒排表内容上拼上数据地址链。在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据。</p>
<h3 id="索引算法"><a href="#索引算法" class="headerlink" title="索引算法"></a>索引算法</h3><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><p>Mysql数据库中最常用的索引算法，基本所有存储引擎都支持BTree索引。（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）。不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 只要它的查询条件是一个不以通配符开头的常量</span><br><span class="line">select * from user where name like &#39;jack%&#39;; </span><br><span class="line">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： </span><br><span class="line">select * from user where name like &#39;%jack&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>B+ tree性质：</strong></p>
<ol>
<li>n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</li>
<li>所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</li>
<li>所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</li>
<li>B+ 树中，数据对象的插入和删除仅在叶节点上进行。</li>
<li>B+ 树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</li>
</ol>
<h4 id="B树和B-树的区别"><a href="#B树和B-树的区别" class="headerlink" title="B树和B+树的区别"></a>B树和B+树的区别</h4><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>B tree</th>
<th>B+ tree</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><strong>内部节点和叶子节点存放键和值</strong>    把频繁访问的数据放在靠近根节点的地方可以提高热点数据的查询效率。</td>
<td><strong>内部节点都是键，没有值，叶子节点同时存放键和值 </strong>    因此一次读取可以在内存页中获取更多的键，有利于更快地缩小查找范围,空间利用率更高，可减少I/O次数，磁盘读写代价更低（因为索引本身很大，不可能全部存储在内存中，往往以索引文件的形式存储的磁盘上）</td>
</tr>
<tr>
<td></td>
<td><strong>叶子节点各自独立</strong>  遍历时需要对树的每一层进行遍历，需要更多的内存置换次数，花费更多的时间</td>
<td><strong>叶子节点有一条链相连</strong>    当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。</td>
</tr>
<tr>
<td></td>
<td>只适合随机检索</td>
<td>同时支持随机检索和顺序检索</td>
</tr>
<tr>
<td></td>
<td>B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td><strong>查询效率更加稳定</strong>    顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</td>
</tr>
</tbody>
</table>
</div>
<h4 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h4><p>类似于数据结构中简单实现的HASH表（散列表）一样，在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p>
<p>Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于B Tree索引。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>item</th>
<th>Hash</th>
<th>B+ tree</th>
</tr>
</thead>
<tbody>
<tr>
<td>底层实现原理</td>
<td>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。</td>
<td>B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</td>
</tr>
<tr>
<td></td>
<td>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</td>
<td></td>
</tr>
<tr>
<td></td>
<td>经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。不支持使用索引进行排序， 不支持模糊查询以及多列索引的最左前缀匹配（因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。）</td>
<td></td>
</tr>
<tr>
<td></td>
<td>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。</td>
<td>B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低</td>
</tr>
</tbody>
</table>
</div>
<h3 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>
<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>
<p>实操的难度：在于前缀截取的长度。</p>
<p>可以利用<code>select count(*)/count(distinct left(password,prefixLen))</code>;，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p>
<h3 id="最左前缀原则-amp-最左匹配原则"><a href="#最左前缀原则-amp-最左匹配原则" class="headerlink" title="最左前缀原则&amp;最左匹配原则"></a>最左前缀原则&amp;最左匹配原则</h3><p>最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</p>
<p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</p>
<h3 id="创建索引的原则"><a href="#创建索引的原则" class="headerlink" title="创建索引的原则"></a>创建索引的原则</h3><ol>
<li>最左前缀匹配原则：组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)停止匹配</li>
<li>较频繁作为查询条件的字段才去创建索引, 对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</li>
<li>更新频繁字段不适合创建索引</li>
<li>不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</li>
<li>尽量扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</li>
<li>定义有外键的数据列一定要建立索引。</li>
<li>对于定义为text、image和bit的数据类型的列不要建立索引。</li>
</ol>
<h3 id="创建，删除索引"><a href="#创建，删除索引" class="headerlink" title="创建，删除索引"></a>创建，删除索引</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><ul>
<li>非空字段：应该指定列为NOT NULL，除非想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。应该用0、一个特殊的值或者一个空串代替空值；</li>
<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多，字段的离散程度高；</li>
<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>
</ul>
<h5 id="在执行CREATE-TABLE时创建索引"><a href="#在执行CREATE-TABLE时创建索引" class="headerlink" title="在执行CREATE TABLE时创建索引"></a>在执行CREATE TABLE时创建索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE user_index2 (</span><br><span class="line">	id INT auto_increment PRIMARY KEY,</span><br><span class="line">	first_name VARCHAR (16),</span><br><span class="line">	last_name VARCHAR (16),</span><br><span class="line">	id_card VARCHAR (18),</span><br><span class="line">	information text,</span><br><span class="line">	KEY name (first_name, last_name),</span><br><span class="line">	FULLTEXT KEY (information),</span><br><span class="line">	UNIQUE KEY (id_card)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="使用ALTER-TABLE命令去增加索引"><a href="#使用ALTER-TABLE命令去增加索引" class="headerlink" title="使用ALTER TABLE命令去增加索引"></a>使用ALTER TABLE命令去增加索引</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD INDEX index_name (column_list);</span><br></pre></td></tr></table></figure>
<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>
<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>
<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>
<h5 id="使用CREATE-INDEX命令创建"><a href="#使用CREATE-INDEX命令创建" class="headerlink" title="使用CREATE INDEX命令创建"></a>使用CREATE INDEX命令创建</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name ON table_name (column_list);</span><br></pre></td></tr></table></figure>
<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>根据索引名删除普通索引、唯一索引、全文索引：<code>alter table 表名 drop KEY 索引名</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index drop KEY name;</span><br><span class="line">alter table user_index drop KEY id_card;</span><br><span class="line">alter table user_index drop KEY information;</span><br></pre></td></tr></table></figure>
<p>删除主键索引：<code>alter table 表名 drop primary key</code>（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引），需要取消自增长再行删除：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alter table user_index</span><br><span class="line">-- 重新定义字段</span><br><span class="line">MODIFY id int,</span><br><span class="line">drop PRIMARY KEY</span><br></pre></td></tr></table></figure>
<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>
<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3><h4 id="使用索引查询一定能提高查询的性能吗？"><a href="#使用索引查询一定能提高查询的性能吗？" class="headerlink" title="使用索引查询一定能提高查询的性能吗？"></a>使用索引查询一定能提高查询的性能吗？</h4><p>通常，通过索引查询数据比全表扫描要快。但是它也有代价。</p>
<p>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，不必要的索引反而会使查询反应时间变慢。</p>
<p>使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</p>
<ul>
<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>
<li>基于非唯一性索引的检索</li>
</ul>
<h4 id="如何删除百万级别或以上的数据"><a href="#如何删除百万级别或以上的数据" class="headerlink" title="如何删除百万级别或以上的数据"></a>如何删除百万级别或以上的数据</h4><p>对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。</p>
<p>要删除百万数据时</p>
<ol>
<li>先删除索引（此时大概耗时三分多钟）</li>
<li>删除其中无用数据（此过程需要不到两分钟）</li>
<li>重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>
</ol>
<h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><p>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据<br>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。</p>
<p>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</p>
<h4 id="非聚簇索引一定会回表查询吗？"><a href="#非聚簇索引一定会回表查询吗？" class="headerlink" title="非聚簇索引一定会回表查询吗？"></a>非聚簇索引一定会回表查询吗？</h4><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>
<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行<code>select age from employee where age &lt; 20</code>的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>
<h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>
<h4 id="为什么需要注意联合索引中的顺序？"><a href="#为什么需要注意联合索引中的顺序？" class="headerlink" title="为什么需要注意联合索引中的顺序？"></a>为什么需要注意联合索引中的顺序？</h4><p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>
<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。</p>
<p>事务是指一个单元的工作，要么全做，要么全不做，事务是逻辑上的一组操作，保证一组数据的修改要么全部执行，要么全部不执行。</p>
<blockquote>
<p>举例：事务最经典也经常被拿出来说例子就是转账了。</p>
<p>假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作就是：将小明的余额减少 1000 元，将小红的余额增加 1000 元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
</blockquote>
<h3 id="事物的四大特性-ACID"><a href="#事物的四大特性-ACID" class="headerlink" title="事物的四大特性(ACID)"></a>事物的四大特性(ACID)</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>
<ul>
<li>原子性： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h3 id="脏读，幻读，不可重复读"><a href="#脏读，幻读，不可重复读" class="headerlink" title="脏读，幻读，不可重复读"></a>脏读，幻读，不可重复读</h3><ul>
<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>
<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>
<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>
</ul>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>SQL 标准定义了四个隔离级别：</p>
<ol>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ol>
<h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h3><p>在所有的 DBMS 中，<strong>锁是实现事务的关键，锁可以保证事务的完整性和并发性</strong>。与现实生活中锁一样，它可以是某些数据的拥有者，在某段时间内不能使用某些数据或数据结构。当然锁还分级别的。</p>
<h3 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h3><ol>
<li>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</li>
<li>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</li>
<li>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</li>
<li>SERIALIZABLE 是限制性最强的隔离级别，因为该级别锁定整个范围的键，并一直持有锁，直到事务完成。</li>
</ol>
<h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="按照锁的粒度划分"><a href="#按照锁的粒度划分" class="headerlink" title="按照锁的粒度划分"></a>按照锁的粒度划分</h4><p>在关系型数据库中，按照锁的粒度把数据库锁分为<strong>行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</strong></p>
<p>MyISAM采用表级锁(table-level locking)<br>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>行级锁</th>
<th>表级锁</th>
<th>页级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁</td>
<td>MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。</td>
<td>MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</td>
</tr>
<tr>
<td>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</td>
<td>开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</td>
<td>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</td>
</tr>
</tbody>
</table>
</div>
<h4 id="按照锁的类别划分"><a href="#按照锁的类别划分" class="headerlink" title="按照锁的类别划分"></a>按照锁的类别划分</h4><p><strong>共享锁</strong>: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>
<p><strong>排他锁</strong>: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>
<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>
<p>常见的解决死锁的方法</p>
<ol>
<li>如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</li>
<li>在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</li>
<li>对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</li>
<li>如果业务处理不好可以用分布式事务锁或者使用乐观锁</li>
</ol>
<h3 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。<strong>乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</strong></p>
<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>
<blockquote>
<p>多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以一般多写的场景下用悲观锁就比较合适。</p>
</blockquote>
<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：一般会使用版本号机制或CAS算法实现。</p>
<blockquote>
<p>乐观锁适用于写比较少的情况下（多读场景），即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>
</blockquote>
<h3 id="问题：-1"><a href="#问题：-1" class="headerlink" title="问题："></a>问题：</h3><h4 id="MySQL中InnoDB引擎的行锁"><a href="#MySQL中InnoDB引擎的行锁" class="headerlink" title="MySQL中InnoDB引擎的行锁"></a>MySQL中InnoDB引擎的行锁</h4><p>InnoDB是基于索引来完成行锁</p>
<p>例: <code>select * from tab_with_index where id = 1 for update;</code></p>
<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p>
<h4 id="InnoDB存储引擎的锁的算法"><a href="#InnoDB存储引擎的锁的算法" class="headerlink" title="InnoDB存储引擎的锁的算法"></a>InnoDB存储引擎的锁的算法</h4><ul>
<li><p>Record lock：单个行记录上的锁</p>
<blockquote>
<p>当查询的索引含有唯一属性时，将next-key lock降级为record key</p>
</blockquote>
</li>
<li><p>Gap lock：间隙锁，锁定一个范围，不包括记录本身</p>
<blockquote>
<p>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，这会导致幻读问题<br>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock）</p>
<p> A. 将事务隔离级别设置为RC </p>
<p>B. 将参数innodb_locks_unsafe_for_binlog设置为1</p>
</blockquote>
</li>
<li><p>Next-key lock：record+gap 锁定一个范围，包含记录本身</p>
<blockquote>
<p>Next-locking keying为了解决Phantom Problem幻读问题</p>
<p>innodb对于行的查询使用next-key lock</p>
</blockquote>
</li>
</ul>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="什么是视图"><a href="#什么是视图" class="headerlink" title="什么是视图"></a>什么是视图</h3><p>视图本质上是一种虚拟表，在物理上是不存在的，具有和物理表相同的功能，其内容与真实的表相似，包含一系列带有名称的列和行数据，可以对视图进行增，改，查，操作，但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>
<h3 id="为什么要使用视图"><a href="#为什么要使用视图" class="headerlink" title="为什么要使用视图"></a>为什么要使用视图</h3><p>为了提高复杂 SQL 语句的复用性和表操作的安全性，数据库管理系统提供了视图特性。视图使得开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>
<h3 id="视图有哪些特点"><a href="#视图有哪些特点" class="headerlink" title="视图有哪些特点"></a>视图有哪些特点</h3><ol>
<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>
<li>视图是由基本表(实表)产生的表(虚表)。</li>
<li>视图的建立和删除不影响基本表。</li>
<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>
<li>当视图来自多个基本表时，不允许添加和删除数据。</li>
<li>视图的操作包括创建视图，查看视图，删除视图和修改视图。</li>
</ol>
<h3 id="视图的优缺点"><a href="#视图的优缺点" class="headerlink" title="视图的优缺点"></a>视图的优缺点</h3><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol>
<li>查询简单化：视图能简化用户的操作</li>
<li>数据安全性：视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>
<li>逻辑数据独立性：视图对重构数据库提供了一定程度的逻辑独立性</li>
</ol>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol>
<li>性能：数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</li>
<li>修改限制：当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的。</li>
</ol>
<h3 id="问题：-2"><a href="#问题：-2" class="headerlink" title="问题："></a>问题：</h3><h4 id="视图的使用场景有哪些"><a href="#视图的使用场景有哪些" class="headerlink" title="视图的使用场景有哪些"></a>视图的使用场景有哪些</h4><p>视图根本用途：简化 SQL 查询，提高开发效率。兼容老的表结构。</p>
<p>常见使用场景：</p>
<ol>
<li>重用 SQL 语句；</li>
<li>简化复杂的 SQL 操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>
<li>使用表的组成部分而不是整个表；</li>
<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>
<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>
</ol>
<h4 id="表和视图的关系"><a href="#表和视图的关系" class="headerlink" title="表和视图的关系"></a>表和视图的关系</h4><p>视图其实就是一条查询 SQL 语句，用于显示一个或多个表或其他视图中的相关数据。 </p>
<p>表是关系数据库中实际存储数据用的。</p>
<h4 id="什么是游标"><a href="#什么是游标" class="headerlink" title="什么是游标"></a>什么是游标</h4><p>游标是系统为用户开设的一个数据缓冲区，存放 SQL 语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>
<h2 id="存储过程与函数"><a href="#存储过程与函数" class="headerlink" title="存储过程与函数"></a>存储过程与函数</h2><h3 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程"></a>什么是存储过程</h3><p>存储过程是一个预编译的 SQL 语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次 SQL，使用存储过程比单纯 SQL 语句执行要快。</p>
<h3 id="存储过程用什么来调用"><a href="#存储过程用什么来调用" class="headerlink" title="存储过程用什么来调用"></a>存储过程用什么来调用</h3><ul>
<li>可以用一个命令对象来调用存储过程。</li>
<li>可以供外部程序调用，比如：Java 程序。</li>
</ul>
<h3 id="存储过程的优缺点"><a href="#存储过程的优缺点" class="headerlink" title="存储过程的优缺点"></a>存储过程的优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol>
<li>存储过程是预编译过的，执行效率高。</li>
<li>存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</li>
<li>安全性高，执行存储过程需要有一定权限的用户。</li>
<li>存储过程可以重复使用，减少数据库开发人员的工作量。</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol>
<li>调试麻烦，但是用 PL/SQL Developer 调试很方便。</li>
<li>移植性差，数据库端代码当然是与数据库相关的。但如果是工程型项目，基本不存在移植问题。</li>
<li>重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（也可以设置成运行时刻自动编译）。</li>
<li>如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，如果用户很难维护该系统</li>
</ol>
<h3 id="存储过程与函数的区别"><a href="#存储过程与函数的区别" class="headerlink" title="存储过程与函数的区别"></a>存储过程与函数的区别</h3><div class="table-container">
<table>
<thead>
<tr>
<th>存储过程</th>
<th>函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>用于在数据库中完成特定的操作或者任务（如插入、删除等）</td>
<td>用于特定的数据（如选择）</td>
</tr>
<tr>
<td>程序头部声明用 procedure</td>
<td>程序头部声明用 function</td>
</tr>
<tr>
<td>程序头部声明时不需描述返回类型</td>
<td>程序头部声明时要描述返回类型，而且 PL / SQL 块中至少要包括一个有效的 return 语句</td>
</tr>
<tr>
<td>可以使用 in / out / in out 三种模式的参数</td>
<td>可以使用 in / out /in out 三种模式的参数</td>
</tr>
<tr>
<td>可作为一个独立的 PL / SQL 语句来执行</td>
<td>不能独立执行，必须作为表达式的一部分调用</td>
</tr>
<tr>
<td>可以通过 out / in out 返回零个或多个值</td>
<td>通过 return 语句返回一个值，且改值要与声明部分一致，也可以是通过 out 类型的参数带出的变量</td>
</tr>
<tr>
<td>SQL 语句( DML 或 SELECT )中不可调用存储过程</td>
<td>SQL 语句( DML 或 SELECT )中可以调用函数</td>
</tr>
</tbody>
</table>
</div>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h3><p>触发器是<strong>用户定义在关系表上的一类由事件驱动的特殊的存储过程</strong>，触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>
<p>主要是通过事件来触发而被执行的。可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p>
<h3 id="触发器的使用场景"><a href="#触发器的使用场景" class="headerlink" title="触发器的使用场景"></a>触发器的使用场景</h3><p>可以通过数据库中的相关表实现级联更改。<br>实时监控某张表中的某个字段的更改而需要做出相应的处理。例如可以生成某些业务的编号。</p>
<h3 id="MySQL中的触发器"><a href="#MySQL中的触发器" class="headerlink" title="MySQL中的触发器"></a>MySQL中的触发器</h3><p>在 MySQL 数据库中有如下六种触发器：</p>
<ul>
<li>Before Insert</li>
<li>After Insert</li>
<li>Before Update</li>
<li>After Update</li>
<li>Before Delete</li>
<li>After Delete</li>
</ul>
<h3 id="事前触发和事后触发的区别"><a href="#事前触发和事后触发的区别" class="headerlink" title="事前触发和事后触发的区别"></a>事前触发和事后触发的区别</h3><p>事前触发器运行于触发事件发生之前，事后触发器运行于触发事件发生之后。</p>
<p>通常事前触发器可以获取事件之前和新的字段值。</p>
<h3 id="语句级触发和行级触发有何区别"><a href="#语句级触发和行级触发有何区别" class="headerlink" title="语句级触发和行级触发有何区别"></a>语句级触发和行级触发有何区别</h3><p>语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/SQL/" rel="tag"># SQL</a>
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
              <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/07/SQL%E5%92%8CMySQL/" rel="prev" title="SQL和MySQL">
      <i class="fa fa-chevron-left"></i> SQL和MySQL
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/09/%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86/" rel="next" title="网络相关知识">
      网络相关知识 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库基本知识"><span class="nav-text">数据库基本知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#范式的定义"><span class="nav-text">范式的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库三大范式是什么"><span class="nav-text">数据库三大范式是什么</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mysql有关权限的表"><span class="nav-text">mysql有关权限的表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL的binlog的3种录入格式"><span class="nav-text">MySQL的binlog的3种录入格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#⭐什么是数据字典"><span class="nav-text">⭐什么是数据字典</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系数据库"><span class="nav-text">关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系型数据库和非关系型数据库比较"><span class="nav-text">关系型数据库和非关系型数据库比较</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#关系型数据库"><span class="nav-text">关系型数据库:</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非关系型数据库-NoSQL"><span class="nav-text">非关系型数据库 NoSQL</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库连接池"><span class="nav-text">数据库连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#①-概述"><span class="nav-text">① 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#②-为什么要使用连接池"><span class="nav-text">② 为什么要使用连接池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#③-传统的连接机制与连接池运行机制区别"><span class="nav-text">③ 传统的连接机制与连接池运行机制区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超键、候选键、主键、外键分别是什么"><span class="nav-text">超键、候选键、主键、外键分别是什么</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主键和外键的区别"><span class="nav-text">主键和外键的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主码和外码"><span class="nav-text">主码和外码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#⭐完整性约束"><span class="nav-text">⭐完整性约束</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用SQL语句"><span class="nav-text">常用SQL语句</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-的四个组成部分-⭐"><span class="nav-text">SQL 的四个组成部分 ⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-约束"><span class="nav-text">SQL 约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#六种关联查询"><span class="nav-text">六种关联查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子查询"><span class="nav-text">子查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#子查询的三种情况"><span class="nav-text">子查询的三种情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#in-和-exists-的区别"><span class="nav-text">in 和 exists 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据类型"><span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#整数类型"><span class="nav-text">整数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实数类型"><span class="nav-text">实数类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#日期和时间类型"><span class="nav-text">日期和时间类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#字符串类型"><span class="nav-text">字符串类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举类型（ENUM）"><span class="nav-text">枚举类型（ENUM）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#drop、delete与truncate的区别"><span class="nav-text">drop、delete与truncate的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#delete"><span class="nav-text">delete</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#truncate"><span class="nav-text">truncate</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#drop"><span class="nav-text">drop</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#总结："><span class="nav-text">总结：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-的生命周期"><span class="nav-text">SQL 的生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在数据库中查询语句速度很慢，应如何优化"><span class="nav-text">在数据库中查询语句速度很慢，应如何优化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#超大分页怎么处理？"><span class="nav-text">超大分页怎么处理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Union-和-Union-All-有什么不同"><span class="nav-text">Union 和 Union All 有什么不同</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#order-by-和-group-by-的区别"><span class="nav-text">order by 和 group by 的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是-PL-SQL"><span class="nav-text">什么是 PL &#x2F; SQL</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引擎"><span class="nav-text">引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL存储引擎MyISAM与InnoDB区别"><span class="nav-text">MySQL存储引擎MyISAM与InnoDB区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InnoDB引擎的4大特性"><span class="nav-text">InnoDB引擎的4大特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储引擎选择"><span class="nav-text">存储引擎选择</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引"><span class="nav-text">索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是索引"><span class="nav-text">什么是索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的作用"><span class="nav-text">索引的作用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#添加索引目的"><span class="nav-text">添加索引目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#聚集索引和非聚集索引-⭐"><span class="nav-text">聚集索引和非聚集索引 ⭐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的优缺点"><span class="nav-text">索引的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#什么样的字段适合建索引"><span class="nav-text">什么样的字段适合建索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引类型"><span class="nav-text">索引类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的数据结构"><span class="nav-text">索引的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引的基本原理"><span class="nav-text">索引的基本原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引算法"><span class="nav-text">索引算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B树索引"><span class="nav-text">B树索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B树和B-树的区别"><span class="nav-text">B树和B+树的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#哈希索引"><span class="nav-text">哈希索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#前缀索引"><span class="nav-text">前缀索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最左前缀原则-amp-最左匹配原则"><span class="nav-text">最左前缀原则&amp;最左匹配原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建索引的原则"><span class="nav-text">创建索引的原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建，删除索引"><span class="nav-text">创建，删除索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#创建索引"><span class="nav-text">创建索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#删除索引"><span class="nav-text">删除索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题："><span class="nav-text">问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#使用索引查询一定能提高查询的性能吗？"><span class="nav-text">使用索引查询一定能提高查询的性能吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#如何删除百万级别或以上的数据"><span class="nav-text">如何删除百万级别或以上的数据</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚簇索引与非聚簇索引"><span class="nav-text">聚簇索引与非聚簇索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#非聚簇索引一定会回表查询吗？"><span class="nav-text">非聚簇索引一定会回表查询吗？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#联合索引"><span class="nav-text">联合索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么需要注意联合索引中的顺序？"><span class="nav-text">为什么需要注意联合索引中的顺序？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事务"><span class="nav-text">事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是事务"><span class="nav-text">什么是事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事物的四大特性-ACID"><span class="nav-text">事物的四大特性(ACID)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#脏读，幻读，不可重复读"><span class="nav-text">脏读，幻读，不可重复读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事务的隔离级别"><span class="nav-text">事务的隔离级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#锁"><span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是锁"><span class="nav-text">什么是锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#隔离级别与锁的关系"><span class="nav-text">隔离级别与锁的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的分类"><span class="nav-text">锁的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#按照锁的粒度划分"><span class="nav-text">按照锁的粒度划分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#按照锁的类别划分"><span class="nav-text">按照锁的类别划分</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁"><span class="nav-text">死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库的乐观锁和悲观锁"><span class="nav-text">数据库的乐观锁和悲观锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题：-1"><span class="nav-text">问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL中InnoDB引擎的行锁"><span class="nav-text">MySQL中InnoDB引擎的行锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#InnoDB存储引擎的锁的算法"><span class="nav-text">InnoDB存储引擎的锁的算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#视图"><span class="nav-text">视图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是视图"><span class="nav-text">什么是视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#为什么要使用视图"><span class="nav-text">为什么要使用视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图有哪些特点"><span class="nav-text">视图有哪些特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图的优缺点"><span class="nav-text">视图的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点："><span class="nav-text">优点：</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点："><span class="nav-text">缺点：</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题：-2"><span class="nav-text">问题：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#视图的使用场景有哪些"><span class="nav-text">视图的使用场景有哪些</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表和视图的关系"><span class="nav-text">表和视图的关系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#什么是游标"><span class="nav-text">什么是游标</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#存储过程与函数"><span class="nav-text">存储过程与函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是存储过程"><span class="nav-text">什么是存储过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储过程用什么来调用"><span class="nav-text">存储过程用什么来调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储过程的优缺点"><span class="nav-text">存储过程的优缺点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点"><span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点"><span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储过程与函数的区别"><span class="nav-text">存储过程与函数的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#触发器"><span class="nav-text">触发器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是触发器"><span class="nav-text">什么是触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触发器的使用场景"><span class="nav-text">触发器的使用场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL中的触发器"><span class="nav-text">MySQL中的触发器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#事前触发和事后触发的区别"><span class="nav-text">事前触发和事后触发的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语句级触发和行级触发有何区别"><span class="nav-text">语句级触发和行级触发有何区别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="QQAI"
      src="/images/header.jpg">
  <p class="site-author-name" itemprop="name">QQAI</p>
  <div class="site-description" itemprop="description">Home is behind, the world ahead</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">29</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">QQAI</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.1
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.1
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

</body>
</html>
